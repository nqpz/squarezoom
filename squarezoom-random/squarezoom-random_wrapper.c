// Generated by Futhark 0.26.0 (prerelease - include info below when reporting bugs)
// git: ee56f96 (Thu Aug 3 12:16:33 2023 +0200) [modified]

// We need to define _GNU_SOURCE before
// _any_ headers files are imported to get
// the usage statistics of a thread (i.e. have RUSAGE_THREAD) on GNU/Linux
// https://manpages.courier-mta.org/htmlman2/getrusage.2.html
#ifndef _GNU_SOURCE // Avoid possible double-definition warning.
#define _GNU_SOURCE
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wparentheses"
#pragma clang diagnostic ignored "-Wunused-label"
#elif __GNUC__
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wparentheses"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif

// Headers
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <float.h>

#define CL_TARGET_OPENCL_VERSION 120
#define CL_USE_DEPRECATED_OPENCL_1_2_APIS
#ifdef __APPLE__
#define CL_SILENCE_DEPRECATION
#include <OpenCL/cl.h>
#else
#include <CL/cl.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

// Initialisation
struct futhark_context_config;
struct futhark_context_config *futhark_context_config_new(void);
void futhark_context_config_free(struct futhark_context_config *cfg);
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg, const char *param_name, size_t new_value);
struct futhark_context;
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg);
void futhark_context_free(struct futhark_context *cfg);
void futhark_context_config_add_build_option(struct futhark_context_config *cfg, const char *opt);
void futhark_context_config_set_device(struct futhark_context_config *cfg, const char *s);
void futhark_context_config_set_platform(struct futhark_context_config *cfg, const char *s);
void futhark_context_config_select_device_interactively(struct futhark_context_config *cfg);
void futhark_context_config_list_devices(struct futhark_context_config *cfg);
void futhark_context_config_dump_program_to(struct futhark_context_config *cfg, const char *s);
void futhark_context_config_load_program_from(struct futhark_context_config *cfg, const char *s);
void futhark_context_config_dump_binary_to(struct futhark_context_config *cfg, const char *s);
void futhark_context_config_load_binary_from(struct futhark_context_config *cfg, const char *s);
void futhark_context_config_set_default_group_size(struct futhark_context_config *cfg, int size);
void futhark_context_config_set_default_num_groups(struct futhark_context_config *cfg, int size);
void futhark_context_config_set_default_tile_size(struct futhark_context_config *cfg, int size);
void futhark_context_config_set_default_reg_tile_size(struct futhark_context_config *cfg, int size);
void futhark_context_config_set_default_threshold(struct futhark_context_config *cfg, int size);
void futhark_context_config_set_command_queue(struct futhark_context_config *cfg, cl_command_queue);
void futhark_context_config_set_debugging(struct futhark_context_config *cfg, int flag);
void futhark_context_config_set_profiling(struct futhark_context_config *cfg, int flag);
void futhark_context_config_set_logging(struct futhark_context_config *cfg, int flag);
int futhark_get_tuning_param_count(void);
const char *futhark_get_tuning_param_name(int);
const char *futhark_get_tuning_param_class(int);

// Arrays
struct futhark_u32_2d;
struct futhark_u32_2d *futhark_new_u32_2d(struct futhark_context *ctx, const uint32_t *data, int64_t dim0, int64_t dim1);
struct futhark_u32_2d *futhark_new_raw_u32_2d(struct futhark_context *ctx, const cl_mem data, int64_t offset, int64_t dim0, int64_t dim1);
int futhark_free_u32_2d(struct futhark_context *ctx, struct futhark_u32_2d *arr);
int futhark_values_u32_2d(struct futhark_context *ctx, struct futhark_u32_2d *arr, uint32_t *data);
cl_mem futhark_values_raw_u32_2d(struct futhark_context *ctx, struct futhark_u32_2d *arr);
const int64_t *futhark_shape_u32_2d(struct futhark_context *ctx, struct futhark_u32_2d *arr);
struct futhark_u8_1d;
struct futhark_u8_1d *futhark_new_u8_1d(struct futhark_context *ctx, const uint8_t *data, int64_t dim0);
struct futhark_u8_1d *futhark_new_raw_u8_1d(struct futhark_context *ctx, const cl_mem data, int64_t offset, int64_t dim0);
int futhark_free_u8_1d(struct futhark_context *ctx, struct futhark_u8_1d *arr);
int futhark_values_u8_1d(struct futhark_context *ctx, struct futhark_u8_1d *arr, uint8_t *data);
cl_mem futhark_values_raw_u8_1d(struct futhark_context *ctx, struct futhark_u8_1d *arr);
const int64_t *futhark_shape_u8_1d(struct futhark_context *ctx, struct futhark_u8_1d *arr);

// Opaque values
struct futhark_opaque_b2de7ac;
struct futhark_opaque_86dd06d3;
struct futhark_opaque_state;
struct futhark_opaque_40c80b6a;
struct futhark_opaque_721f284b;
struct futhark_opaque_84640977;
struct futhark_opaque_f5b98ad5;
struct futhark_opaque_9eab96ba;
struct futhark_opaque_11462a01;
int futhark_free_opaque_b2de7ac(struct futhark_context *ctx, struct futhark_opaque_b2de7ac *obj);
int futhark_store_opaque_b2de7ac(struct futhark_context *ctx, const struct futhark_opaque_b2de7ac *obj, void **p, size_t *n);
struct futhark_opaque_b2de7ac *futhark_restore_opaque_b2de7ac(struct futhark_context *ctx, const void *p);
int futhark_free_opaque_86dd06d3(struct futhark_context *ctx, struct futhark_opaque_86dd06d3 *obj);
int futhark_store_opaque_86dd06d3(struct futhark_context *ctx, const struct futhark_opaque_86dd06d3 *obj, void **p, size_t *n);
struct futhark_opaque_86dd06d3 *futhark_restore_opaque_86dd06d3(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_86dd06d3_0(struct futhark_context *ctx, uint64_t *out, const struct futhark_opaque_86dd06d3 *obj);
int futhark_project_opaque_86dd06d3_1(struct futhark_context *ctx, uint64_t *out, const struct futhark_opaque_86dd06d3 *obj);
int futhark_new_opaque_86dd06d3(struct futhark_context *ctx, struct futhark_opaque_86dd06d3 **out, const uint64_t v0, const uint64_t v1);
int futhark_free_opaque_state(struct futhark_context *ctx, struct futhark_opaque_state *obj);
int futhark_store_opaque_state(struct futhark_context *ctx, const struct futhark_opaque_state *obj, void **p, size_t *n);
struct futhark_opaque_state *futhark_restore_opaque_state(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_state_auto_zoom(struct futhark_context *ctx, struct futhark_opaque_f5b98ad5 **out, const struct futhark_opaque_state *obj);
int futhark_project_opaque_state_base(struct futhark_context *ctx, struct futhark_opaque_40c80b6a **out, const struct futhark_opaque_state *obj);
int futhark_project_opaque_state_height(struct futhark_context *ctx, int64_t *out, const struct futhark_opaque_state *obj);
int futhark_project_opaque_state_mouse(struct futhark_context *ctx, struct futhark_opaque_11462a01 **out, const struct futhark_opaque_state *obj);
int futhark_project_opaque_state_screen_calculations(struct futhark_context *ctx, struct futhark_opaque_84640977 **out, const struct futhark_opaque_state *obj);
int futhark_project_opaque_state_viewport(struct futhark_context *ctx, struct futhark_opaque_721f284b **out, const struct futhark_opaque_state *obj);
int futhark_project_opaque_state_width(struct futhark_context *ctx, int64_t *out, const struct futhark_opaque_state *obj);
int futhark_new_opaque_state(struct futhark_context *ctx, struct futhark_opaque_state **out, const struct futhark_opaque_f5b98ad5 *f_auto_zzoom, const struct futhark_opaque_40c80b6a *f_base, const int64_t f_height, const struct futhark_opaque_11462a01 *f_mouse, const struct futhark_opaque_84640977 *f_screen_calculations, const struct futhark_opaque_721f284b *f_viewport, const int64_t f_width);
int futhark_free_opaque_40c80b6a(struct futhark_context *ctx, struct futhark_opaque_40c80b6a *obj);
int futhark_store_opaque_40c80b6a(struct futhark_context *ctx, const struct futhark_opaque_40c80b6a *obj, void **p, size_t *n);
struct futhark_opaque_40c80b6a *futhark_restore_opaque_40c80b6a(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_40c80b6a_approach(struct futhark_context *ctx, struct futhark_opaque_b2de7ac **out, const struct futhark_opaque_40c80b6a *obj);
int futhark_project_opaque_40c80b6a_rng(struct futhark_context *ctx, struct futhark_opaque_86dd06d3 **out, const struct futhark_opaque_40c80b6a *obj);
int futhark_project_opaque_40c80b6a_time(struct futhark_context *ctx, float *out, const struct futhark_opaque_40c80b6a *obj);
int futhark_new_opaque_40c80b6a(struct futhark_context *ctx, struct futhark_opaque_40c80b6a **out, const struct futhark_opaque_b2de7ac *f_approach, const struct futhark_opaque_86dd06d3 *f_rng, const float f_time);
int futhark_free_opaque_721f284b(struct futhark_context *ctx, struct futhark_opaque_721f284b *obj);
int futhark_store_opaque_721f284b(struct futhark_context *ctx, const struct futhark_opaque_721f284b *obj, void **p, size_t *n);
struct futhark_opaque_721f284b *futhark_restore_opaque_721f284b(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_721f284b_center(struct futhark_context *ctx, struct futhark_opaque_9eab96ba **out, const struct futhark_opaque_721f284b *obj);
int futhark_project_opaque_721f284b_zoom(struct futhark_context *ctx, float *out, const struct futhark_opaque_721f284b *obj);
int futhark_new_opaque_721f284b(struct futhark_context *ctx, struct futhark_opaque_721f284b **out, const struct futhark_opaque_9eab96ba *f_center, const float f_zzoom);
int futhark_free_opaque_84640977(struct futhark_context *ctx, struct futhark_opaque_84640977 *obj);
int futhark_store_opaque_84640977(struct futhark_context *ctx, const struct futhark_opaque_84640977 *obj, void **p, size_t *n);
struct futhark_opaque_84640977 *futhark_restore_opaque_84640977(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_84640977_center_offset(struct futhark_context *ctx, struct futhark_opaque_9eab96ba **out, const struct futhark_opaque_84640977 *obj);
int futhark_project_opaque_84640977_offset_viewport_scaled(struct futhark_context *ctx, struct futhark_opaque_9eab96ba **out, const struct futhark_opaque_84640977 *obj);
int futhark_project_opaque_84640977_precision(struct futhark_context *ctx, int64_t *out, const struct futhark_opaque_84640977 *obj);
int futhark_project_opaque_84640977_xy_factor_inv(struct futhark_context *ctx, float *out, const struct futhark_opaque_84640977 *obj);
int futhark_project_opaque_84640977_zoom_factor(struct futhark_context *ctx, float *out, const struct futhark_opaque_84640977 *obj);
int futhark_new_opaque_84640977(struct futhark_context *ctx, struct futhark_opaque_84640977 **out, const struct futhark_opaque_9eab96ba *f_center_offset, const struct futhark_opaque_9eab96ba *f_offset_viewport_scaled, const int64_t f_precision, const float f_xy_factor_inv, const float f_zzoom_factor);
int futhark_free_opaque_f5b98ad5(struct futhark_context *ctx, struct futhark_opaque_f5b98ad5 *obj);
int futhark_store_opaque_f5b98ad5(struct futhark_context *ctx, const struct futhark_opaque_f5b98ad5 *obj, void **p, size_t *n);
struct futhark_opaque_f5b98ad5 *futhark_restore_opaque_f5b98ad5(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_f5b98ad5_enabled(struct futhark_context *ctx, bool *out, const struct futhark_opaque_f5b98ad5 *obj);
int futhark_project_opaque_f5b98ad5_factor(struct futhark_context *ctx, float *out, const struct futhark_opaque_f5b98ad5 *obj);
int futhark_new_opaque_f5b98ad5(struct futhark_context *ctx, struct futhark_opaque_f5b98ad5 **out, const bool f_enabled, const float f_factor);
int futhark_free_opaque_9eab96ba(struct futhark_context *ctx, struct futhark_opaque_9eab96ba *obj);
int futhark_store_opaque_9eab96ba(struct futhark_context *ctx, const struct futhark_opaque_9eab96ba *obj, void **p, size_t *n);
struct futhark_opaque_9eab96ba *futhark_restore_opaque_9eab96ba(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_9eab96ba_x(struct futhark_context *ctx, float *out, const struct futhark_opaque_9eab96ba *obj);
int futhark_project_opaque_9eab96ba_y(struct futhark_context *ctx, float *out, const struct futhark_opaque_9eab96ba *obj);
int futhark_new_opaque_9eab96ba(struct futhark_context *ctx, struct futhark_opaque_9eab96ba **out, const float f_x, const float f_y);
int futhark_free_opaque_11462a01(struct futhark_context *ctx, struct futhark_opaque_11462a01 *obj);
int futhark_store_opaque_11462a01(struct futhark_context *ctx, const struct futhark_opaque_11462a01 *obj, void **p, size_t *n);
struct futhark_opaque_11462a01 *futhark_restore_opaque_11462a01(struct futhark_context *ctx, const void *p);
int futhark_project_opaque_11462a01_x(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_11462a01 *obj);
int futhark_project_opaque_11462a01_y(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_11462a01 *obj);
int futhark_new_opaque_11462a01(struct futhark_context *ctx, struct futhark_opaque_11462a01 **out, const int32_t f_x, const int32_t f_y);

// Entry points
int futhark_entry_grab_mouse(struct futhark_context *ctx, bool *out0);
int futhark_entry_init(struct futhark_context *ctx, struct futhark_opaque_state **out0, const uint32_t in0, const int32_t in1, const int32_t in2);
int futhark_entry_key(struct futhark_context *ctx, struct futhark_opaque_state **out0, const int32_t in0, const int32_t in1, const struct futhark_opaque_state *in2);
int futhark_entry_mouse(struct futhark_context *ctx, struct futhark_opaque_state **out0, const int32_t in0, const int32_t in1, const int32_t in2, const struct futhark_opaque_state *in3);
int futhark_entry_render(struct futhark_context *ctx, struct futhark_u32_2d **out0, const struct futhark_opaque_state *in0);
int futhark_entry_resize(struct futhark_context *ctx, struct futhark_opaque_state **out0, const int32_t in0, const int32_t in1, const struct futhark_opaque_state *in2);
int futhark_entry_step(struct futhark_context *ctx, struct futhark_opaque_state **out0, const float in0, const struct futhark_opaque_state *in1);
int futhark_entry_text_colour(struct futhark_context *ctx, uint32_t *out0, const struct futhark_opaque_state *in0);
int futhark_entry_text_content(struct futhark_context *ctx, int32_t *out0, int32_t *out1, float *out2, float *out3, float *out4, int32_t *out5, const float in0, const struct futhark_opaque_state *in1);
int futhark_entry_text_format(struct futhark_context *ctx, struct futhark_u8_1d **out0);
int futhark_entry_wheel(struct futhark_context *ctx, struct futhark_opaque_state **out0, const int32_t in0, const int32_t in1, const struct futhark_opaque_state *in2);

// Miscellaneous
int futhark_context_sync(struct futhark_context *ctx);
cl_command_queue futhark_context_get_command_queue(struct futhark_context *ctx);
void futhark_context_config_set_cache_file(struct futhark_context_config *cfg, const char *f);
char *futhark_context_report(struct futhark_context *ctx);
char *futhark_context_get_error(struct futhark_context *ctx);
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f);
void futhark_context_pause_profiling(struct futhark_context *ctx);
void futhark_context_unpause_profiling(struct futhark_context *ctx);
int futhark_context_clear_caches(struct futhark_context *ctx);
#define FUTHARK_BACKEND_opencl
#define FUTHARK_SUCCESS 0
#define FUTHARK_PROGRAM_ERROR 2
#define FUTHARK_OUT_OF_MEMORY 3

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <stdint.h>
// If NDEBUG is set, the assert() macro will do nothing. Since Futhark
// (unfortunately) makes use of assert() for error detection (and even some
// side effects), we want to avoid that.
#undef NDEBUG
#include <assert.h>
#include <stdarg.h>
// Start of util.h.
//
// Various helper functions that are useful in all generated C code.

#include <errno.h>
#include <string.h>

static const char *fut_progname = "(embedded Futhark)";

static void futhark_panic(int eval, const char *fmt, ...) __attribute__((noreturn));
static char* msgprintf(const char *s, ...);
static void* slurp_file(const char *filename, size_t *size);
static int dump_file(const char *file, const void *buf, size_t n);
struct str_builder;
static void str_builder_init(struct str_builder *b);
static void str_builder(struct str_builder *b, const char *s, ...);
static char *strclone(const char *str);

static void futhark_panic(int eval, const char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  fprintf(stderr, "%s: ", fut_progname);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  exit(eval);
}

// For generating arbitrary-sized error messages.  It is the callers
// responsibility to free the buffer at some point.
static char* msgprintf(const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = 1 + (size_t)vsnprintf(NULL, 0, s, vl);
  char *buffer = (char*) malloc(needed);
  va_start(vl, s); // Must re-init.
  vsnprintf(buffer, needed, s, vl);
  return buffer;
}

static inline void check_err(int errval, int sets_errno, const char *fun, int line,
                             const char *msg, ...) {
  if (errval) {
    char errnum[10];

    va_list vl;
    va_start(vl, msg);

    fprintf(stderr, "ERROR: ");
    vfprintf(stderr, msg, vl);
    fprintf(stderr, " in %s() at line %d with error code %s\n",
            fun, line,
            sets_errno ? strerror(errno) : errnum);
    exit(errval);
  }
}

#define CHECK_ERR(err, ...) check_err(err, 0, __func__, __LINE__, __VA_ARGS__)
#define CHECK_ERRNO(err, ...) check_err(err, 1, __func__, __LINE__, __VA_ARGS__)

// Read the rest of an open file into a NUL-terminated string; returns
// NULL on error.
static void* fslurp_file(FILE *f, size_t *size) {
  long start = ftell(f);
  fseek(f, 0, SEEK_END);
  long src_size = ftell(f)-start;
  fseek(f, start, SEEK_SET);
  unsigned char *s = (unsigned char*) malloc((size_t)src_size + 1);
  if (fread(s, 1, (size_t)src_size, f) != (size_t)src_size) {
    free(s);
    s = NULL;
  } else {
    s[src_size] = '\0';
  }

  if (size) {
    *size = (size_t)src_size;
  }

  return s;
}

// Read a file into a NUL-terminated string; returns NULL on error.
static void* slurp_file(const char *filename, size_t *size) {
  FILE *f = fopen(filename, "rb"); // To avoid Windows messing with linebreaks.
  if (f == NULL) return NULL;
  unsigned char *s = fslurp_file(f, size);
  fclose(f);
  return s;
}

// Dump 'n' bytes from 'buf' into the file at the designated location.
// Returns 0 on success.
static int dump_file(const char *file, const void *buf, size_t n) {
  FILE *f = fopen(file, "w");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(buf, sizeof(char), n, f) != n) {
    return 1;
  }

  if (fclose(f) != 0) {
    return 1;
  }

  return 0;
}

struct str_builder {
  char *str;
  size_t capacity; // Size of buffer.
  size_t used; // Bytes used, *not* including final zero.
};

static void str_builder_init(struct str_builder *b) {
  b->capacity = 10;
  b->used = 0;
  b->str = malloc(b->capacity);
  b->str[0] = 0;
}

static void str_builder(struct str_builder *b, const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = (size_t)vsnprintf(NULL, 0, s, vl);

  while (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }

  va_start(vl, s); // Must re-init.
  vsnprintf(b->str+b->used, b->capacity-b->used, s, vl);
  b->used += needed;
}

struct cost_centre {
  const char *name;
  int64_t runs;
  int64_t runtime;
};

// Dynamic dictionary for tallying cost centres when aggregating
// profiling information.  Not performance-critical.
struct cost_centres {
  size_t capacity;
  size_t used;
  struct cost_centre* centres;
};

static struct cost_centres *cost_centres_new() {
  struct cost_centres *ccs = malloc(sizeof(struct cost_centres));
  ccs->capacity = 100;
  ccs->used = 0;
  ccs->centres = calloc(ccs->capacity, sizeof(struct cost_centre));
  return ccs;
}

static void cost_centres_free(struct cost_centres* ccs) {
  free(ccs->centres);
  free(ccs);
}

static void cost_centres_init(struct cost_centres* ccs, const char *name) {
  if (ccs->used == ccs->capacity) {
    ccs->capacity *= 2;
    ccs->centres = realloc(ccs->centres, ccs->capacity*sizeof(struct cost_centre));
  }
  ccs->centres[ccs->used].name = name;
  ccs->centres[ccs->used].runs = 0;
  ccs->centres[ccs->used].runtime = 0;
  ccs->used++;
}

static void cost_centres_add(struct cost_centres* ccs, struct cost_centre c) {
  size_t i = 0;
  for (i = 0; i < ccs->used; i++) {
    if (strcmp(c.name, ccs->centres[i].name) == 0) {
      ccs->centres[i].runs += c.runs;
      ccs->centres[i].runtime += c.runtime;
      return;
    }
  }
  if (i == ccs->capacity) {
    ccs->capacity *= 2;
    ccs->centres = realloc(ccs->centres, ccs->capacity*sizeof(struct cost_centre));
  }
  ccs->centres[i] = c;
  ccs->used++;
}

static void cost_centre_report(struct cost_centres* ccs, struct str_builder *b) {
  int64_t total_runs = 0;
  int64_t total_runtime = 0;
  for (size_t i = 0; i < ccs->used; i++) {
    struct cost_centre c = ccs->centres[i];
    str_builder(b,
                "%-40s ran %5d times; avg %8ldus; total: %8ldus\n",
                c.name,
                c.runs, c.runs == 0 ? 0 : c.runtime/c.runs, c.runtime);
    total_runs += c.runs;
    total_runtime += c.runtime;
  }
  str_builder(b,
              "%d operations with cumulative runtime: %6ldus\n",
              total_runs, total_runtime);
}

static char *strclone(const char *str) {
  size_t size = strlen(str) + 1;
  char *copy = (char*) malloc(size);
  if (copy == NULL) {
    return NULL;
  }

  memcpy(copy, str, size);
  return copy;
}

// End of util.h.
// Start of cache.h

#define CACHE_HASH_SIZE 8 // In 32-bit words.

struct cache_hash {
  uint32_t hash[CACHE_HASH_SIZE];
};

// Initialise a blank cache.
static void cache_hash_init(struct cache_hash *c);

// Hash some bytes and add them to the accumulated hash.
static void cache_hash(struct cache_hash *out, const char *in, size_t n);

// Try to restore cache contents from a file with the given name.
// Assumes the cache is invalid if it contains the given hash.
// Allocates memory and reads the cache conents, which is returned in
// *buf with size *buflen.  If the cache is successfully loaded, this
// function returns 0.  Otherwise it returns nonzero.  Errno is set if
// the failure to load the cache is due to anything except invalid
// cache conents.  Note that failing to restore the cache is not
// necessarily a problem: it might just be invalid or not created yet.
static int cache_restore(const char *fname, const struct cache_hash *hash,
                         unsigned char **buf, size_t *buflen);

// Store cache contents in the given file, with the given hash.
static int cache_store(const char *fname, const struct cache_hash *hash,
                       const unsigned char *buf, size_t buflen);

// Now for the implementation.

static void cache_hash_init(struct cache_hash *c) {
  memset(c->hash, 0, CACHE_HASH_SIZE * sizeof(uint32_t));
}

static void cache_hash(struct cache_hash *out, const char *in, size_t n) {
  // Adaptation of djb2 for larger output size by storing intermediate
  // states.
  uint32_t hash = 5381;
  for (size_t i = 0; i < n; i++) {
    hash = ((hash << 5) + hash) + in[i];
    out->hash[i % CACHE_HASH_SIZE] ^= hash;
  }
}

#define CACHE_HEADER_SIZE 8
static const char cache_header[CACHE_HEADER_SIZE] = "FUTHARK\0";

static int cache_restore(const char *fname, const struct cache_hash *hash,
                         unsigned char **buf, size_t *buflen) {
  FILE *f = fopen(fname, "rb");

  if (f == NULL) {
    return 1;
  }

  char f_header[CACHE_HEADER_SIZE];

  if (fread(f_header, sizeof(char), CACHE_HEADER_SIZE, f) != CACHE_HEADER_SIZE) {
    goto error;
  }

  if (memcmp(f_header, cache_header, CACHE_HEADER_SIZE) != 0) {
    goto error;
  }

  if (fseek(f, 0, SEEK_END) != 0) {
    goto error;
  }
  int64_t f_size = (int64_t)ftell(f);
  if (fseek(f, CACHE_HEADER_SIZE, SEEK_SET) != 0) {
    goto error;
  }

  int64_t expected_size;

  if (fread(&expected_size, sizeof(int64_t), 1, f) != 1) {
    goto error;
  }

  if (f_size != expected_size) {
    errno = 0;
    goto error;
  }

  int32_t f_hash[CACHE_HASH_SIZE];

  if (fread(f_hash, sizeof(int32_t), CACHE_HASH_SIZE, f) != CACHE_HASH_SIZE) {
    goto error;
  }

  if (memcmp(f_hash, hash->hash, CACHE_HASH_SIZE) != 0) {
    errno = 0;
    goto error;
  }

  *buflen = f_size - CACHE_HEADER_SIZE - sizeof(int64_t) - CACHE_HASH_SIZE*sizeof(int32_t);
  *buf = malloc(*buflen);
  if (fread(*buf, sizeof(char), *buflen, f) != *buflen) {
    free(*buf);
    goto error;
  }

  fclose(f);

  return 0;

 error:
  fclose(f);
  return 1;
}

static int cache_store(const char *fname, const struct cache_hash *hash,
                       const unsigned char *buf, size_t buflen) {
  FILE *f = fopen(fname, "wb");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(cache_header, CACHE_HEADER_SIZE, 1, f) != 1) {
    goto error;
  }

  int64_t size = CACHE_HEADER_SIZE + sizeof(int64_t) + CACHE_HASH_SIZE*sizeof(int32_t) + buflen;

  if (fwrite(&size, sizeof(size), 1, f) != 1) {
    goto error;
  }

  if (fwrite(hash->hash, sizeof(int32_t), CACHE_HASH_SIZE, f) != CACHE_HASH_SIZE) {
    goto error;
  }

  if (fwrite(buf, sizeof(unsigned char), buflen, f) != buflen) {
    goto error;
  }

  fclose(f);

  return 0;

 error:
  fclose(f);
  return 1;
}

// End of cache.h
// Start of half.h.

// Conversion functions are from http://half.sourceforge.net/, but
// translated to C.
//
// Copyright (c) 2012-2021 Christian Rau
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef __OPENCL_VERSION__
#define __constant
#endif

__constant static const uint16_t base_table[512] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
  0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
  0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
  0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
  0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };

__constant static const unsigned char shift_table[512] = {
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };

__constant static const uint32_t mantissa_table[2048] = {
  0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
  0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
  0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
  0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
  0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
  0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
  0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
  0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
  0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
  0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
  0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
  0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
  0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
  0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
  0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
  0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
  0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
  0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
  0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
  0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
  0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
  0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
  0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
  0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
  0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
  0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
  0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
  0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
  0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
  0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
  0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
  0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
  0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
  0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
  0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
  0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
  0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
  0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
  0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
  0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
  0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
  0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
  0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
  0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
  0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
  0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
  0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
  0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
  0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
  0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
  0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
  0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
  0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
  0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
  0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
  0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
  0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
  0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
  0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
  0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
  0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
  0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
  0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
  0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
  0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
  0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
  0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
  0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
  0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
  0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
  0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
  0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
  0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
  0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
  0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
  0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
  0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
__constant static const uint32_t exponent_table[64] = {
  0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
  0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
__constant static const unsigned short offset_table[64] = {
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };

static uint16_t float2halfbits(float value) {
  union { float x; uint32_t y; } u;
  u.x = value;
  uint32_t bits = u.y;

  uint16_t hbits = base_table[bits>>23] + (uint16_t)((bits&0x7FFFFF)>>shift_table[bits>>23]);;

  return hbits;
}

static float halfbits2float(uint16_t value) {
  uint32_t bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];

  union { uint32_t x; float y; } u;
  u.x = bits;
  return u.y;
}

static uint16_t halfbitsnextafter(uint16_t from, uint16_t to) {
  int fabs = from & 0x7FFF, tabs = to & 0x7FFF;
  if(fabs > 0x7C00 || tabs > 0x7C00) {
    return ((from&0x7FFF)>0x7C00) ? (from|0x200) : (to|0x200);
  }
  if(from == to || !(fabs|tabs)) {
    return to;
  }
  if(!fabs) {
    return (to&0x8000)+1;
  }
  unsigned int out =
    from +
    (((from>>15)^(unsigned int)((from^(0x8000|(0x8000-(from>>15))))<(to^(0x8000|(0x8000-(to>>15))))))<<1)
    - 1;
  return out;
}

// End of half.h.
// Start of timing.h.

// The function get_wall_time() returns the wall time in microseconds
// (with an unspecified offset).

#ifdef _WIN32

#include <windows.h>

static int64_t get_wall_time(void) {
  LARGE_INTEGER time,freq;
  assert(QueryPerformanceFrequency(&freq));
  assert(QueryPerformanceCounter(&time));
  return ((double)time.QuadPart / freq.QuadPart) * 1000000;
}

#else
// Assuming POSIX

#include <time.h>
#include <sys/time.h>

static int64_t get_wall_time(void) {
  struct timeval time;
  assert(gettimeofday(&time,NULL) == 0);
  return time.tv_sec * 1000000 + time.tv_usec;
}

static int64_t get_wall_time_ns(void) {
  struct timespec time;
  assert(clock_gettime(CLOCK_REALTIME, &time) == 0);
  return time.tv_sec * 1000000000 + time.tv_nsec;
}

#endif

// End of timing.h.
// Start of lock.h.

// A very simple cross-platform implementation of locks.  Uses
// pthreads on Unix and some Windows thing there.  Futhark's
// host-level code is not multithreaded, but user code may be, so we
// need some mechanism for ensuring atomic access to API functions.
// This is that mechanism.  It is not exposed to user code at all, so
// we do not have to worry about name collisions.

#ifdef _WIN32

typedef HANDLE lock_t;

static void create_lock(lock_t *lock) {
  *lock = CreateMutex(NULL,  // Default security attributes.
                      FALSE, // Initially unlocked.
                      NULL); // Unnamed.
}

static void lock_lock(lock_t *lock) {
  assert(WaitForSingleObject(*lock, INFINITE) == WAIT_OBJECT_0);
}

static void lock_unlock(lock_t *lock) {
  assert(ReleaseMutex(*lock));
}

static void free_lock(lock_t *lock) {
  CloseHandle(*lock);
}

#else
// Assuming POSIX

#include <pthread.h>

typedef pthread_mutex_t lock_t;

static void create_lock(lock_t *lock) {
  int r = pthread_mutex_init(lock, NULL);
  assert(r == 0);
}

static void lock_lock(lock_t *lock) {
  int r = pthread_mutex_lock(lock);
  assert(r == 0);
}

static void lock_unlock(lock_t *lock) {
  int r = pthread_mutex_unlock(lock);
  assert(r == 0);
}

static void free_lock(lock_t *lock) {
  // Nothing to do for pthreads.
  (void)lock;
}

#endif

// End of lock.h.
// Start of free_list.h.

typedef uintptr_t fl_mem;

// An entry in the free list.  May be invalid, to avoid having to
// deallocate entries as soon as they are removed.  There is also a
// tag, to help with memory reuse.
struct free_list_entry {
  size_t size;
  fl_mem mem;
  const char *tag;
  unsigned char valid;
};

struct free_list {
  struct free_list_entry *entries; // Pointer to entries.
  int capacity;                    // Number of entries.
  int used;                        // Number of valid entries.
  lock_t lock;                     // Thread safety.
};

static void free_list_init(struct free_list *l) {
  l->capacity = 30; // Picked arbitrarily.
  l->used = 0;
  l->entries = (struct free_list_entry*) malloc(sizeof(struct free_list_entry) * l->capacity);
  for (int i = 0; i < l->capacity; i++) {
    l->entries[i].valid = 0;
  }
  create_lock(&l->lock);
}

// Remove invalid entries from the free list.
static void free_list_pack(struct free_list *l) {
  lock_lock(&l->lock);
  int p = 0;
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[p] = l->entries[i];
      if (i > p) {
        l->entries[i].valid = 0;
      }
      p++;
    }
  }

  // Now p is the number of used elements.  We don't want it to go
  // less than the default capacity (although in practice it's OK as
  // long as it doesn't become 1).
  if (p < 30) {
    p = 30;
  }
  l->entries = realloc(l->entries, p * sizeof(struct free_list_entry));
  l->capacity = p;
  lock_unlock(&l->lock);
}

static void free_list_destroy(struct free_list *l) {
  assert(l->used == 0);
  free(l->entries);
  free_lock(&l->lock);
}

// Not part of the interface, so no locking.
static int free_list_find_invalid(struct free_list *l) {
  int i;
  for (i = 0; i < l->capacity; i++) {
    if (!l->entries[i].valid) {
      break;
    }
  }
  return i;
}

static void free_list_insert(struct free_list *l, size_t size, fl_mem mem, const char *tag) {
  lock_lock(&l->lock);
  int i = free_list_find_invalid(l);

  if (i == l->capacity) {
    // List is full; so we have to grow it.
    int new_capacity = l->capacity * 2 * sizeof(struct free_list_entry);
    l->entries = realloc(l->entries, new_capacity);
    for (int j = 0; j < l->capacity; j++) {
      l->entries[j+l->capacity].valid = 0;
    }
    l->capacity *= 2;
  }

  // Now 'i' points to the first invalid entry.
  l->entries[i].valid = 1;
  l->entries[i].size = size;
  l->entries[i].mem = mem;
  l->entries[i].tag = tag;

  l->used++;
  lock_unlock(&l->lock);
}

// Determine whether this entry in the free list is acceptable for
// satisfying the request.  Not public, so no locking.
static bool free_list_acceptable(size_t size, const char* tag, struct free_list_entry *entry) {
  // We check not just the hard requirement (is the entry acceptable
  // and big enough?) but also put a cap on how much wasted space
  // (internal fragmentation) we allow.  This is necessarily a
  // heuristic, and a crude one.

  if (!entry->valid) {
    return false;
  }

  if (size > entry->size) {
    return false;
  }

  // We know the block fits.  Now the question is whether it is too
  // big.  Our policy is as follows:
  //
  // 1) We don't care about wasted space below 4096 bytes (to avoid
  // churn in tiny allocations).
  //
  // 2) If the tag matches, we allow _any_ amount of wasted space.
  //
  // 3) Otherwise we allow up to 50% wasted space.

  if (entry->size < 4096) {
    return true;
  }

  if (entry->tag == tag) {
    return true;
  }

  if (entry->size < size * 2) {
    return true;
  }

  return false;
}

// Find and remove a memory block of the indicated tag, or if that
// does not exist, another memory block with exactly the desired size.
// Returns 0 on success.
static int free_list_find(struct free_list *l, size_t size, const char *tag,
                          size_t *size_out, fl_mem *mem_out) {
  lock_lock(&l->lock);
  int size_match = -1;
  int i;
  int ret = 1;
  for (i = 0; i < l->capacity; i++) {
    if (free_list_acceptable(size, tag, &l->entries[i]) &&
        (size_match < 0 || l->entries[i].size < l->entries[size_match].size)) {
      // If this entry is valid, has sufficient size, and is smaller than the
      // best entry found so far, use this entry.
      size_match = i;
    }
  }

  if (size_match >= 0) {
    l->entries[size_match].valid = 0;
    *size_out = l->entries[size_match].size;
    *mem_out = l->entries[size_match].mem;
    l->used--;
    ret = 0;
  }
  lock_unlock(&l->lock);
  return ret;
}

// Remove the first block in the free list.  Returns 0 if a block was
// removed, and nonzero if the free list was already empty.
static int free_list_first(struct free_list *l, fl_mem *mem_out) {
  lock_lock(&l->lock);
  int ret = 1;
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[i].valid = 0;
      *mem_out = l->entries[i].mem;
      l->used--;
      ret = 0;
      break;
    }
  }
  lock_unlock(&l->lock);
  return ret;
}

// End of free_list.h.

#ifdef _MSC_VER
#define inline __inline
#endif
#include <string.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <ctype.h>


#define CL_TARGET_OPENCL_VERSION 120
#define CL_USE_DEPRECATED_OPENCL_1_2_APIS
#ifdef __APPLE__
#define CL_SILENCE_DEPRECATION
#include <OpenCL/cl.h>
#else
#include <CL/cl.h>
#endif


#define FUTHARK_F64_ENABLED

// Start of scalar.h.

// Implementation of the primitive scalar operations.  Very
// repetitive.  This code is inserted directly into both CUDA and
// OpenCL programs, as well as the CPU code, so it has some #ifdefs to
// work everywhere.  Some operations are defined as macros because
// this allows us to use them as constant expressions in things like
// array sizes and static initialisers.

// Some of the #ifdefs are because OpenCL uses type-generic functions
// for some operations (e.g. sqrt), while C and CUDA sensibly use
// distinct functions for different precisions (e.g. sqrtf() and
// sqrt()).  This is quite annoying.  Due to C's unfortunate casting
// rules, it is also really easy to accidentally implement
// floating-point functions in the wrong precision, so be careful.

// Double-precision definitions are only included if the preprocessor
// macro FUTHARK_F64_ENABLED is set.

static inline uint8_t add8(uint8_t x, uint8_t y) {
  return x + y;
}

static inline uint16_t add16(uint16_t x, uint16_t y) {
  return x + y;
}

static inline uint32_t add32(uint32_t x, uint32_t y) {
  return x + y;
}

static inline uint64_t add64(uint64_t x, uint64_t y) {
  return x + y;
}

static inline uint8_t sub8(uint8_t x, uint8_t y) {
  return x - y;
}

static inline uint16_t sub16(uint16_t x, uint16_t y) {
  return x - y;
}

static inline uint32_t sub32(uint32_t x, uint32_t y) {
  return x - y;
}

static inline uint64_t sub64(uint64_t x, uint64_t y) {
  return x - y;
}

static inline uint8_t mul8(uint8_t x, uint8_t y) {
  return x * y;
}

static inline uint16_t mul16(uint16_t x, uint16_t y) {
  return x * y;
}

static inline uint32_t mul32(uint32_t x, uint32_t y) {
  return x * y;
}

static inline uint64_t mul64(uint64_t x, uint64_t y) {
  return x * y;
}

#if ISPC

static inline uint8_t udiv8(uint8_t x, uint8_t y) {
  // This strange pattern is used to prevent the ISPC compiler from
  // causing SIGFPEs and bogus results on divisions where inactive lanes
  // have 0-valued divisors. It ensures that any inactive lane instead
  // has a divisor of 1. https://github.com/ispc/ispc/issues/2292
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }

  return x / ys;
}

static inline uint16_t udiv16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x / ys;
}

static inline uint32_t udiv32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  

  return x / ys;
}

static inline uint64_t udiv64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  

  return x / ys;
}

static inline uint8_t udiv_up8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  

  return (x + y - 1) / ys;
}

static inline uint16_t udiv_up16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return (x + y - 1) / ys;
}

static inline uint32_t udiv_up32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return (x + y - 1) / ys;
}

static inline uint64_t udiv_up64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return (x + y - 1) / ys;
}

static inline uint8_t umod8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x % ys;
}

static inline uint16_t umod16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  

  return x % ys;
}

static inline uint32_t umod32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x % ys;
}

static inline uint64_t umod64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x % ys;
}

static inline uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x / ys;
}

static inline uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x / ys;
}

static inline uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x / ys;
}

static inline uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x / ys;
}

static inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : (x + y - 1) / ys;
}

static inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : (x + y - 1) / ys;
}

static inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : (x + y - 1) / ys;
}

static inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : (x + y - 1) / ys;
}

static inline uint8_t umod_safe8(uint8_t x, uint8_t y) {
  uint8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x % ys;
}

static inline uint16_t umod_safe16(uint16_t x, uint16_t y) {
  uint16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x % ys;
}

static inline uint32_t umod_safe32(uint32_t x, uint32_t y) {
  uint32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x % ys;
}

static inline uint64_t umod_safe64(uint64_t x, uint64_t y) {
  uint64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x % ys;
}

static inline int8_t sdiv8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  int8_t q = x / ys;
  int8_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int16_t sdiv16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  int16_t q = x / ys;
  int16_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int32_t sdiv32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  int32_t q = x / ys;
  int32_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int64_t sdiv64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  int64_t q = x / ys;
  int64_t r = x % ys;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int8_t sdiv_up8(int8_t x, int8_t y) {
  return sdiv8(x + y - 1, y);
}

static inline int16_t sdiv_up16(int16_t x, int16_t y) {
  return sdiv16(x + y - 1, y);
}

static inline int32_t sdiv_up32(int32_t x, int32_t y) {
  return sdiv32(x + y - 1, y);
}

static inline int64_t sdiv_up64(int64_t x, int64_t y) {
  return sdiv64(x + y - 1, y);
}

static inline int8_t smod8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  int8_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int16_t smod16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  int16_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int32_t smod32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  int32_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int64_t smod64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  int64_t r = x % ys;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int8_t sdiv_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : sdiv8(x, y);
}

static inline int16_t sdiv_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : sdiv16(x, y);
}

static inline int32_t sdiv_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : sdiv32(x, y);
}

static inline int64_t sdiv_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : sdiv64(x, y);
}

static inline int8_t sdiv_up_safe8(int8_t x, int8_t y) {
  return sdiv_safe8(x + y - 1, y);
}

static inline int16_t sdiv_up_safe16(int16_t x, int16_t y) {
  return sdiv_safe16(x + y - 1, y);
}

static inline int32_t sdiv_up_safe32(int32_t x, int32_t y) {
  return sdiv_safe32(x + y - 1, y);
}

static inline int64_t sdiv_up_safe64(int64_t x, int64_t y) {
  return sdiv_safe64(x + y - 1, y);
}

static inline int8_t smod_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : smod8(x, y);
}

static inline int16_t smod_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : smod16(x, y);
}

static inline int32_t smod_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : smod32(x, y);
}

static inline int64_t smod_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : smod64(x, y);
}

static inline int8_t squot8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x / ys;
}

static inline int16_t squot16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x / ys;
}

static inline int32_t squot32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x / ys;
}

static inline int64_t squot64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x / ys;
}

static inline int8_t srem8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x % ys;
}

static inline int16_t srem16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x % ys;
}

static inline int32_t srem32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x % ys;
}

static inline int64_t srem64(int64_t x, int64_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return x % ys;
}

static inline int8_t squot_safe8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x / ys;
}

static inline int16_t squot_safe16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x / ys;
}

static inline int32_t squot_safe32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x / ys;
}

static inline int64_t squot_safe64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x / ys;
}

static inline int8_t srem_safe8(int8_t x, int8_t y) {
  int8_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x % ys;
}

static inline int16_t srem_safe16(int16_t x, int16_t y) {
  int16_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x % ys;
}

static inline int32_t srem_safe32(int32_t x, int32_t y) {
  int32_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x % ys;
}

static inline int64_t srem_safe64(int64_t x, int64_t y) {
  int64_t ys = 1;
  foreach_active(i){
    ys = y;
  }
  
  return y == 0 ? 0 : x % ys;
}

#else

static inline uint8_t udiv8(uint8_t x, uint8_t y) {
  return x / y;
}

static inline uint16_t udiv16(uint16_t x, uint16_t y) {
  return x / y;
}

static inline uint32_t udiv32(uint32_t x, uint32_t y) {
  return x / y;
}

static inline uint64_t udiv64(uint64_t x, uint64_t y) {
  return x / y;
}

static inline uint8_t udiv_up8(uint8_t x, uint8_t y) {
  return (x + y - 1) / y;
}

static inline uint16_t udiv_up16(uint16_t x, uint16_t y) {
  return (x + y - 1) / y;
}

static inline uint32_t udiv_up32(uint32_t x, uint32_t y) {
  return (x + y - 1) / y;
}

static inline uint64_t udiv_up64(uint64_t x, uint64_t y) {
  return (x + y - 1) / y;
}

static inline uint8_t umod8(uint8_t x, uint8_t y) {
  return x % y;
}

static inline uint16_t umod16(uint16_t x, uint16_t y) {
  return x % y;
}

static inline uint32_t umod32(uint32_t x, uint32_t y) {
  return x % y;
}

static inline uint64_t umod64(uint64_t x, uint64_t y) {
  return x % y;
}

static inline uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint8_t umod_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint16_t umod_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint32_t umod_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint64_t umod_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int8_t sdiv8(int8_t x, int8_t y) {
  int8_t q = x / y;
  int8_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int16_t sdiv16(int16_t x, int16_t y) {
  int16_t q = x / y;
  int16_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int32_t sdiv32(int32_t x, int32_t y) {
  int32_t q = x / y;
  int32_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int64_t sdiv64(int64_t x, int64_t y) {
  int64_t q = x / y;
  int64_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int8_t sdiv_up8(int8_t x, int8_t y) {
  return sdiv8(x + y - 1, y);
}

static inline int16_t sdiv_up16(int16_t x, int16_t y) {
  return sdiv16(x + y - 1, y);
}

static inline int32_t sdiv_up32(int32_t x, int32_t y) {
  return sdiv32(x + y - 1, y);
}

static inline int64_t sdiv_up64(int64_t x, int64_t y) {
  return sdiv64(x + y - 1, y);
}

static inline int8_t smod8(int8_t x, int8_t y) {
  int8_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int16_t smod16(int16_t x, int16_t y) {
  int16_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int32_t smod32(int32_t x, int32_t y) {
  int32_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int64_t smod64(int64_t x, int64_t y) {
  int64_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int8_t sdiv_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : sdiv8(x, y);
}

static inline int16_t sdiv_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : sdiv16(x, y);
}

static inline int32_t sdiv_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : sdiv32(x, y);
}

static inline int64_t sdiv_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : sdiv64(x, y);
}

static inline int8_t sdiv_up_safe8(int8_t x, int8_t y) {
  return sdiv_safe8(x + y - 1, y);
}

static inline int16_t sdiv_up_safe16(int16_t x, int16_t y) {
  return sdiv_safe16(x + y - 1, y);
}

static inline int32_t sdiv_up_safe32(int32_t x, int32_t y) {
  return sdiv_safe32(x + y - 1, y);
}

static inline int64_t sdiv_up_safe64(int64_t x, int64_t y) {
  return sdiv_safe64(x + y - 1, y);
}

static inline int8_t smod_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : smod8(x, y);
}

static inline int16_t smod_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : smod16(x, y);
}

static inline int32_t smod_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : smod32(x, y);
}

static inline int64_t smod_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : smod64(x, y);
}

static inline int8_t squot8(int8_t x, int8_t y) {
  return x / y;
}

static inline int16_t squot16(int16_t x, int16_t y) {
  return x / y;
}

static inline int32_t squot32(int32_t x, int32_t y) {
  return x / y;
}

static inline int64_t squot64(int64_t x, int64_t y) {
  return x / y;
}

static inline int8_t srem8(int8_t x, int8_t y) {
  return x % y;
}

static inline int16_t srem16(int16_t x, int16_t y) {
  return x % y;
}

static inline int32_t srem32(int32_t x, int32_t y) {
  return x % y;
}

static inline int64_t srem64(int64_t x, int64_t y) {
  return x % y;
}

static inline int8_t squot_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int16_t squot_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int32_t squot_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int64_t squot_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int8_t srem_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int16_t srem_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int32_t srem_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int64_t srem_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x % y;
}

#endif

static inline int8_t smin8(int8_t x, int8_t y) {
  return x < y ? x : y;
}

static inline int16_t smin16(int16_t x, int16_t y) {
  return x < y ? x : y;
}

static inline int32_t smin32(int32_t x, int32_t y) {
  return x < y ? x : y;
}

static inline int64_t smin64(int64_t x, int64_t y) {
  return x < y ? x : y;
}

static inline uint8_t umin8(uint8_t x, uint8_t y) {
  return x < y ? x : y;
}

static inline uint16_t umin16(uint16_t x, uint16_t y) {
  return x < y ? x : y;
}

static inline uint32_t umin32(uint32_t x, uint32_t y) {
  return x < y ? x : y;
}

static inline uint64_t umin64(uint64_t x, uint64_t y) {
  return x < y ? x : y;
}

static inline int8_t smax8(int8_t x, int8_t y) {
  return x < y ? y : x;
}

static inline int16_t smax16(int16_t x, int16_t y) {
  return x < y ? y : x;
}

static inline int32_t smax32(int32_t x, int32_t y) {
  return x < y ? y : x;
}

static inline int64_t smax64(int64_t x, int64_t y) {
  return x < y ? y : x;
}

static inline uint8_t umax8(uint8_t x, uint8_t y) {
  return x < y ? y : x;
}

static inline uint16_t umax16(uint16_t x, uint16_t y) {
  return x < y ? y : x;
}

static inline uint32_t umax32(uint32_t x, uint32_t y) {
  return x < y ? y : x;
}

static inline uint64_t umax64(uint64_t x, uint64_t y) {
  return x < y ? y : x;
}

static inline uint8_t shl8(uint8_t x, uint8_t y) {
  return (uint8_t)(x << y);
}

static inline uint16_t shl16(uint16_t x, uint16_t y) {
  return (uint16_t)(x << y);
}

static inline uint32_t shl32(uint32_t x, uint32_t y) {
  return x << y;
}

static inline uint64_t shl64(uint64_t x, uint64_t y) {
  return x << y;
}

static inline uint8_t lshr8(uint8_t x, uint8_t y) {
  return x >> y;
}

static inline uint16_t lshr16(uint16_t x, uint16_t y) {
  return x >> y;
}

static inline uint32_t lshr32(uint32_t x, uint32_t y) {
  return x >> y;
}

static inline uint64_t lshr64(uint64_t x, uint64_t y) {
  return x >> y;
}

static inline int8_t ashr8(int8_t x, int8_t y) {
  return x >> y;
}

static inline int16_t ashr16(int16_t x, int16_t y) {
  return x >> y;
}

static inline int32_t ashr32(int32_t x, int32_t y) {
  return x >> y;
}

static inline int64_t ashr64(int64_t x, int64_t y) {
  return x >> y;
}

static inline uint8_t and8(uint8_t x, uint8_t y) {
  return x & y;
}

static inline uint16_t and16(uint16_t x, uint16_t y) {
  return x & y;
}

static inline uint32_t and32(uint32_t x, uint32_t y) {
  return x & y;
}

static inline uint64_t and64(uint64_t x, uint64_t y) {
  return x & y;
}

static inline uint8_t or8(uint8_t x, uint8_t y) {
  return x | y;
}

static inline uint16_t or16(uint16_t x, uint16_t y) {
  return x | y;
}

static inline uint32_t or32(uint32_t x, uint32_t y) {
  return x | y;
}

static inline uint64_t or64(uint64_t x, uint64_t y) {
  return x | y;
}

static inline uint8_t xor8(uint8_t x, uint8_t y) {
  return x ^ y;
}

static inline uint16_t xor16(uint16_t x, uint16_t y) {
  return x ^ y;
}

static inline uint32_t xor32(uint32_t x, uint32_t y) {
  return x ^ y;
}

static inline uint64_t xor64(uint64_t x, uint64_t y) {
  return x ^ y;
}

static inline bool ult8(uint8_t x, uint8_t y) {
  return x < y;
}

static inline bool ult16(uint16_t x, uint16_t y) {
  return x < y;
}

static inline bool ult32(uint32_t x, uint32_t y) {
  return x < y;
}

static inline bool ult64(uint64_t x, uint64_t y) {
  return x < y;
}

static inline bool ule8(uint8_t x, uint8_t y) {
  return x <= y;
}

static inline bool ule16(uint16_t x, uint16_t y) {
  return x <= y;
}

static inline bool ule32(uint32_t x, uint32_t y) {
  return x <= y;
}

static inline bool ule64(uint64_t x, uint64_t y) {
  return x <= y;
}

static inline bool slt8(int8_t x, int8_t y) {
  return x < y;
}

static inline bool slt16(int16_t x, int16_t y) {
  return x < y;
}

static inline bool slt32(int32_t x, int32_t y) {
  return x < y;
}

static inline bool slt64(int64_t x, int64_t y) {
  return x < y;
}

static inline bool sle8(int8_t x, int8_t y) {
  return x <= y;
}

static inline bool sle16(int16_t x, int16_t y) {
  return x <= y;
}

static inline bool sle32(int32_t x, int32_t y) {
  return x <= y;
}

static inline bool sle64(int64_t x, int64_t y) {
  return x <= y;
}

static inline uint8_t pow8(uint8_t x, uint8_t y) {
  uint8_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint16_t pow16(uint16_t x, uint16_t y) {
  uint16_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint32_t pow32(uint32_t x, uint32_t y) {
  uint32_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint64_t pow64(uint64_t x, uint64_t y) {
  uint64_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline bool itob_i8_bool(int8_t x) {
  return x != 0;
}

static inline bool itob_i16_bool(int16_t x) {
  return x != 0;
}

static inline bool itob_i32_bool(int32_t x) {
  return x != 0;
}

static inline bool itob_i64_bool(int64_t x) {
  return x != 0;
}

static inline int8_t btoi_bool_i8(bool x) {
  return x;
}

static inline int16_t btoi_bool_i16(bool x) {
  return x;
}

static inline int32_t btoi_bool_i32(bool x) {
  return x;
}

static inline int64_t btoi_bool_i64(bool x) {
  return x;
}

#define sext_i8_i8(x) ((int8_t) (int8_t) (x))
#define sext_i8_i16(x) ((int16_t) (int8_t) (x))
#define sext_i8_i32(x) ((int32_t) (int8_t) (x))
#define sext_i8_i64(x) ((int64_t) (int8_t) (x))
#define sext_i16_i8(x) ((int8_t) (int16_t) (x))
#define sext_i16_i16(x) ((int16_t) (int16_t) (x))
#define sext_i16_i32(x) ((int32_t) (int16_t) (x))
#define sext_i16_i64(x) ((int64_t) (int16_t) (x))
#define sext_i32_i8(x) ((int8_t) (int32_t) (x))
#define sext_i32_i16(x) ((int16_t) (int32_t) (x))
#define sext_i32_i32(x) ((int32_t) (int32_t) (x))
#define sext_i32_i64(x) ((int64_t) (int32_t) (x))
#define sext_i64_i8(x) ((int8_t) (int64_t) (x))
#define sext_i64_i16(x) ((int16_t) (int64_t) (x))
#define sext_i64_i32(x) ((int32_t) (int64_t) (x))
#define sext_i64_i64(x) ((int64_t) (int64_t) (x))
#define zext_i8_i8(x) ((int8_t) (uint8_t) (x))
#define zext_i8_i16(x) ((int16_t) (uint8_t) (x))
#define zext_i8_i32(x) ((int32_t) (uint8_t) (x))
#define zext_i8_i64(x) ((int64_t) (uint8_t) (x))
#define zext_i16_i8(x) ((int8_t) (uint16_t) (x))
#define zext_i16_i16(x) ((int16_t) (uint16_t) (x))
#define zext_i16_i32(x) ((int32_t) (uint16_t) (x))
#define zext_i16_i64(x) ((int64_t) (uint16_t) (x))
#define zext_i32_i8(x) ((int8_t) (uint32_t) (x))
#define zext_i32_i16(x) ((int16_t) (uint32_t) (x))
#define zext_i32_i32(x) ((int32_t) (uint32_t) (x))
#define zext_i32_i64(x) ((int64_t) (uint32_t) (x))
#define zext_i64_i8(x) ((int8_t) (uint64_t) (x))
#define zext_i64_i16(x) ((int16_t) (uint64_t) (x))
#define zext_i64_i32(x) ((int32_t) (uint64_t) (x))
#define zext_i64_i64(x) ((int64_t) (uint64_t) (x))

static int8_t abs8(int8_t x) {
  return (int8_t)abs(x);
}

static int16_t abs16(int16_t x) {
  return (int16_t)abs(x);
}

static int32_t abs32(int32_t x) {
  return abs(x);
}

static int64_t abs64(int64_t x) {
#if defined(__OPENCL_VERSION__) || defined(ISPC)
  return abs(x);
#else
  return llabs(x);
#endif
}

#if defined(__OPENCL_VERSION__)
static int32_t futrts_popc8(int8_t x) {
  return popcount(x);
}

static int32_t futrts_popc16(int16_t x) {
  return popcount(x);
}

static int32_t futrts_popc32(int32_t x) {
  return popcount(x);
}

static int32_t futrts_popc64(int64_t x) {
  return popcount(x);
}
#elif defined(__CUDA_ARCH__)

static int32_t futrts_popc8(int8_t x) {
  return __popc(zext_i8_i32(x));
}

static int32_t futrts_popc16(int16_t x) {
  return __popc(zext_i16_i32(x));
}

static int32_t futrts_popc32(int32_t x) {
  return __popc(x);
}

static int32_t futrts_popc64(int64_t x) {
  return __popcll(x);
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_popc8(uint8_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc16(uint16_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc32(uint32_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc64(uint64_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}
#endif

#if defined(__OPENCL_VERSION__)
static uint8_t  futrts_umul_hi8 ( uint8_t a,  uint8_t b) { return mul_hi(a, b); }
static uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return mul_hi(a, b); }
static uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return mul_hi(a, b); }
static uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return mul_hi(a, b); }
static uint8_t  futrts_smul_hi8 ( int8_t a,  int8_t b) { return mul_hi(a, b); }
static uint16_t futrts_smul_hi16(int16_t a, int16_t b) { return mul_hi(a, b); }
static uint32_t futrts_smul_hi32(int32_t a, int32_t b) { return mul_hi(a, b); }
static uint64_t futrts_smul_hi64(int64_t a, int64_t b) { return mul_hi(a, b); }
#elif defined(__CUDA_ARCH__)
static  uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
static uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
static uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return __umulhi(a, b); }
static uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return __umul64hi(a, b); }
static  uint8_t futrts_smul_hi8 ( int8_t a, int8_t b) { return ((int16_t)a) * ((int16_t)b) >> 8; }
static uint16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((int32_t)a) * ((int32_t)b) >> 16; }
static uint32_t futrts_smul_hi32(int32_t a, int32_t b) { return __mulhi(a, b); }
static uint64_t futrts_smul_hi64(int64_t a, int64_t b) { return __mul64hi(a, b); }
#elif ISPC
static uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
static uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
static uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
static uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) {
  uint64_t ah = a >> 32;
  uint64_t al = a & 0xffffffff;
  uint64_t bh = b >> 32;
  uint64_t bl = b & 0xffffffff;

  uint64_t p1 = al * bl;
  uint64_t p2 = al * bh;
  uint64_t p3 = ah * bl;
  uint64_t p4 = ah * bh;

  uint64_t p1h = p1 >> 32;
  uint64_t p2h = p2 >> 32;
  uint64_t p3h = p3 >> 32;
  uint64_t p2l = p2 & 0xffffffff;
  uint64_t p3l = p3 & 0xffffffff;

  uint64_t l = p1h + p2l + p3l;
  uint64_t m = (p2 >> 32) + (p3 >> 32);
  uint64_t h = (l >> 32) + m + p4;

  return h;
}
static  int8_t futrts_smul_hi8 ( int8_t a,  int8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
static int16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
static int32_t futrts_smul_hi32(int32_t a, int32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
static int64_t futrts_smul_hi64(int64_t a, int64_t b) {
  uint64_t ah = a >> 32;
  uint64_t al = a & 0xffffffff;
  uint64_t bh = b >> 32;
  uint64_t bl = b & 0xffffffff;

  uint64_t p1 =  al * bl;
  int64_t  p2 = al * bh;
  int64_t  p3 = ah * bl;
  uint64_t p4 =  ah * bh;

  uint64_t p1h = p1 >> 32;
  uint64_t p2h = p2 >> 32;
  uint64_t p3h = p3 >> 32;
  uint64_t p2l = p2 & 0xffffffff;
  uint64_t p3l = p3 & 0xffffffff;

  uint64_t l = p1h + p2l + p3l;
  uint64_t m = (p2 >> 32) + (p3 >> 32);
  uint64_t h = (l >> 32) + m + p4;

  return h;
}

#else // Not OpenCL, ISPC, or CUDA, but plain C.
static uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }
static uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }
static uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }
static uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return ((__uint128_t)a) * ((__uint128_t)b) >> 64; }
static int8_t futrts_smul_hi8(int8_t a, int8_t b) { return ((int16_t)a) * ((int16_t)b) >> 8; }
static int16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((int32_t)a) * ((int32_t)b) >> 16; }
static int32_t futrts_smul_hi32(int32_t a, int32_t b) { return ((int64_t)a) * ((int64_t)b) >> 32; }
static int64_t futrts_smul_hi64(int64_t a, int64_t b) { return ((__int128_t)a) * ((__int128_t)b) >> 64; }
#endif

#if defined(__OPENCL_VERSION__)
static  uint8_t futrts_umad_hi8 ( uint8_t a,  uint8_t b,  uint8_t c) { return mad_hi(a, b, c); }
static uint16_t futrts_umad_hi16(uint16_t a, uint16_t b, uint16_t c) { return mad_hi(a, b, c); }
static uint32_t futrts_umad_hi32(uint32_t a, uint32_t b, uint32_t c) { return mad_hi(a, b, c); }
static uint64_t futrts_umad_hi64(uint64_t a, uint64_t b, uint64_t c) { return mad_hi(a, b, c); }
static  uint8_t futrts_smad_hi8( int8_t a,  int8_t b,   int8_t c) { return mad_hi(a, b, c); }
static uint16_t futrts_smad_hi16(int16_t a, int16_t b, int16_t c) { return mad_hi(a, b, c); }
static uint32_t futrts_smad_hi32(int32_t a, int32_t b, int32_t c) { return mad_hi(a, b, c); }
static uint64_t futrts_smad_hi64(int64_t a, int64_t b, int64_t c) { return mad_hi(a, b, c); }
#else // Not OpenCL

static  uint8_t futrts_umad_hi8( uint8_t a,  uint8_t b,  uint8_t c) { return futrts_umul_hi8(a, b) + c; }
static uint16_t futrts_umad_hi16(uint16_t a, uint16_t b, uint16_t c) { return futrts_umul_hi16(a, b) + c; }
static uint32_t futrts_umad_hi32(uint32_t a, uint32_t b, uint32_t c) { return futrts_umul_hi32(a, b) + c; }
static uint64_t futrts_umad_hi64(uint64_t a, uint64_t b, uint64_t c) { return futrts_umul_hi64(a, b) + c; }
static  uint8_t futrts_smad_hi8 ( int8_t a,  int8_t b,  int8_t c) { return futrts_smul_hi8(a, b) + c; }
static uint16_t futrts_smad_hi16(int16_t a, int16_t b, int16_t c) { return futrts_smul_hi16(a, b) + c; }
static uint32_t futrts_smad_hi32(int32_t a, int32_t b, int32_t c) { return futrts_smul_hi32(a, b) + c; }
static uint64_t futrts_smad_hi64(int64_t a, int64_t b, int64_t c) { return futrts_smul_hi64(a, b) + c; }
#endif

#if defined(__OPENCL_VERSION__)
static int32_t futrts_clzz8(int8_t x) {
  return clz(x);
}

static int32_t futrts_clzz16(int16_t x) {
  return clz(x);
}

static int32_t futrts_clzz32(int32_t x) {
  return clz(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return clz(x);
}

#elif defined(__CUDA_ARCH__)

static int32_t futrts_clzz8(int8_t x) {
  return __clz(zext_i8_i32(x)) - 24;
}

static int32_t futrts_clzz16(int16_t x) {
  return __clz(zext_i16_i32(x)) - 16;
}

static int32_t futrts_clzz32(int32_t x) {
  return __clz(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return __clzll(x);
}

#elif ISPC

static int32_t futrts_clzz8(int8_t x) {
  return count_leading_zeros((int32_t)(uint8_t)x)-24;
}

static int32_t futrts_clzz16(int16_t x) {
  return count_leading_zeros((int32_t)(uint16_t)x)-16;
}

static int32_t futrts_clzz32(int32_t x) {
  return count_leading_zeros(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return count_leading_zeros(x);
}

#else // Not OpenCL, ISPC or CUDA, but plain C.

static int32_t futrts_clzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_clz((uint32_t)zext_i8_i32(x)) - 24;
}

static int32_t futrts_clzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_clz((uint32_t)zext_i16_i32(x)) - 16;
}

static int32_t futrts_clzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_clz((uint32_t)x);
}

static int32_t futrts_clzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_clzll((uint64_t)x);
}
#endif

#if defined(__OPENCL_VERSION__)
static int32_t futrts_ctzz8(int8_t x) {
  int i = 0;
  for (; i < 8 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz16(int16_t x) {
  int i = 0;
  for (; i < 16 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz32(int32_t x) {
  int i = 0;
  for (; i < 32 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz64(int64_t x) {
  int i = 0;
  for (; i < 64 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

#elif defined(__CUDA_ARCH__)

static int32_t futrts_ctzz8(int8_t x) {
  int y = __ffs(x);
  return y == 0 ? 8 : y - 1;
}

static int32_t futrts_ctzz16(int16_t x) {
  int y = __ffs(x);
  return y == 0 ? 16 : y - 1;
}

static int32_t futrts_ctzz32(int32_t x) {
  int y = __ffs(x);
  return y == 0 ? 32 : y - 1;
}

static int32_t futrts_ctzz64(int64_t x) {
  int y = __ffsll(x);
  return y == 0 ? 64 : y - 1;
}

#elif ISPC

static int32_t futrts_ctzz8(int8_t x) {
  return x == 0 ? 8 : count_trailing_zeros((int32_t)x);
}

static int32_t futrts_ctzz16(int16_t x) {
  return x == 0 ? 16 : count_trailing_zeros((int32_t)x);
}

static int32_t futrts_ctzz32(int32_t x) {
  return count_trailing_zeros(x);
}

static int32_t futrts_ctzz64(int64_t x) {
  return count_trailing_zeros(x);
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_ctzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_ctzll((uint64_t)x);
}
#endif

static inline float fdiv32(float x, float y) {
  return x / y;
}

static inline float fadd32(float x, float y) {
  return x + y;
}

static inline float fsub32(float x, float y) {
  return x - y;
}

static inline float fmul32(float x, float y) {
  return x * y;
}

static inline bool cmplt32(float x, float y) {
  return x < y;
}

static inline bool cmple32(float x, float y) {
  return x <= y;
}

static inline float sitofp_i8_f32(int8_t x) {
  return (float) x;
}

static inline float sitofp_i16_f32(int16_t x) {
  return (float) x;
}

static inline float sitofp_i32_f32(int32_t x) {
  return (float) x;
}

static inline float sitofp_i64_f32(int64_t x) {
  return (float) x;
}

static inline float uitofp_i8_f32(uint8_t x) {
  return (float) x;
}

static inline float uitofp_i16_f32(uint16_t x) {
  return (float) x;
}

static inline float uitofp_i32_f32(uint32_t x) {
  return (float) x;
}

static inline float uitofp_i64_f32(uint64_t x) {
  return (float) x;
}

#ifdef __OPENCL_VERSION__
static inline float fabs32(float x) {
  return fabs(x);
}

static inline float fmax32(float x, float y) {
  return fmax(x, y);
}

static inline float fmin32(float x, float y) {
  return fmin(x, y);
}

static inline float fpow32(float x, float y) {
  return pow(x, y);
}

#elif ISPC

static inline float fabs32(float x) {
  return abs(x);
}

static inline float fmax32(float x, float y) {
  return isnan(x) ? y : isnan(y) ? x : max(x, y);
}

static inline float fmin32(float x, float y) {
  return isnan(x) ? y : isnan(y) ? x : min(x, y);
}

static inline float fpow32(float a, float b) {
  float ret;
  foreach_active (i) {
      uniform float r = __stdlib_powf(extract(a, i), extract(b, i));
      ret = insert(ret, i, r);
  }
  return ret;
}

#else // Not OpenCL, but CUDA or plain C.

static inline float fabs32(float x) {
  return fabsf(x);
}

static inline float fmax32(float x, float y) {
  return fmaxf(x, y);
}

static inline float fmin32(float x, float y) {
  return fminf(x, y);
}

static inline float fpow32(float x, float y) {
  return powf(x, y);
}
#endif

static inline bool futrts_isnan32(float x) {
  return isnan(x);
}

#if ISPC

static inline bool futrts_isinf32(float x) {
  return !isnan(x) && isnan(x - x);
}

static inline bool futrts_isfinite32(float x) {
  return !isnan(x) && !futrts_isinf32(x);
}

#else

static inline bool futrts_isinf32(float x) {
  return isinf(x);
}

#endif

static inline int8_t fptosi_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

static inline int16_t fptosi_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

static inline int32_t fptosi_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

static inline int64_t fptosi_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int64_t) x;
  };
}

static inline uint8_t fptoui_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

static inline uint16_t fptoui_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

static inline uint32_t fptoui_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

static inline uint64_t fptoui_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

static inline bool ftob_f32_bool(float x) {
  return x != 0;
}

static inline float btof_bool_f32(bool x) {
  return x ? 1 : 0;
}

#ifdef __OPENCL_VERSION__
static inline float futrts_log32(float x) {
  return log(x);
}

static inline float futrts_log2_32(float x) {
  return log2(x);
}

static inline float futrts_log10_32(float x) {
  return log10(x);
}

static inline float futrts_log1p_32(float x) {
  return log1p(x);
}

static inline float futrts_sqrt32(float x) {
  return sqrt(x);
}

static inline float futrts_cbrt32(float x) {
  return cbrt(x);
}

static inline float futrts_exp32(float x) {
  return exp(x);
}

static inline float futrts_cos32(float x) {
  return cos(x);
}

static inline float futrts_sin32(float x) {
  return sin(x);
}

static inline float futrts_tan32(float x) {
  return tan(x);
}

static inline float futrts_acos32(float x) {
  return acos(x);
}

static inline float futrts_asin32(float x) {
  return asin(x);
}

static inline float futrts_atan32(float x) {
  return atan(x);
}

static inline float futrts_cosh32(float x) {
  return cosh(x);
}

static inline float futrts_sinh32(float x) {
  return sinh(x);
}

static inline float futrts_tanh32(float x) {
  return tanh(x);
}

static inline float futrts_acosh32(float x) {
  return acosh(x);
}

static inline float futrts_asinh32(float x) {
  return asinh(x);
}

static inline float futrts_atanh32(float x) {
  return atanh(x);
}

static inline float futrts_atan2_32(float x, float y) {
  return atan2(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  return hypot(x, y);
}

static inline float futrts_gamma32(float x) {
  return tgamma(x);
}

static inline float futrts_lgamma32(float x) {
  return lgamma(x);
}

static inline float futrts_erf32(float x) {
  return erf(x);
}

static inline float futrts_erfc32(float x) {
  return erfc(x);
}

static inline float fmod32(float x, float y) {
  return fmod(x, y);
}

static inline float futrts_round32(float x) {
  return rint(x);
}

static inline float futrts_floor32(float x) {
  return floor(x);
}

static inline float futrts_ceil32(float x) {
  return ceil(x);
}

static inline float futrts_nextafter32(float x, float y) {
  return nextafter(x, y);
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return mix(v0, v1, t);
}

static inline float futrts_mad32(float a, float b, float c) {
  return mad(a, b, c);
}

static inline float futrts_fma32(float a, float b, float c) {
  return fma(a, b, c);
}

#elif ISPC

static inline float futrts_log32(float x) {
  return futrts_isfinite32(x) || (futrts_isinf32(x) && x < 0)? log(x) : x;
}

static inline float futrts_log2_32(float x) {
  return futrts_log32(x) / log(2.0f);
}

static inline float futrts_log10_32(float x) {
  return futrts_log32(x) / log(10.0f);
}

static inline float futrts_log1p_32(float x) {
  if(x == -1.0f || (futrts_isinf32(x) && x > 0.0f)) return x / 0.0f;
  float y = 1.0f + x;
  float z = y - 1.0f;
  return log(y) - (z-x)/y;
}

static inline float futrts_sqrt32(float x) {
  return sqrt(x);
}

extern "C" unmasked uniform float cbrtf(uniform float);
static inline float futrts_cbrt32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = cbrtf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

static inline float futrts_exp32(float x) {
  return exp(x);
}

static inline float futrts_cos32(float x) {
  return cos(x);
}

static inline float futrts_sin32(float x) {
  return sin(x);
}

static inline float futrts_tan32(float x) {
  return tan(x);
}

static inline float futrts_acos32(float x) {
  return acos(x);
}

static inline float futrts_asin32(float x) {
  return asin(x);
}

static inline float futrts_atan32(float x) {
  return atan(x);
}

static inline float futrts_cosh32(float x) {
  return (exp(x)+exp(-x)) / 2.0f;
}

static inline float futrts_sinh32(float x) {
  return (exp(x)-exp(-x)) / 2.0f;
}

static inline float futrts_tanh32(float x) {
  return futrts_sinh32(x)/futrts_cosh32(x);
}

static inline float futrts_acosh32(float x) {
  float f = x+sqrt(x*x-1);
  if(futrts_isfinite32(f)) return log(f);
  return f;
}

static inline float futrts_asinh32(float x) {
  float f = x+sqrt(x*x+1);
  if(futrts_isfinite32(f)) return log(f);
  return f;

}

static inline float futrts_atanh32(float x) {
  float f = (1+x)/(1-x);
  if(futrts_isfinite32(f)) return log(f)/2.0f;
  return f;

}

static inline float futrts_atan2_32(float x, float y) {
  return (x == 0.0f && y == 0.0f) ? 0.0f : atan2(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  if (futrts_isfinite32(x) && futrts_isfinite32(y)) {
    x = abs(x);
    y = abs(y);
    float a;
    float b;
    if (x >= y){
        a = x;
        b = y;
    } else {
        a = y;
        b = x;
    }
    if(b == 0){
      return a;
    }

    int e;
    float an;
    float bn;
    an = frexp (a, &e);
    bn = ldexp (b, - e);
    float cn;
    cn = sqrt (an * an + bn * bn);
    return ldexp (cn, e);
  } else {
    if (futrts_isinf32(x) || futrts_isinf32(y)) return INFINITY;
    else return x + y;
  }

}

extern "C" unmasked uniform float tgammaf(uniform float x);
static inline float futrts_gamma32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = tgammaf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float lgammaf(uniform float x);
static inline float futrts_lgamma32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = lgammaf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float erff(uniform float x);
static inline float futrts_erf32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = erff(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float erfcf(uniform float x);
static inline float futrts_erfc32(float x) {
  float res;
  foreach_active (i) {
    uniform float r = erfcf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

static inline float fmod32(float x, float y) {
  return x - y * trunc(x/y);
}

static inline float futrts_round32(float x) {
  return round(x);
}

static inline float futrts_floor32(float x) {
  return floor(x);
}

static inline float futrts_ceil32(float x) {
  return ceil(x);
}

extern "C" unmasked uniform float nextafterf(uniform float x, uniform float y);
static inline float futrts_nextafter32(float x, float y) {
  float res;
  foreach_active (i) {
    uniform float r = nextafterf(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

static inline float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

static inline float futrts_fma32(float a, float b, float c) {
  return a * b + c;
}

#else // Not OpenCL or ISPC, but CUDA or plain C.

static inline float futrts_log32(float x) {
  return logf(x);
}

static inline float futrts_log2_32(float x) {
  return log2f(x);
}

static inline float futrts_log10_32(float x) {
  return log10f(x);
}

static inline float futrts_log1p_32(float x) {
  return log1pf(x);
}

static inline float futrts_sqrt32(float x) {
  return sqrtf(x);
}

static inline float futrts_cbrt32(float x) {
  return cbrtf(x);
}

static inline float futrts_exp32(float x) {
  return expf(x);
}

static inline float futrts_cos32(float x) {
  return cosf(x);
}

static inline float futrts_sin32(float x) {
  return sinf(x);
}

static inline float futrts_tan32(float x) {
  return tanf(x);
}

static inline float futrts_acos32(float x) {
  return acosf(x);
}

static inline float futrts_asin32(float x) {
  return asinf(x);
}

static inline float futrts_atan32(float x) {
  return atanf(x);
}

static inline float futrts_cosh32(float x) {
  return coshf(x);
}

static inline float futrts_sinh32(float x) {
  return sinhf(x);
}

static inline float futrts_tanh32(float x) {
  return tanhf(x);
}

static inline float futrts_acosh32(float x) {
  return acoshf(x);
}

static inline float futrts_asinh32(float x) {
  return asinhf(x);
}

static inline float futrts_atanh32(float x) {
  return atanhf(x);
}

static inline float futrts_atan2_32(float x, float y) {
  return atan2f(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  return hypotf(x, y);
}

static inline float futrts_gamma32(float x) {
  return tgammaf(x);
}

static inline float futrts_lgamma32(float x) {
  return lgammaf(x);
}

static inline float futrts_erf32(float x) {
  return erff(x);
}

static inline float futrts_erfc32(float x) {
  return erfcf(x);
}

static inline float fmod32(float x, float y) {
  return fmodf(x, y);
}

static inline float futrts_round32(float x) {
  return rintf(x);
}

static inline float futrts_floor32(float x) {
  return floorf(x);
}

static inline float futrts_ceil32(float x) {
  return ceilf(x);
}

static inline float futrts_nextafter32(float x, float y) {
  return nextafterf(x, y);
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

static inline float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

static inline float futrts_fma32(float a, float b, float c) {
  return fmaf(a, b, c);
}
#endif

#if ISPC
static inline int32_t futrts_to_bits32(float x) {
  return intbits(x);
}

static inline float futrts_from_bits32(int32_t x) {
  return floatbits(x);
}
#else
static inline int32_t futrts_to_bits32(float x) {
  union {
    float f;
    int32_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline float futrts_from_bits32(int32_t x) {
  union {
    int32_t f;
    float t;
  } p;

  p.f = x;
  return p.t;
}
#endif

static inline float fsignum32(float x) {
  return futrts_isnan32(x) ? x : (x > 0 ? 1 : 0) - (x < 0 ? 1 : 0);
}

#ifdef FUTHARK_F64_ENABLED

#if ISPC
static inline bool futrts_isinf64(float x) {
  return !isnan(x) && isnan(x - x);
}

static inline bool futrts_isfinite64(float x) {
  return !isnan(x) && !futrts_isinf64(x);
}

static inline double fdiv64(double x, double y) {
  return x / y;
}

static inline double fadd64(double x, double y) {
  return x + y;
}

static inline double fsub64(double x, double y) {
  return x - y;
}

static inline double fmul64(double x, double y) {
  return x * y;
}

static inline bool cmplt64(double x, double y) {
  return x < y;
}

static inline bool cmple64(double x, double y) {
  return x <= y;
}

static inline double sitofp_i8_f64(int8_t x) {
  return (double) x;
}

static inline double sitofp_i16_f64(int16_t x) {
  return (double) x;
}

static inline double sitofp_i32_f64(int32_t x) {
  return (double) x;
}

static inline double sitofp_i64_f64(int64_t x) {
  return (double) x;
}

static inline double uitofp_i8_f64(uint8_t x) {
  return (double) x;
}

static inline double uitofp_i16_f64(uint16_t x) {
  return (double) x;
}

static inline double uitofp_i32_f64(uint32_t x) {
  return (double) x;
}

static inline double uitofp_i64_f64(uint64_t x) {
  return (double) x;
}

static inline double fabs64(double x) {
  return abs(x);
}

static inline double fmax64(double x, double y) {
  return isnan(x) ? y : isnan(y) ? x : max(x, y);
}

static inline double fmin64(double x, double y) {
  return isnan(x) ? y : isnan(y) ? x : min(x, y);
}

static inline double fpow64(double a, double b) {
  float ret;
  foreach_active (i) {
      uniform float r = __stdlib_powf(extract(a, i), extract(b, i));
      ret = insert(ret, i, r);
  }
  return ret;
}

static inline double futrts_log64(double x) {
  return futrts_isfinite64(x) || (futrts_isinf64(x) && x < 0)? log(x) : x;
}

static inline double futrts_log2_64(double x) {
  return futrts_log64(x)/log(2.0d);
}

static inline double futrts_log10_64(double x) {
  return futrts_log64(x)/log(10.0d);
}

static inline double futrts_log1p_64(double x) {
  if(x == -1.0d || (futrts_isinf64(x) && x > 0.0d)) return x / 0.0d;
  double y = 1.0d + x;
  double z = y - 1.0d;
  return log(y) - (z-x)/y;
}

static inline double futrts_sqrt64(double x) {
  return sqrt(x);
}

extern "C" unmasked uniform double cbrt(uniform double);
static inline double futrts_cbrt64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = cbrtf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

static inline double futrts_exp64(double x) {
  return exp(x);
}

static inline double futrts_cos64(double x) {
  return cos(x);
}

static inline double futrts_sin64(double x) {
  return sin(x);
}

static inline double futrts_tan64(double x) {
  return tan(x);
}

static inline double futrts_acos64(double x) {
  return acos(x);
}

static inline double futrts_asin64(double x) {
  return asin(x);
}

static inline double futrts_atan64(double x) {
  return atan(x);
}

static inline double futrts_cosh64(double x) {
  return (exp(x)+exp(-x)) / 2.0d;
}

static inline double futrts_sinh64(double x) {
  return (exp(x)-exp(-x)) / 2.0d;
}

static inline double futrts_tanh64(double x) {
  return futrts_sinh64(x)/futrts_cosh64(x);
}

static inline double futrts_acosh64(double x) {
  double f = x+sqrt(x*x-1.0d);
  if(futrts_isfinite64(f)) return log(f);
  return f;
}

static inline double futrts_asinh64(double x) {
  double f = x+sqrt(x*x+1.0d);
  if(futrts_isfinite64(f)) return log(f);
  return f;
}

static inline double futrts_atanh64(double x) {
  double f = (1.0d+x)/(1.0d-x);
  if(futrts_isfinite64(f)) return log(f)/2.0d;
  return f;

}

static inline double futrts_atan2_64(double x, double y) {
  return atan2(x, y);
}

extern "C" unmasked uniform double hypot(uniform double x, uniform double y);
static inline double futrts_hypot64(double x, double y) {
  double res;
  foreach_active (i) {
    uniform double r = hypot(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double tgamma(uniform double x);
static inline double futrts_gamma64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = tgamma(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double lgamma(uniform double x);
static inline double futrts_lgamma64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = lgamma(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double erf(uniform double x);
static inline double futrts_erf64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = erf(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform double erfc(uniform double x);
static inline double futrts_erfc64(double x) {
  double res;
  foreach_active (i) {
    uniform double r = erfc(extract(x, i));
    res = insert(res, i, r);
  }
  return res;
}

static inline double futrts_fma64(double a, double b, double c) {
  return a * b + c;
}

static inline double futrts_round64(double x) {
  return round(x);
}

static inline double futrts_ceil64(double x) {
  return ceil(x);
}

extern "C" unmasked uniform double nextafter(uniform float x, uniform double y);
static inline float futrts_nextafter64(double x, double y) {
  double res;
  foreach_active (i) {
    uniform double r = nextafter(extract(x, i), extract(y, i));
    res = insert(res, i, r);
  }
  return res;
}

static inline double futrts_floor64(double x) {
  return floor(x);
}

static inline bool futrts_isnan64(double x) {
  return isnan(x);
}

static inline int8_t fptosi_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

static inline int16_t fptosi_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

static inline int32_t fptosi_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

static inline int64_t fptosi_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int64_t) x;
  }
}

static inline uint8_t fptoui_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

static inline uint16_t fptoui_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

static inline uint32_t fptoui_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

static inline uint64_t fptoui_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

static inline bool ftob_f64_bool(double x) {
  return x != 0.0;
}

static inline double btof_bool_f64(bool x) {
  return x ? 1.0 : 0.0;
}

static inline int64_t futrts_to_bits64(double x) {
  int64_t res;
  foreach_active (i) {
    uniform double tmp = extract(x, i);
    uniform int64_t r = *((uniform int64_t* uniform)&tmp);
    res = insert(res, i, r);
  }
  return res;
}

static inline double futrts_from_bits64(int64_t x) {
  double res;
  foreach_active (i) {
    uniform int64_t tmp = extract(x, i);
    uniform double r = *((uniform double* uniform)&tmp);
    res = insert(res, i, r);
  }
  return res;
}

static inline double fmod64(double x, double y) {
  return x - y * trunc(x/y);
}

static inline double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0 ? 1.0d : 0.0d) - (x < 0 ? 1.0d : 0.0d);
}

static inline double futrts_lerp64(double v0, double v1, double t) {
  return v0 + (v1 - v0) * t;
}

static inline double futrts_mad64(double a, double b, double c) {
  return a * b + c;
}

static inline float fpconv_f32_f32(float x) {
  return (float) x;
}

static inline double fpconv_f32_f64(float x) {
  return (double) x;
}

static inline float fpconv_f64_f32(double x) {
  return (float) x;
}

static inline double fpconv_f64_f64(double x) {
  return (double) x;
}

#else

static inline double fdiv64(double x, double y) {
  return x / y;
}

static inline double fadd64(double x, double y) {
  return x + y;
}

static inline double fsub64(double x, double y) {
  return x - y;
}

static inline double fmul64(double x, double y) {
  return x * y;
}

static inline bool cmplt64(double x, double y) {
  return x < y;
}

static inline bool cmple64(double x, double y) {
  return x <= y;
}

static inline double sitofp_i8_f64(int8_t x) {
  return (double) x;
}

static inline double sitofp_i16_f64(int16_t x) {
  return (double) x;
}

static inline double sitofp_i32_f64(int32_t x) {
  return (double) x;
}

static inline double sitofp_i64_f64(int64_t x) {
  return (double) x;
}

static inline double uitofp_i8_f64(uint8_t x) {
  return (double) x;
}

static inline double uitofp_i16_f64(uint16_t x) {
  return (double) x;
}

static inline double uitofp_i32_f64(uint32_t x) {
  return (double) x;
}

static inline double uitofp_i64_f64(uint64_t x) {
  return (double) x;
}

static inline double fabs64(double x) {
  return fabs(x);
}

static inline double fmax64(double x, double y) {
  return fmax(x, y);
}

static inline double fmin64(double x, double y) {
  return fmin(x, y);
}

static inline double fpow64(double x, double y) {
  return pow(x, y);
}

static inline double futrts_log64(double x) {
  return log(x);
}

static inline double futrts_log2_64(double x) {
  return log2(x);
}

static inline double futrts_log10_64(double x) {
  return log10(x);
}

static inline double futrts_log1p_64(double x) {
  return log1p(x);
}

static inline double futrts_sqrt64(double x) {
  return sqrt(x);
}

static inline double futrts_cbrt64(double x) {
  return cbrt(x);
}

static inline double futrts_exp64(double x) {
  return exp(x);
}

static inline double futrts_cos64(double x) {
  return cos(x);
}

static inline double futrts_sin64(double x) {
  return sin(x);
}

static inline double futrts_tan64(double x) {
  return tan(x);
}

static inline double futrts_acos64(double x) {
  return acos(x);
}

static inline double futrts_asin64(double x) {
  return asin(x);
}

static inline double futrts_atan64(double x) {
  return atan(x);
}

static inline double futrts_cosh64(double x) {
  return cosh(x);
}

static inline double futrts_sinh64(double x) {
  return sinh(x);
}

static inline double futrts_tanh64(double x) {
  return tanh(x);
}

static inline double futrts_acosh64(double x) {
  return acosh(x);
}

static inline double futrts_asinh64(double x) {
  return asinh(x);
}

static inline double futrts_atanh64(double x) {
  return atanh(x);
}

static inline double futrts_atan2_64(double x, double y) {
  return atan2(x, y);
}

static inline double futrts_hypot64(double x, double y) {
  return hypot(x, y);
}

static inline double futrts_gamma64(double x) {
  return tgamma(x);
}

static inline double futrts_lgamma64(double x) {
  return lgamma(x);
}

static inline double futrts_erf64(double x) {
  return erf(x);
}

static inline double futrts_erfc64(double x) {
  return erfc(x);
}

static inline double futrts_fma64(double a, double b, double c) {
  return fma(a, b, c);
}

static inline double futrts_round64(double x) {
  return rint(x);
}

static inline double futrts_ceil64(double x) {
  return ceil(x);
}

static inline float futrts_nextafter64(float x, float y) {
  return nextafter(x, y);
}

static inline double futrts_floor64(double x) {
  return floor(x);
}

static inline bool futrts_isnan64(double x) {
  return isnan(x);
}

static inline bool futrts_isinf64(double x) {
  return isinf(x);
}

static inline int8_t fptosi_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

static inline int16_t fptosi_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

static inline int32_t fptosi_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

static inline int64_t fptosi_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int64_t) x;
  }
}

static inline uint8_t fptoui_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

static inline uint16_t fptoui_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

static inline uint32_t fptoui_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

static inline uint64_t fptoui_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

static inline bool ftob_f64_bool(double x) {
  return x != 0;
}

static inline double btof_bool_f64(bool x) {
  return x ? 1 : 0;
}

static inline int64_t futrts_to_bits64(double x) {
  union {
    double f;
    int64_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline double futrts_from_bits64(int64_t x) {
  union {
    int64_t f;
    double t;
  } p;

  p.f = x;
  return p.t;
}

static inline double fmod64(double x, double y) {
  return fmod(x, y);
}

static inline double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0) - (x < 0);
}

static inline double futrts_lerp64(double v0, double v1, double t) {
#ifdef __OPENCL_VERSION__
  return mix(v0, v1, t);
#else
  return v0 + (v1 - v0) * t;
#endif
}

static inline double futrts_mad64(double a, double b, double c) {
#ifdef __OPENCL_VERSION__
  return mad(a, b, c);
#else
  return a * b + c;
#endif
}

static inline float fpconv_f32_f32(float x) {
  return (float) x;
}

static inline double fpconv_f32_f64(float x) {
  return (double) x;
}

static inline float fpconv_f64_f32(double x) {
  return (float) x;
}

static inline double fpconv_f64_f64(double x) {
  return (double) x;
}

#endif

#endif

// End of scalar.h.
// Start of scalar_f16.h.

// Half-precision is emulated if needed (e.g. in straight C) with the
// native type used if possible.  The emulation works by typedef'ing
// 'float' to 'f16', and then implementing all operations on single
// precision.  To cut down on duplication, we use the same code for
// those Futhark functions that require just operators or casts.  The
// in-memory representation for arrays will still be 16 bits even
// under emulation, so the compiler will have to be careful when
// generating reads or writes.

#if !defined(cl_khr_fp16) && !(defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 600) && !(defined(ISPC))
#define EMULATE_F16
#endif

#if !defined(EMULATE_F16) && defined(__OPENCL_VERSION__)
#pragma OPENCL EXTENSION cl_khr_fp16 : enable
#endif

#ifdef EMULATE_F16

// Note that the half-precision storage format is still 16 bits - the
// compiler will have to be real careful!
typedef float f16;

#elif ISPC
typedef float16 f16;

#else

#ifdef __CUDA_ARCH__
#include <cuda_fp16.h>
#endif

typedef half f16;

#endif

// Some of these functions convert to single precision because half
// precision versions are not available.

static inline f16 fadd16(f16 x, f16 y) {
  return x + y;
}

static inline f16 fsub16(f16 x, f16 y) {
  return x - y;
}

static inline f16 fmul16(f16 x, f16 y) {
  return x * y;
}

static inline bool cmplt16(f16 x, f16 y) {
  return x < y;
}

static inline bool cmple16(f16 x, f16 y) {
  return x <= y;
}

static inline f16 sitofp_i8_f16(int8_t x) {
  return (f16) x;
}

static inline f16 sitofp_i16_f16(int16_t x) {
  return (f16) x;
}

static inline f16 sitofp_i32_f16(int32_t x) {
  return (f16) x;
}

static inline f16 sitofp_i64_f16(int64_t x) {
  return (f16) x;
}

static inline f16 uitofp_i8_f16(uint8_t x) {
  return (f16) x;
}

static inline f16 uitofp_i16_f16(uint16_t x) {
  return (f16) x;
}

static inline f16 uitofp_i32_f16(uint32_t x) {
  return (f16) x;
}

static inline f16 uitofp_i64_f16(uint64_t x) {
  return (f16) x;
}

static inline int8_t fptosi_f16_i8(f16 x) {
  return (int8_t) (float) x;
}

static inline int16_t fptosi_f16_i16(f16 x) {
  return (int16_t) x;
}

static inline int32_t fptosi_f16_i32(f16 x) {
  return (int32_t) x;
}

static inline int64_t fptosi_f16_i64(f16 x) {
  return (int64_t) x;
}

static inline uint8_t fptoui_f16_i8(f16 x) {
  return (uint8_t) (float) x;
}

static inline uint16_t fptoui_f16_i16(f16 x) {
  return (uint16_t) x;
}

static inline uint32_t fptoui_f16_i32(f16 x) {
  return (uint32_t) x;
}

static inline uint64_t fptoui_f16_i64(f16 x) {
  return (uint64_t) x;
}

static inline bool ftob_f16_bool(f16 x) {
  return x != (f16)0;
}

static inline f16 btof_bool_f16(bool x) {
  return x ? 1 : 0;
}

#ifndef EMULATE_F16
static inline bool futrts_isnan16(f16 x) {
  return isnan((float)x);
}

#ifdef __OPENCL_VERSION__

static inline f16 fabs16(f16 x) {
  return fabs(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmax(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fmin(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return pow(x, y);
}

#elif ISPC
static inline f16 fabs16(f16 x) {
  return abs(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return futrts_isnan16(x) ? y : futrts_isnan16(y) ? x : max(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return futrts_isnan16(x) ? y : futrts_isnan16(y) ? x : min(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return pow(x, y);
}
#else // Assuming CUDA.

static inline f16 fabs16(f16 x) {
  return fabsf(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmaxf(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fminf(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return powf(x, y);
}
#endif

#if ISPC
static inline bool futrts_isinf16(float x) {
  return !futrts_isnan16(x) && futrts_isnan16(x - x);
}
static inline bool futrts_isfinite16(float x) {
  return !futrts_isnan16(x) && !futrts_isinf16(x);
}

#else

static inline bool futrts_isinf16(f16 x) {
  return isinf((float)x);
}
#endif

#ifdef __OPENCL_VERSION__
static inline f16 futrts_log16(f16 x) {
  return log(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return log2(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return log10(x);
}

static inline f16 futrts_log1p_16(f16 x) {
  return log1p(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return sqrt(x);
}

static inline f16 futrts_cbrt16(f16 x) {
  return cbrt(x);
}

static inline f16 futrts_exp16(f16 x) {
  return exp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return cos(x);
}

static inline f16 futrts_sin16(f16 x) {
  return sin(x);
}

static inline f16 futrts_tan16(f16 x) {
  return tan(x);
}

static inline f16 futrts_acos16(f16 x) {
  return acos(x);
}

static inline f16 futrts_asin16(f16 x) {
  return asin(x);
}

static inline f16 futrts_atan16(f16 x) {
  return atan(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return cosh(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return sinh(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return tanh(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return acosh(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return asinh(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return atanh(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return hypot(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return tgamma(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return lgamma(x);
}

static inline f16 futrts_erf16(f16 x) {
  return erf(x);
}

static inline f16 futrts_erfc16(f16 x) {
  return erfc(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmod(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return rint(x);
}

static inline f16 futrts_floor16(f16 x) {
  return floor(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return ceil(x);
}

static inline f16 futrts_nextafter16(f16 x, f16 y) {
  return nextafter(x, y);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return mix(v0, v1, t);
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return mad(a, b, c);
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fma(a, b, c);
}
#elif ISPC

static inline f16 futrts_log16(f16 x) {
  return futrts_isfinite16(x) || (futrts_isinf16(x) && x < 0) ? log(x) : x;
}

static inline f16 futrts_log2_16(f16 x) {
  return futrts_log16(x) / log(2.0f16);
}

static inline f16 futrts_log10_16(f16 x) {
  return futrts_log16(x) / log(10.0f16);
}

static inline f16 futrts_log1p_16(f16 x) {
  if(x == -1.0f16 || (futrts_isinf16(x) && x > 0.0f16)) return x / 0.0f16;
  f16 y = 1.0f16 + x;
  f16 z = y - 1.0f16;
  return log(y) - (z-x)/y;
}

static inline f16 futrts_sqrt16(f16 x) {
  return (float16)sqrt((float)x);
}

static inline f16 futrts_exp16(f16 x) {
  return exp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return (float16)cos((float)x);
}

static inline f16 futrts_sin16(f16 x) {
  return (float16)sin((float)x);
}

static inline f16 futrts_tan16(f16 x) {
  return (float16)tan((float)x);
}

static inline f16 futrts_acos16(f16 x) {
  return (float16)acos((float)x);
}

static inline f16 futrts_asin16(f16 x) {
  return (float16)asin((float)x);
}

static inline f16 futrts_atan16(f16 x) {
  return (float16)atan((float)x);
}

static inline f16 futrts_cosh16(f16 x) {
  return (exp(x)+exp(-x)) / 2.0f16;
}

static inline f16 futrts_sinh16(f16 x) {
  return (exp(x)-exp(-x)) / 2.0f16;
}

static inline f16 futrts_tanh16(f16 x) {
  return futrts_sinh16(x)/futrts_cosh16(x);
}

static inline f16 futrts_acosh16(f16 x) {
  float16 f = x+(float16)sqrt((float)(x*x-1));
  if(futrts_isfinite16(f)) return log(f);
  return f;
}

static inline f16 futrts_asinh16(f16 x) {
  float16 f = x+(float16)sqrt((float)(x*x+1));
  if(futrts_isfinite16(f)) return log(f);
  return f;
}

static inline f16 futrts_atanh16(f16 x) {
  float16 f = (1+x)/(1-x);
  if(futrts_isfinite16(f)) return log(f)/2.0f16;
  return f;
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return (float16)atan2((float)x, (float)y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return (float16)futrts_hypot32((float)x, (float)y);
}

extern "C" unmasked uniform float tgammaf(uniform float x);
static inline f16 futrts_gamma16(f16 x) {
  f16 res;
  foreach_active (i) {
    uniform f16 r = (f16)tgammaf(extract((float)x, i));
    res = insert(res, i, r);
  }
  return res;
}

extern "C" unmasked uniform float lgammaf(uniform float x);
static inline f16 futrts_lgamma16(f16 x) {
  f16 res;
  foreach_active (i) {
    uniform f16 r = (f16)lgammaf(extract((float)x, i));
    res = insert(res, i, r);
  }
  return res;
}

static inline f16 futrts_cbrt16(f16 x) {
  f16 res = (f16)futrts_cbrt32((float)x);
  return res;
}

static inline f16 futrts_erf16(f16 x) {
  f16 res = (f16)futrts_erf32((float)x);
  return res;
}

static inline f16 futrts_erfc16(f16 x) {
  f16 res = (f16)futrts_erfc32((float)x);
  return res;
}

static inline f16 fmod16(f16 x, f16 y) {
  return x - y * (float16)trunc((float) (x/y));
}

static inline f16 futrts_round16(f16 x) {
  return (float16)round((float)x);
}

static inline f16 futrts_floor16(f16 x) {
  return (float16)floor((float)x);
}

static inline f16 futrts_ceil16(f16 x) {
  return (float16)ceil((float)x);
}

static inline f16 futrts_nextafter16(f16 x, f16 y) {
  return (float16)futrts_nextafter32((float)x, (float) y);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return v0 + (v1 - v0) * t;
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

#else // Assume CUDA.

static inline f16 futrts_log16(f16 x) {
  return hlog(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return hlog2(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return hlog10(x);
}

static inline f16 futrts_log1p_16(f16 x) {
  return (f16)log1pf((float)x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return hsqrt(x);
}

static inline f16 futrts_cbrt16(f16 x) {
  return cbrtf(x);
}

static inline f16 futrts_exp16(f16 x) {
  return hexp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return hcos(x);
}

static inline f16 futrts_sin16(f16 x) {
  return hsin(x);
}

static inline f16 futrts_tan16(f16 x) {
  return tanf(x);
}

static inline f16 futrts_acos16(f16 x) {
  return acosf(x);
}

static inline f16 futrts_asin16(f16 x) {
  return asinf(x);
}

static inline f16 futrts_atan16(f16 x) {
  return atanf(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return coshf(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return sinhf(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return tanhf(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return acoshf(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return asinhf(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return atanhf(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2f(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return hypotf(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return tgammaf(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return lgammaf(x);
}

static inline f16 futrts_erf16(f16 x) {
  return erff(x);
}

static inline f16 futrts_erfc16(f16 x) {
  return erfcf(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmodf(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return rintf(x);
}

static inline f16 futrts_floor16(f16 x) {
  return hfloor(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return hceil(x);
}

static inline f16 futrts_nextafter16(f16 x, f16 y) {
  return __ushort_as_half(halfbitsnextafter(__half_as_ushort(x), __half_as_ushort(y)));
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return v0 + (v1 - v0) * t;
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fmaf(a, b, c);
}

#endif

// The CUDA __half type cannot be put in unions for some reason, so we
// use bespoke conversion functions instead.
#ifdef __CUDA_ARCH__
static inline int16_t futrts_to_bits16(f16 x) {
  return __half_as_ushort(x);
}
static inline f16 futrts_from_bits16(int16_t x) {
  return __ushort_as_half(x);
}
#elif ISPC

static inline int16_t futrts_to_bits16(f16 x) {
  varying int16_t y = *((varying int16_t * uniform)&x);
  return y;
}

static inline f16 futrts_from_bits16(int16_t x) {
  varying f16 y = *((varying f16 * uniform)&x);
  return y;
}
#else
static inline int16_t futrts_to_bits16(f16 x) {
  union {
    f16 f;
    int16_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline f16 futrts_from_bits16(int16_t x) {
  union {
    int16_t f;
    f16 t;
  } p;

  p.f = x;
  return p.t;
}
#endif

#else // No native f16 - emulate.

static inline f16 fabs16(f16 x) {
  return fabs32(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmax32(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fmin32(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return fpow32(x, y);
}

static inline bool futrts_isnan16(f16 x) {
  return futrts_isnan32(x);
}

static inline bool futrts_isinf16(f16 x) {
  return futrts_isinf32(x);
}

static inline f16 futrts_log16(f16 x) {
  return futrts_log32(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return futrts_log2_32(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return futrts_log10_32(x);
}

static inline f16 futrts_log1p_16(f16 x) {
  return futrts_log1p_32(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return futrts_sqrt32(x);
}

static inline f16 futrts_cbrt16(f16 x) {
  return futrts_cbrt32(x);
}

static inline f16 futrts_exp16(f16 x) {
  return futrts_exp32(x);
}

static inline f16 futrts_cos16(f16 x) {
  return futrts_cos32(x);
}

static inline f16 futrts_sin16(f16 x) {
  return futrts_sin32(x);
}

static inline f16 futrts_tan16(f16 x) {
  return futrts_tan32(x);
}

static inline f16 futrts_acos16(f16 x) {
  return futrts_acos32(x);
}

static inline f16 futrts_asin16(f16 x) {
  return futrts_asin32(x);
}

static inline f16 futrts_atan16(f16 x) {
  return futrts_atan32(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return futrts_cosh32(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return futrts_sinh32(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return futrts_tanh32(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return futrts_acosh32(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return futrts_asinh32(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return futrts_atanh32(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return futrts_atan2_32(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return futrts_hypot32(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return futrts_gamma32(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return futrts_lgamma32(x);
}

static inline f16 futrts_erf16(f16 x) {
  return futrts_erf32(x);
}

static inline f16 futrts_erfc16(f16 x) {
  return futrts_erfc32(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmod32(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return futrts_round32(x);
}

static inline f16 futrts_floor16(f16 x) {
  return futrts_floor32(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return futrts_ceil32(x);
}

static inline f16 futrts_nextafter16(f16 x, f16 y) {
  return halfbits2float(halfbitsnextafter(float2halfbits(x), float2halfbits(y)));
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return futrts_lerp32(v0, v1, t);
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return futrts_mad32(a, b, c);
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return futrts_fma32(a, b, c);
}

// Even when we are using an OpenCL that does not support cl_khr_fp16,
// it must still support vload_half for actually creating a
// half-precision number, which can then be efficiently converted to a
// float.  Similarly for vstore_half.
#ifdef __OPENCL_VERSION__

static inline int16_t futrts_to_bits16(f16 x) {
  int16_t y;
  // Violating strict aliasing here.
  vstore_half((float)x, 0, (half*)&y);
  return y;
}

static inline f16 futrts_from_bits16(int16_t x) {
  return (f16)vload_half(0, (half*)&x);
}

#else

static inline int16_t futrts_to_bits16(f16 x) {
  return (int16_t)float2halfbits(x);
}

static inline f16 futrts_from_bits16(int16_t x) {
  return halfbits2float((uint16_t)x);
}

static inline f16 fsignum16(f16 x) {
  return futrts_isnan16(x) ? x : (x > 0 ? 1 : 0) - (x < 0 ? 1 : 0);
}

#endif

#endif

static inline float fpconv_f16_f16(f16 x) {
  return x;
}

static inline float fpconv_f16_f32(f16 x) {
  return x;
}

static inline f16 fpconv_f32_f16(float x) {
  return (f16) x;
}

#ifdef FUTHARK_F64_ENABLED

static inline double fpconv_f16_f64(f16 x) {
  return (double) x;
}

#if ISPC
static inline f16 fpconv_f64_f16(double x) {
  return (f16) ((float)x);
}
#else
static inline f16 fpconv_f64_f16(double x) {
  return (f16) x;
}
#endif
#endif


// End of scalar_f16.h.

// Start of context_prototypes.h
//
// Prototypes for the functions in context.h, or that will be called
// from those functions, that need to be available very early.

struct futhark_context_config;
struct futhark_context;

static void set_error(struct futhark_context* ctx, char *error);

// These are called in context/config new/free functions and contain
// shared setup.  They are generated by the compiler itself.
static int init_constants(struct futhark_context*);
static int free_constants(struct futhark_context*);
static void setup_program(struct futhark_context* ctx);
static void teardown_program(struct futhark_context *ctx);

// Allocate host memory.  Must be freed with host_free().
static void host_alloc(struct futhark_context* ctx, size_t size, const char* tag, size_t* size_out, void** mem_out);
// Allocate memory allocated with host_alloc().
static void host_free(struct futhark_context* ctx, size_t size, const char* tag, void* mem);

// Functions that must be defined by the backend.
static void backend_context_config_setup(struct futhark_context_config* cfg);
static void backend_context_config_teardown(struct futhark_context_config* cfg);
static int backend_context_setup(struct futhark_context *ctx);
static void backend_context_teardown(struct futhark_context *ctx);

// End of of context_prototypes.h

struct memblock_device {
    int *references;
    cl_mem mem;
    int64_t size;
    const char *desc;
};
struct memblock {
    int *references;
    unsigned char *mem;
    int64_t size;
    const char *desc;
};
struct constants {
    int dummy;
    struct memblock_device counters_mem_26260;
    struct memblock_device mem_25847;
};
static int8_t static_array_realtype_26533[119] = {(int8_t) 70, (int8_t) 80, (int8_t) 83, (int8_t) 58, (int8_t) 32, (int8_t) 37, (int8_t) 100, (int8_t) 10, (int8_t) 86, (int8_t) 105, (int8_t) 101, (int8_t) 119, (int8_t) 58, (int8_t) 32, (int8_t) 37, (int8_t) 91, (int8_t) 104, (int8_t) 115, (int8_t) 118, (int8_t) 124, (int8_t) 111, (int8_t) 107, (int8_t) 108, (int8_t) 97, (int8_t) 98, (int8_t) 124, (int8_t) 103, (int8_t) 114, (int8_t) 97, (int8_t) 121, (int8_t) 115, (int8_t) 99, (int8_t) 97, (int8_t) 108, (int8_t) 101, (int8_t) 93, (int8_t) 10, (int8_t) 86, (int8_t) 105, (int8_t) 101, (int8_t) 119, (int8_t) 112, (int8_t) 111, (int8_t) 114, (int8_t) 116, (int8_t) 58, (int8_t) 32, (int8_t) 99, (int8_t) 101, (int8_t) 110, (int8_t) 116, (int8_t) 101, (int8_t) 114, (int8_t) 32, (int8_t) 40, (int8_t) 120, (int8_t) 61, (int8_t) 37, (int8_t) 46, (int8_t) 48, (int8_t) 51, (int8_t) 108, (int8_t) 101, (int8_t) 44, (int8_t) 32, (int8_t) 121, (int8_t) 61, (int8_t) 37, (int8_t) 46, (int8_t) 48, (int8_t) 51, (int8_t) 108, (int8_t) 101, (int8_t) 41, (int8_t) 59, (int8_t) 32, (int8_t) 122, (int8_t) 111, (int8_t) 111, (int8_t) 109, (int8_t) 32, (int8_t) 37, (int8_t) 46, (int8_t) 48, (int8_t) 51, (int8_t) 108, (int8_t) 101, (int8_t) 10, (int8_t) 65, (int8_t) 117, (int8_t) 116, (int8_t) 111, (int8_t) 32, (int8_t) 109, (int8_t) 111, (int8_t) 100, (int8_t) 101, (int8_t) 58, (int8_t) 32, (int8_t) 37, (int8_t) 91, (int8_t) 100, (int8_t) 105, (int8_t) 115, (int8_t) 97, (int8_t) 98, (int8_t) 108, (int8_t) 101, (int8_t) 100, (int8_t) 124, (int8_t) 101, (int8_t) 110, (int8_t) 97, (int8_t) 98, (int8_t) 108, (int8_t) 101, (int8_t) 100, (int8_t) 93, (int8_t) 10};
struct tuning_params {
    int64_t *builtinzhreplicate_f32zigroup_sizze_26118;
    int64_t *builtinzhreplicate_i32zigroup_sizze_26271;
    int64_t *builtinzhreplicate_i64zigroup_sizze_26138;
    int64_t *copy_group_sizze;
    int64_t *copy_num_groups;
    int64_t *renderzisegmap_group_sizze_24229;
    int64_t *renderzisegmap_group_sizze_24527;
    int64_t *renderzisegmap_group_sizze_24681;
    int64_t *renderzisegmap_group_sizze_24702;
    int64_t *renderzisegmap_group_sizze_24734;
    int64_t *renderzisegmap_group_sizze_24758;
    int64_t *renderzisegmap_group_sizze_24792;
    int64_t *renderzisegmap_group_sizze_25074;
    int64_t *renderzisegmap_group_sizze_25080;
    int64_t *renderzisegmap_group_sizze_25123;
    int64_t *renderzisegmap_group_sizze_25139;
    int64_t *renderzisegmap_group_sizze_25373;
    int64_t *renderzisegmap_group_sizze_25416;
    int64_t *renderzisegmap_group_sizze_25432;
    int64_t *renderzisegmap_group_sizze_25642;
    int64_t *renderzisegmap_group_sizze_25685;
    int64_t *renderzisegmap_group_sizze_25701;
    int64_t *renderzisegmap_num_groups_24231;
    int64_t *renderzisegmap_num_groups_24704;
    int64_t *renderzisegmap_num_groups_24794;
    int64_t *renderzisegred_group_sizze_24772;
    int64_t *renderzisegred_num_groups_24774;
    int64_t *renderzisegscan_group_sizze_25064;
    int64_t *renderzisegscan_num_groups_25066;
    int64_t *renderzisuff_outer_par_0;
};
static const int num_tuning_params = 30;
static const char *tuning_param_names[] = {"builtin#replicate_f32.group_size_26118", "builtin#replicate_i32.group_size_26271", "builtin#replicate_i64.group_size_26138", "copy_group_size", "copy_num_groups", "render.segmap_group_size_24229", "render.segmap_group_size_24527", "render.segmap_group_size_24681", "render.segmap_group_size_24702", "render.segmap_group_size_24734", "render.segmap_group_size_24758", "render.segmap_group_size_24792", "render.segmap_group_size_25074", "render.segmap_group_size_25080", "render.segmap_group_size_25123", "render.segmap_group_size_25139", "render.segmap_group_size_25373", "render.segmap_group_size_25416", "render.segmap_group_size_25432", "render.segmap_group_size_25642", "render.segmap_group_size_25685", "render.segmap_group_size_25701", "render.segmap_num_groups_24231", "render.segmap_num_groups_24704", "render.segmap_num_groups_24794", "render.segred_group_size_24772", "render.segred_num_groups_24774", "render.segscan_group_size_25064", "render.segscan_num_groups_25066", "render.suff_outer_par_0", NULL};
static const char *tuning_param_vars[] = {"builtinzhreplicate_f32zigroup_sizze_26118", "builtinzhreplicate_i32zigroup_sizze_26271", "builtinzhreplicate_i64zigroup_sizze_26138", "copy_group_sizze", "copy_num_groups", "renderzisegmap_group_sizze_24229", "renderzisegmap_group_sizze_24527", "renderzisegmap_group_sizze_24681", "renderzisegmap_group_sizze_24702", "renderzisegmap_group_sizze_24734", "renderzisegmap_group_sizze_24758", "renderzisegmap_group_sizze_24792", "renderzisegmap_group_sizze_25074", "renderzisegmap_group_sizze_25080", "renderzisegmap_group_sizze_25123", "renderzisegmap_group_sizze_25139", "renderzisegmap_group_sizze_25373", "renderzisegmap_group_sizze_25416", "renderzisegmap_group_sizze_25432", "renderzisegmap_group_sizze_25642", "renderzisegmap_group_sizze_25685", "renderzisegmap_group_sizze_25701", "renderzisegmap_num_groups_24231", "renderzisegmap_num_groups_24704", "renderzisegmap_num_groups_24794", "renderzisegred_group_sizze_24772", "renderzisegred_num_groups_24774", "renderzisegscan_group_sizze_25064", "renderzisegscan_num_groups_25066", "renderzisuff_outer_par_0", NULL};
static const char *tuning_param_classes[] = {"group_size", "group_size", "group_size", "group_size", "num_groups", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "group_size", "num_groups", "num_groups", "num_groups", "group_size", "num_groups", "group_size", "num_groups", "threshold(def, )", NULL};
static int64_t tuning_param_defaults[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static const int max_failure_args = 0;
static const int f64_required = 0;
static const char *opencl_program[] = {"\n// Clang-based OpenCL implementations need this for 'static' to work.\n#ifdef cl_clang_storage_class_specifiers\n#pragma OPENCL EXTENSION cl_clang_storage_class_specifiers : enable\n#endif\n#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n\n// Some OpenCL programs dislike empty progams, or programs with no kernels.\n// Declare a dummy kernel to ensure they remain our friends.\n__kernel void dummy_kernel(__global unsigned char *dummy, int n)\n{\n    const int thread_gid = get_global_id(0);\n    if (thread_gid >= n) return;\n}\n\n#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable\n\ntypedef char int8_t;\ntypedef short int16_t;\ntypedef int int32_t;\ntypedef long int64_t;\n\ntypedef uchar uint8_t;\ntypedef ushort uint16_t;\ntypedef uint uint32_t;\ntypedef ulong uint64_t;\n\n// NVIDIAs OpenCL does not create device-wide memory fences (see #734), so we\n// use inline assembly if we detect we are on an NVIDIA GPU.\n#ifdef cl_nv_pragma_unroll\nstatic inline void mem_fence_global() {\n  asm(\"membar.gl;\");\n}\n#else\nstatic inline void mem_fence_global() {\n  mem_fence(CLK_LOCAL_MEM_FENCE | CLK_GLOBAL_MEM_FENCE);\n}\n#endif\nstatic inline void mem_fence_local() {\n  mem_fence(CLK_LOCAL_MEM_FENCE);\n}\n// Start of half.h.\n\n// Conversion functions are from http://half.sourceforge.net/, but\n// translated to C.\n//\n// Copyright (c) 2012-2021 Christian Rau\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Softwa", "re.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#ifndef __OPENCL_VERSION__\n#define __constant\n#endif\n\n__constant static const uint16_t base_table[512] = {\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,\n  0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,\n  0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C0", "0, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,\n  0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,\n  0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC0",
                                       "0, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };\n\n__constant static const unsigned char shift_table[512] = {\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 2", "4, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };\n\n__constant static const uint32_t mantissa_table[2048] = {\n  0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,\n  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,\n  0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,\n  0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,\n  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,\n  0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA00", "00, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,\n  0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,\n  0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,\n  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,\n  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,\n  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,\n  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,\n  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,\n  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,\n  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,\n  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A00",
                                       "00, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,\n  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,\n  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,\n  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,\n  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,\n  0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,\n  0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,\n  0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,\n  0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,\n  0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,\n  0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF80", "00,\n  0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,\n  0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,\n  0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,\n  0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,\n  0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,\n  0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,\n  0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,\n  0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,\n  0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,\n  0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,\n  0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x3811", "0000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,\n  0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,\n  0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,\n  0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,\n  0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,\n  0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,\n  0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,\n  0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,\n  0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,\n  0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,\n  0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A",
                                       "4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,\n  0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,\n  0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,\n  0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,\n  0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,\n  0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,\n  0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,\n  0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,\n  0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,\n  0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,\n  0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x3863", "8000, 0x3863C000,\n  0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,\n  0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,\n  0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,\n  0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,\n  0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,\n  0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,\n  0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,\n  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,\n  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,\n  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,\n  0x38060000, 0x38062000, 0x38064000, 0x38", "066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,\n  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,\n  0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,\n  0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,\n  0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,\n  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,\n  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,\n  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,\n  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,\n  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,\n  0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x38",
                                       "1B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,\n  0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,\n  0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,\n  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,\n  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,\n  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,\n  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,\n  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,\n  0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,\n  0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,\n  0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x38", "2FA000, 0x382FC000, 0x382FE000,\n  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,\n  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,\n  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,\n  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,\n  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,\n  0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,\n  0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,\n  0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,\n  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,\n  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,\n  0x38440000, 0x38442000, 0x", "38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,\n  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,\n  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,\n  0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,\n  0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,\n  0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,\n  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,\n  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,\n  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,\n  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,\n  0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x",
                                       "3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,\n  0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,\n  0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,\n  0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,\n  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,\n  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,\n  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,\n  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,\n  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,\n  0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,\n  0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x", "386D8000, 0x386DA000, 0x386DC000, 0x386DE000,\n  0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,\n  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,\n  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,\n  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,\n  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,\n  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,\n  0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,\n  0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,\n  0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };\n__constant static const uint32_t exponent_table[64] = {\n  0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06", "000000, 0x06800000, 0x07000000, 0x07800000,\n  0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,\n  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,\n  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };\n__constant static const unsigned short offset_table[64] = {\n  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,\n  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };\n\nstatic uint16_t float2halfbits(float value) {\n  union { float x; uint32_t y; } u;\n  u.x = value;\n  uint32_t bits = u.y;\n\n  uint16_t hbits = base_table[bits>>23] + (uint16_t)((bits&0x7FFFFF)>>shift_table[bits>>23]);;\n\n  return hbits;\n}\n\nstatic float halfbits2float(uint16_t value) {\n  uint32_t bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];\n\n  union { uint32_t x; float y; } u;\n  u.x = bits;\n  return u.y;\n}\n\nstatic uint16_t halfbitsnextafter(uint16_t from, uint16_t to) {\n  int fabs = from & 0x7FFF, tabs = to & 0x7FFF;\n  if(fabs > 0x7C00 || tabs > 0x7C00) {\n    return ((from&0x7FFF)>0x7C00) ? (from|0x200) : (to|0x200);\n  }\n  if(from == to || !(fabs|tabs)) {\n    return to;\n  }\n  if(!fabs) {\n    return (to&0x8000)+1;\n  }\n  unsigned int out =\n    from +\n    (((from>>15)^(unsigned int)((from^(0x8000|(0x8000-(from>>15))))<(to^(0x8000|(0x8000-(to>>15))))))<<1)\n    - 1;\n  return out;",
                                       "\n}\n\n// End of half.h.\n// Start of scalar.h.\n\n// Implementation of the primitive scalar operations.  Very\n// repetitive.  This code is inserted directly into both CUDA and\n// OpenCL programs, as well as the CPU code, so it has some #ifdefs to\n// work everywhere.  Some operations are defined as macros because\n// this allows us to use them as constant expressions in things like\n// array sizes and static initialisers.\n\n// Some of the #ifdefs are because OpenCL uses type-generic functions\n// for some operations (e.g. sqrt), while C and CUDA sensibly use\n// distinct functions for different precisions (e.g. sqrtf() and\n// sqrt()).  This is quite annoying.  Due to C's unfortunate casting\n// rules, it is also really easy to accidentally implement\n// floating-point functions in the wrong precision, so be careful.\n\n// Double-precision definitions are only included if the preprocessor\n// macro FUTHARK_F64_ENABLED is set.\n\nstatic inline uint8_t add8(uint8_t x, uint8_t y) {\n  return x + y;\n}\n\nstatic inline uint16_t add16(uint16_t x, uint16_t y) {\n  return x + y;\n}\n\nstatic inline uint32_t add32(uint32_t x, uint32_t y) {\n  return x + y;\n}\n\nstatic inline uint64_t add64(uint64_t x, uint64_t y) {\n  return x + y;\n}\n\nstatic inline uint8_t sub8(uint8_t x, uint8_t y) {\n  return x - y;\n}\n\nstatic inline uint16_t sub16(uint16_t x, uint16_t y) {\n  return x - y;\n}\n\nstatic inline uint32_t sub32(uint32_t x, uint32_t y) {\n  return x - y;\n}\n\nstatic inline uint64_t sub64(uint64_t x, uint64_t y) {\n  return x - y;\n}\n\nstatic inline uint8_t mul8(uint8_t x, uint8_t y) {\n  return x * y;\n}\n\nstatic inline uint16_t mul16(uint16_t x, uint16_t y) {\n  return x * y;\n}\n\nstatic inline uint32_t mul32(uint32_t x, uint32_t y) {\n  return x * y;\n}\n\nstatic inline uint64_t mul64(uint64_t x, uint64_t y) {\n  return x * y;\n}\n\n#if ISPC\n\nstatic inline uint8_t udiv8(uint8_t x, uint8_t y) {\n  // This strange pattern is used to prevent the ISPC compiler from\n  // causing SIGFPEs and bogus results on divisions where inactive lan", "es\n  // have 0-valued divisors. It ensures that any inactive lane instead\n  // has a divisor of 1. https://github.com/ispc/ispc/issues/2292\n  uint8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n\n  return x / ys;\n}\n\nstatic inline uint16_t udiv16(uint16_t x, uint16_t y) {\n  uint16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x / ys;\n}\n\nstatic inline uint32_t udiv32(uint32_t x, uint32_t y) {\n  uint32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n\n  return x / ys;\n}\n\nstatic inline uint64_t udiv64(uint64_t x, uint64_t y) {\n  uint64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n\n  return x / ys;\n}\n\nstatic inline uint8_t udiv_up8(uint8_t x, uint8_t y) {\n  uint8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n\n  return (x + y - 1) / ys;\n}\n\nstatic inline uint16_t udiv_up16(uint16_t x, uint16_t y) {\n  uint16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return (x + y - 1) / ys;\n}\n\nstatic inline uint32_t udiv_up32(uint32_t x, uint32_t y) {\n  uint32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return (x + y - 1) / ys;\n}\n\nstatic inline uint64_t udiv_up64(uint64_t x, uint64_t y) {\n  uint64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return (x + y - 1) / ys;\n}\n\nstatic inline uint8_t umod8(uint8_t x, uint8_t y) {\n  uint8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x % ys;\n}\n\nstatic inline uint16_t umod16(uint16_t x, uint16_t y) {\n  uint16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n\n  return x % ys;\n}\n\nstatic inline uint32_t umod32(uint32_t x, uint32_t y) {\n  uint32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x % ys;\n}\n\nstatic inline uint64_t umod64(uint64_t x, uint64_t y) {\n  uint64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x % ys;\n}\n\nstatic inline uint8_t udiv_safe8(uint8_t x, uint8_t y) {\n  uint8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x / ys;\n}\n\nstatic inline uint16_t udiv_safe16(uint16_t x, uint16_t y) {\n  uint16_t ys = 1;\n  foreach_active(i){\n    ", "ys = y;\n  }\n  \n  return y == 0 ? 0 : x / ys;\n}\n\nstatic inline uint32_t udiv_safe32(uint32_t x, uint32_t y) {\n  uint32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x / ys;\n}\n\nstatic inline uint64_t udiv_safe64(uint64_t x, uint64_t y) {\n  uint64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x / ys;\n}\n\nstatic inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {\n  uint8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : (x + y - 1) / ys;\n}\n\nstatic inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {\n  uint16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : (x + y - 1) / ys;\n}\n\nstatic inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {\n  uint32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : (x + y - 1) / ys;\n}\n\nstatic inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {\n  uint64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : (x + y - 1) / ys;\n}\n\nstatic inline uint8_t umod_safe8(uint8_t x, uint8_t y) {\n  uint8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x % ys;\n}\n\nstatic inline uint16_t umod_safe16(uint16_t x, uint16_t y) {\n  uint16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x % ys;\n}\n\nstatic inline uint32_t umod_safe32(uint32_t x, uint32_t y) {\n  uint32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x % ys;\n}\n\nstatic inline uint64_t umod_safe64(uint64_t x, uint64_t y) {\n  uint64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x % ys;\n}\n\nstatic inline int8_t sdiv8(int8_t x, int8_t y) {\n  int8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  int8_t q = x / ys;\n  int8_t r = x % ys;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int16_t sdiv16(int16_t x, int16_t y) {\n  int16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  int16_t q = x / ys;\n  int16_t r = x % ys;\n\n  return q - ((r != 0",
                                       " && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int32_t sdiv32(int32_t x, int32_t y) {\n  int32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  int32_t q = x / ys;\n  int32_t r = x % ys;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int64_t sdiv64(int64_t x, int64_t y) {\n  int64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  int64_t q = x / ys;\n  int64_t r = x % ys;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int8_t sdiv_up8(int8_t x, int8_t y) {\n  return sdiv8(x + y - 1, y);\n}\n\nstatic inline int16_t sdiv_up16(int16_t x, int16_t y) {\n  return sdiv16(x + y - 1, y);\n}\n\nstatic inline int32_t sdiv_up32(int32_t x, int32_t y) {\n  return sdiv32(x + y - 1, y);\n}\n\nstatic inline int64_t sdiv_up64(int64_t x, int64_t y) {\n  return sdiv64(x + y - 1, y);\n}\n\nstatic inline int8_t smod8(int8_t x, int8_t y) {\n  int8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  int8_t r = x % ys;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int16_t smod16(int16_t x, int16_t y) {\n  int16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  int16_t r = x % ys;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int32_t smod32(int32_t x, int32_t y) {\n  int32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  int32_t r = x % ys;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int64_t smod64(int64_t x, int64_t y) {\n  int64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  int64_t r = x % ys;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int8_t sdiv_safe8(int8_t x, int8_t y) {\n  return y == 0 ? 0 : sdiv8(x, y);\n}\n\nstatic inline int16_t sdiv_safe16(int16_t x, int16_t y) {\n  return y == 0 ? 0 : sdiv16(x, y);\n}\n\nstatic inline int32_t sdiv_safe32(int32_t x, int32_t y) {\n  return y == 0 ? 0 : sdiv32(x, y);\n}\n\nstatic inline int64_t sdiv_safe64(int64_t x, int64_t y) {\n  return y == 0 ? 0 : sdi", "v64(x, y);\n}\n\nstatic inline int8_t sdiv_up_safe8(int8_t x, int8_t y) {\n  return sdiv_safe8(x + y - 1, y);\n}\n\nstatic inline int16_t sdiv_up_safe16(int16_t x, int16_t y) {\n  return sdiv_safe16(x + y - 1, y);\n}\n\nstatic inline int32_t sdiv_up_safe32(int32_t x, int32_t y) {\n  return sdiv_safe32(x + y - 1, y);\n}\n\nstatic inline int64_t sdiv_up_safe64(int64_t x, int64_t y) {\n  return sdiv_safe64(x + y - 1, y);\n}\n\nstatic inline int8_t smod_safe8(int8_t x, int8_t y) {\n  return y == 0 ? 0 : smod8(x, y);\n}\n\nstatic inline int16_t smod_safe16(int16_t x, int16_t y) {\n  return y == 0 ? 0 : smod16(x, y);\n}\n\nstatic inline int32_t smod_safe32(int32_t x, int32_t y) {\n  return y == 0 ? 0 : smod32(x, y);\n}\n\nstatic inline int64_t smod_safe64(int64_t x, int64_t y) {\n  return y == 0 ? 0 : smod64(x, y);\n}\n\nstatic inline int8_t squot8(int8_t x, int8_t y) {\n  int8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x / ys;\n}\n\nstatic inline int16_t squot16(int16_t x, int16_t y) {\n  int16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x / ys;\n}\n\nstatic inline int32_t squot32(int32_t x, int32_t y) {\n  int32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x / ys;\n}\n\nstatic inline int64_t squot64(int64_t x, int64_t y) {\n  int64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x / ys;\n}\n\nstatic inline int8_t srem8(int8_t x, int8_t y) {\n  int8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x % ys;\n}\n\nstatic inline int16_t srem16(int16_t x, int16_t y) {\n  int16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x % ys;\n}\n\nstatic inline int32_t srem32(int32_t x, int32_t y) {\n  int32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x % ys;\n}\n\nstatic inline int64_t srem64(int64_t x, int64_t y) {\n  int8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return x % ys;\n}\n\nstatic inline int8_t squot_safe8(int8_t x, int8_t y) {\n  int8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x / ys;\n}\n\nstatic inline int16_t ", "squot_safe16(int16_t x, int16_t y) {\n  int16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x / ys;\n}\n\nstatic inline int32_t squot_safe32(int32_t x, int32_t y) {\n  int32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x / ys;\n}\n\nstatic inline int64_t squot_safe64(int64_t x, int64_t y) {\n  int64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x / ys;\n}\n\nstatic inline int8_t srem_safe8(int8_t x, int8_t y) {\n  int8_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x % ys;\n}\n\nstatic inline int16_t srem_safe16(int16_t x, int16_t y) {\n  int16_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x % ys;\n}\n\nstatic inline int32_t srem_safe32(int32_t x, int32_t y) {\n  int32_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x % ys;\n}\n\nstatic inline int64_t srem_safe64(int64_t x, int64_t y) {\n  int64_t ys = 1;\n  foreach_active(i){\n    ys = y;\n  }\n  \n  return y == 0 ? 0 : x % ys;\n}\n\n#else\n\nstatic inline uint8_t udiv8(uint8_t x, uint8_t y) {\n  return x / y;\n}\n\nstatic inline uint16_t udiv16(uint16_t x, uint16_t y) {\n  return x / y;\n}\n\nstatic inline uint32_t udiv32(uint32_t x, uint32_t y) {\n  return x / y;\n}\n\nstatic inline uint64_t udiv64(uint64_t x, uint64_t y) {\n  return x / y;\n}\n\nstatic inline uint8_t udiv_up8(uint8_t x, uint8_t y) {\n  return (x + y - 1) / y;\n}\n\nstatic inline uint16_t udiv_up16(uint16_t x, uint16_t y) {\n  return (x + y - 1) / y;\n}\n\nstatic inline uint32_t udiv_up32(uint32_t x, uint32_t y) {\n  return (x + y - 1) / y;\n}\n\nstatic inline uint64_t udiv_up64(uint64_t x, uint64_t y) {\n  return (x + y - 1) / y;\n}\n\nstatic inline uint8_t umod8(uint8_t x, uint8_t y) {\n  return x % y;\n}\n\nstatic inline uint16_t umod16(uint16_t x, uint16_t y) {\n  return x % y;\n}\n\nstatic inline uint32_t umod32(uint32_t x, uint32_t y) {\n  return x % y;\n}\n\nstatic inline uint64_t umod64(uint64_t x, uint64_t y) {\n  return x % y;\n}\n\nstatic inline uint8_t udiv_safe8(u",
                                       "int8_t x, uint8_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline uint16_t udiv_safe16(uint16_t x, uint16_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline uint32_t udiv_safe32(uint32_t x, uint32_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline uint64_t udiv_safe64(uint64_t x, uint64_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {\n  return y == 0 ? 0 : (x + y - 1) / y;\n}\n\nstatic inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {\n  return y == 0 ? 0 : (x + y - 1) / y;\n}\n\nstatic inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {\n  return y == 0 ? 0 : (x + y - 1) / y;\n}\n\nstatic inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {\n  return y == 0 ? 0 : (x + y - 1) / y;\n}\n\nstatic inline uint8_t umod_safe8(uint8_t x, uint8_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline uint16_t umod_safe16(uint16_t x, uint16_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline uint32_t umod_safe32(uint32_t x, uint32_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline uint64_t umod_safe64(uint64_t x, uint64_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline int8_t sdiv8(int8_t x, int8_t y) {\n  int8_t q = x / y;\n  int8_t r = x % y;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int16_t sdiv16(int16_t x, int16_t y) {\n  int16_t q = x / y;\n  int16_t r = x % y;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int32_t sdiv32(int32_t x, int32_t y) {\n  int32_t q = x / y;\n  int32_t r = x % y;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int64_t sdiv64(int64_t x, int64_t y) {\n  int64_t q = x / y;\n  int64_t r = x % y;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int8_t sdiv_up8(int8_t x, int8_t y) {\n  return sdiv8(x + y - 1, y);\n}\n\nstatic inline int16_t sdiv_up16(int16_t x, int16_t y) {\n  return sdiv16(x + y - 1, y);\n}\n\nstatic inline int32_t sdiv_up32(int32_t x, int32_t y) {\n  return sdiv32(x + y - 1, y);\n}\n\nstatic inline int64", "_t sdiv_up64(int64_t x, int64_t y) {\n  return sdiv64(x + y - 1, y);\n}\n\nstatic inline int8_t smod8(int8_t x, int8_t y) {\n  int8_t r = x % y;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int16_t smod16(int16_t x, int16_t y) {\n  int16_t r = x % y;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int32_t smod32(int32_t x, int32_t y) {\n  int32_t r = x % y;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int64_t smod64(int64_t x, int64_t y) {\n  int64_t r = x % y;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int8_t sdiv_safe8(int8_t x, int8_t y) {\n  return y == 0 ? 0 : sdiv8(x, y);\n}\n\nstatic inline int16_t sdiv_safe16(int16_t x, int16_t y) {\n  return y == 0 ? 0 : sdiv16(x, y);\n}\n\nstatic inline int32_t sdiv_safe32(int32_t x, int32_t y) {\n  return y == 0 ? 0 : sdiv32(x, y);\n}\n\nstatic inline int64_t sdiv_safe64(int64_t x, int64_t y) {\n  return y == 0 ? 0 : sdiv64(x, y);\n}\n\nstatic inline int8_t sdiv_up_safe8(int8_t x, int8_t y) {\n  return sdiv_safe8(x + y - 1, y);\n}\n\nstatic inline int16_t sdiv_up_safe16(int16_t x, int16_t y) {\n  return sdiv_safe16(x + y - 1, y);\n}\n\nstatic inline int32_t sdiv_up_safe32(int32_t x, int32_t y) {\n  return sdiv_safe32(x + y - 1, y);\n}\n\nstatic inline int64_t sdiv_up_safe64(int64_t x, int64_t y) {\n  return sdiv_safe64(x + y - 1, y);\n}\n\nstatic inline int8_t smod_safe8(int8_t x, int8_t y) {\n  return y == 0 ? 0 : smod8(x, y);\n}\n\nstatic inline int16_t smod_safe16(int16_t x, int16_t y) {\n  return y == 0 ? 0 : smod16(x, y);\n}\n\nstatic inline int32_t smod_safe32(int32_t x, int32_t y) {\n  return y == 0 ? 0 : smod32(x, y);\n}\n\nstatic inline int64_t smod_safe64(int64_t x, int64_t y) {\n  return y == 0 ? 0 : smod64(x, y);\n}\n\nstatic inline int8_t squot8(int8_t x, int8_t y) {\n  return x / y;\n}\n\nstatic inline int16_t squot16(int16_t x, int16_t y) {\n  return x / y;\n}\n\nstatic inline int32_t squot32(int32", "_t x, int32_t y) {\n  return x / y;\n}\n\nstatic inline int64_t squot64(int64_t x, int64_t y) {\n  return x / y;\n}\n\nstatic inline int8_t srem8(int8_t x, int8_t y) {\n  return x % y;\n}\n\nstatic inline int16_t srem16(int16_t x, int16_t y) {\n  return x % y;\n}\n\nstatic inline int32_t srem32(int32_t x, int32_t y) {\n  return x % y;\n}\n\nstatic inline int64_t srem64(int64_t x, int64_t y) {\n  return x % y;\n}\n\nstatic inline int8_t squot_safe8(int8_t x, int8_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline int16_t squot_safe16(int16_t x, int16_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline int32_t squot_safe32(int32_t x, int32_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline int64_t squot_safe64(int64_t x, int64_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline int8_t srem_safe8(int8_t x, int8_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline int16_t srem_safe16(int16_t x, int16_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline int32_t srem_safe32(int32_t x, int32_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline int64_t srem_safe64(int64_t x, int64_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\n#endif\n\nstatic inline int8_t smin8(int8_t x, int8_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline int16_t smin16(int16_t x, int16_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline int32_t smin32(int32_t x, int32_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline int64_t smin64(int64_t x, int64_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint8_t umin8(uint8_t x, uint8_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint16_t umin16(uint16_t x, uint16_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint32_t umin32(uint32_t x, uint32_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint64_t umin64(uint64_t x, uint64_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline int8_t smax8(int8_t x, int8_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline int16_t smax16(int16_t x, int16_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline int32_t smax32(int32_t x, int32_t y) {\n  return x < y ? y : x;\n}\n\ns",
                                       "tatic inline int64_t smax64(int64_t x, int64_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline uint8_t umax8(uint8_t x, uint8_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline uint16_t umax16(uint16_t x, uint16_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline uint32_t umax32(uint32_t x, uint32_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline uint64_t umax64(uint64_t x, uint64_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline uint8_t shl8(uint8_t x, uint8_t y) {\n  return (uint8_t)(x << y);\n}\n\nstatic inline uint16_t shl16(uint16_t x, uint16_t y) {\n  return (uint16_t)(x << y);\n}\n\nstatic inline uint32_t shl32(uint32_t x, uint32_t y) {\n  return x << y;\n}\n\nstatic inline uint64_t shl64(uint64_t x, uint64_t y) {\n  return x << y;\n}\n\nstatic inline uint8_t lshr8(uint8_t x, uint8_t y) {\n  return x >> y;\n}\n\nstatic inline uint16_t lshr16(uint16_t x, uint16_t y) {\n  return x >> y;\n}\n\nstatic inline uint32_t lshr32(uint32_t x, uint32_t y) {\n  return x >> y;\n}\n\nstatic inline uint64_t lshr64(uint64_t x, uint64_t y) {\n  return x >> y;\n}\n\nstatic inline int8_t ashr8(int8_t x, int8_t y) {\n  return x >> y;\n}\n\nstatic inline int16_t ashr16(int16_t x, int16_t y) {\n  return x >> y;\n}\n\nstatic inline int32_t ashr32(int32_t x, int32_t y) {\n  return x >> y;\n}\n\nstatic inline int64_t ashr64(int64_t x, int64_t y) {\n  return x >> y;\n}\n\nstatic inline uint8_t and8(uint8_t x, uint8_t y) {\n  return x & y;\n}\n\nstatic inline uint16_t and16(uint16_t x, uint16_t y) {\n  return x & y;\n}\n\nstatic inline uint32_t and32(uint32_t x, uint32_t y) {\n  return x & y;\n}\n\nstatic inline uint64_t and64(uint64_t x, uint64_t y) {\n  return x & y;\n}\n\nstatic inline uint8_t or8(uint8_t x, uint8_t y) {\n  return x | y;\n}\n\nstatic inline uint16_t or16(uint16_t x, uint16_t y) {\n  return x | y;\n}\n\nstatic inline uint32_t or32(uint32_t x, uint32_t y) {\n  return x | y;\n}\n\nstatic inline uint64_t or64(uint64_t x, uint64_t y) {\n  return x | y;\n}\n\nstatic inline uint8_t xor8(uint8_t x, uint8_t y) {\n  return x ^ y;\n}\n\nstatic inline uint16_t xor16(uint16_", "t x, uint16_t y) {\n  return x ^ y;\n}\n\nstatic inline uint32_t xor32(uint32_t x, uint32_t y) {\n  return x ^ y;\n}\n\nstatic inline uint64_t xor64(uint64_t x, uint64_t y) {\n  return x ^ y;\n}\n\nstatic inline bool ult8(uint8_t x, uint8_t y) {\n  return x < y;\n}\n\nstatic inline bool ult16(uint16_t x, uint16_t y) {\n  return x < y;\n}\n\nstatic inline bool ult32(uint32_t x, uint32_t y) {\n  return x < y;\n}\n\nstatic inline bool ult64(uint64_t x, uint64_t y) {\n  return x < y;\n}\n\nstatic inline bool ule8(uint8_t x, uint8_t y) {\n  return x <= y;\n}\n\nstatic inline bool ule16(uint16_t x, uint16_t y) {\n  return x <= y;\n}\n\nstatic inline bool ule32(uint32_t x, uint32_t y) {\n  return x <= y;\n}\n\nstatic inline bool ule64(uint64_t x, uint64_t y) {\n  return x <= y;\n}\n\nstatic inline bool slt8(int8_t x, int8_t y) {\n  return x < y;\n}\n\nstatic inline bool slt16(int16_t x, int16_t y) {\n  return x < y;\n}\n\nstatic inline bool slt32(int32_t x, int32_t y) {\n  return x < y;\n}\n\nstatic inline bool slt64(int64_t x, int64_t y) {\n  return x < y;\n}\n\nstatic inline bool sle8(int8_t x, int8_t y) {\n  return x <= y;\n}\n\nstatic inline bool sle16(int16_t x, int16_t y) {\n  return x <= y;\n}\n\nstatic inline bool sle32(int32_t x, int32_t y) {\n  return x <= y;\n}\n\nstatic inline bool sle64(int64_t x, int64_t y) {\n  return x <= y;\n}\n\nstatic inline uint8_t pow8(uint8_t x, uint8_t y) {\n  uint8_t res = 1, rem = y;\n\n  while (rem != 0) {\n    if (rem & 1)\n      res *= x;\n    rem >>= 1;\n    x *= x;\n  }\n  return res;\n}\n\nstatic inline uint16_t pow16(uint16_t x, uint16_t y) {\n  uint16_t res = 1, rem = y;\n\n  while (rem != 0) {\n    if (rem & 1)\n      res *= x;\n    rem >>= 1;\n    x *= x;\n  }\n  return res;\n}\n\nstatic inline uint32_t pow32(uint32_t x, uint32_t y) {\n  uint32_t res = 1, rem = y;\n\n  while (rem != 0) {\n    if (rem & 1)\n      res *= x;\n    rem >>= 1;\n    x *= x;\n  }\n  return res;\n}\n\nstatic inline uint64_t pow64(uint64_t x, uint64_t y) {\n  uint64_t res = 1, rem = y;\n\n  while (rem != 0) {\n    if (rem & 1)\n      res *= x;\n    rem >>= 1;\n    ", "x *= x;\n  }\n  return res;\n}\n\nstatic inline bool itob_i8_bool(int8_t x) {\n  return x != 0;\n}\n\nstatic inline bool itob_i16_bool(int16_t x) {\n  return x != 0;\n}\n\nstatic inline bool itob_i32_bool(int32_t x) {\n  return x != 0;\n}\n\nstatic inline bool itob_i64_bool(int64_t x) {\n  return x != 0;\n}\n\nstatic inline int8_t btoi_bool_i8(bool x) {\n  return x;\n}\n\nstatic inline int16_t btoi_bool_i16(bool x) {\n  return x;\n}\n\nstatic inline int32_t btoi_bool_i32(bool x) {\n  return x;\n}\n\nstatic inline int64_t btoi_bool_i64(bool x) {\n  return x;\n}\n\n#define sext_i8_i8(x) ((int8_t) (int8_t) (x))\n#define sext_i8_i16(x) ((int16_t) (int8_t) (x))\n#define sext_i8_i32(x) ((int32_t) (int8_t) (x))\n#define sext_i8_i64(x) ((int64_t) (int8_t) (x))\n#define sext_i16_i8(x) ((int8_t) (int16_t) (x))\n#define sext_i16_i16(x) ((int16_t) (int16_t) (x))\n#define sext_i16_i32(x) ((int32_t) (int16_t) (x))\n#define sext_i16_i64(x) ((int64_t) (int16_t) (x))\n#define sext_i32_i8(x) ((int8_t) (int32_t) (x))\n#define sext_i32_i16(x) ((int16_t) (int32_t) (x))\n#define sext_i32_i32(x) ((int32_t) (int32_t) (x))\n#define sext_i32_i64(x) ((int64_t) (int32_t) (x))\n#define sext_i64_i8(x) ((int8_t) (int64_t) (x))\n#define sext_i64_i16(x) ((int16_t) (int64_t) (x))\n#define sext_i64_i32(x) ((int32_t) (int64_t) (x))\n#define sext_i64_i64(x) ((int64_t) (int64_t) (x))\n#define zext_i8_i8(x) ((int8_t) (uint8_t) (x))\n#define zext_i8_i16(x) ((int16_t) (uint8_t) (x))\n#define zext_i8_i32(x) ((int32_t) (uint8_t) (x))\n#define zext_i8_i64(x) ((int64_t) (uint8_t) (x))\n#define zext_i16_i8(x) ((int8_t) (uint16_t) (x))\n#define zext_i16_i16(x) ((int16_t) (uint16_t) (x))\n#define zext_i16_i32(x) ((int32_t) (uint16_t) (x))\n#define zext_i16_i64(x) ((int64_t) (uint16_t) (x))\n#define zext_i32_i8(x) ((int8_t) (uint32_t) (x))\n#define zext_i32_i16(x) ((int16_t) (uint32_t) (x))\n#define zext_i32_i32(x) ((int32_t) (uint32_t) (x))\n#define zext_i32_i64(x) ((int64_t) (uint32_t) (x))\n#define zext_i64_i8(x) ((int8_t) (uint64_t) (x))\n#define zext_i64_i16(x) ((int16_t) (",
                                       "uint64_t) (x))\n#define zext_i64_i32(x) ((int32_t) (uint64_t) (x))\n#define zext_i64_i64(x) ((int64_t) (uint64_t) (x))\n\nstatic int8_t abs8(int8_t x) {\n  return (int8_t)abs(x);\n}\n\nstatic int16_t abs16(int16_t x) {\n  return (int16_t)abs(x);\n}\n\nstatic int32_t abs32(int32_t x) {\n  return abs(x);\n}\n\nstatic int64_t abs64(int64_t x) {\n#if defined(__OPENCL_VERSION__) || defined(ISPC)\n  return abs(x);\n#else\n  return llabs(x);\n#endif\n}\n\n#if defined(__OPENCL_VERSION__)\nstatic int32_t futrts_popc8(int8_t x) {\n  return popcount(x);\n}\n\nstatic int32_t futrts_popc16(int16_t x) {\n  return popcount(x);\n}\n\nstatic int32_t futrts_popc32(int32_t x) {\n  return popcount(x);\n}\n\nstatic int32_t futrts_popc64(int64_t x) {\n  return popcount(x);\n}\n#elif defined(__CUDA_ARCH__)\n\nstatic int32_t futrts_popc8(int8_t x) {\n  return __popc(zext_i8_i32(x));\n}\n\nstatic int32_t futrts_popc16(int16_t x) {\n  return __popc(zext_i16_i32(x));\n}\n\nstatic int32_t futrts_popc32(int32_t x) {\n  return __popc(x);\n}\n\nstatic int32_t futrts_popc64(int64_t x) {\n  return __popcll(x);\n}\n\n#else // Not OpenCL or CUDA, but plain C.\n\nstatic int32_t futrts_popc8(uint8_t x) {\n  int c = 0;\n  for (; x; ++c) { x &= x - 1; }\n  return c;\n}\n\nstatic int32_t futrts_popc16(uint16_t x) {\n  int c = 0;\n  for (; x; ++c) { x &= x - 1; }\n  return c;\n}\n\nstatic int32_t futrts_popc32(uint32_t x) {\n  int c = 0;\n  for (; x; ++c) { x &= x - 1; }\n  return c;\n}\n\nstatic int32_t futrts_popc64(uint64_t x) {\n  int c = 0;\n  for (; x; ++c) { x &= x - 1; }\n  return c;\n}\n#endif\n\n#if defined(__OPENCL_VERSION__)\nstatic uint8_t  futrts_umul_hi8 ( uint8_t a,  uint8_t b) { return mul_hi(a, b); }\nstatic uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return mul_hi(a, b); }\nstatic uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return mul_hi(a, b); }\nstatic uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return mul_hi(a, b); }\nstatic uint8_t  futrts_smul_hi8 ( int8_t a,  int8_t b) { return mul_hi(a, b); }\nstatic uint16_t futrts_smul_hi16(int16_t a, int16_t b", ") { return mul_hi(a, b); }\nstatic uint32_t futrts_smul_hi32(int32_t a, int32_t b) { return mul_hi(a, b); }\nstatic uint64_t futrts_smul_hi64(int64_t a, int64_t b) { return mul_hi(a, b); }\n#elif defined(__CUDA_ARCH__)\nstatic  uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }\nstatic uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }\nstatic uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return __umulhi(a, b); }\nstatic uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return __umul64hi(a, b); }\nstatic  uint8_t futrts_smul_hi8 ( int8_t a, int8_t b) { return ((int16_t)a) * ((int16_t)b) >> 8; }\nstatic uint16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((int32_t)a) * ((int32_t)b) >> 16; }\nstatic uint32_t futrts_smul_hi32(int32_t a, int32_t b) { return __mulhi(a, b); }\nstatic uint64_t futrts_smul_hi64(int64_t a, int64_t b) { return __mul64hi(a, b); }\n#elif ISPC\nstatic uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }\nstatic uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }\nstatic uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }\nstatic uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) {\n  uint64_t ah = a >> 32;\n  uint64_t al = a & 0xffffffff;\n  uint64_t bh = b >> 32;\n  uint64_t bl = b & 0xffffffff;\n\n  uint64_t p1 = al * bl;\n  uint64_t p2 = al * bh;\n  uint64_t p3 = ah * bl;\n  uint64_t p4 = ah * bh;\n\n  uint64_t p1h = p1 >> 32;\n  uint64_t p2h = p2 >> 32;\n  uint64_t p3h = p3 >> 32;\n  uint64_t p2l = p2 & 0xffffffff;\n  uint64_t p3l = p3 & 0xffffffff;\n\n  uint64_t l = p1h + p2l + p3l;\n  uint64_t m = (p2 >> 32) + (p3 >> 32);\n  uint64_t h = (l >> 32) + m + p4;\n\n  return h;\n}\nstatic  int8_t futrts_smul_hi8 ( int8_t a,  int8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }\nstatic int16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((uint32_t)a", ") * ((uint32_t)b) >> 16; }\nstatic int32_t futrts_smul_hi32(int32_t a, int32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }\nstatic int64_t futrts_smul_hi64(int64_t a, int64_t b) {\n  uint64_t ah = a >> 32;\n  uint64_t al = a & 0xffffffff;\n  uint64_t bh = b >> 32;\n  uint64_t bl = b & 0xffffffff;\n\n  uint64_t p1 =  al * bl;\n  int64_t  p2 = al * bh;\n  int64_t  p3 = ah * bl;\n  uint64_t p4 =  ah * bh;\n\n  uint64_t p1h = p1 >> 32;\n  uint64_t p2h = p2 >> 32;\n  uint64_t p3h = p3 >> 32;\n  uint64_t p2l = p2 & 0xffffffff;\n  uint64_t p3l = p3 & 0xffffffff;\n\n  uint64_t l = p1h + p2l + p3l;\n  uint64_t m = (p2 >> 32) + (p3 >> 32);\n  uint64_t h = (l >> 32) + m + p4;\n\n  return h;\n}\n\n#else // Not OpenCL, ISPC, or CUDA, but plain C.\nstatic uint8_t futrts_umul_hi8(uint8_t a, uint8_t b) { return ((uint16_t)a) * ((uint16_t)b) >> 8; }\nstatic uint16_t futrts_umul_hi16(uint16_t a, uint16_t b) { return ((uint32_t)a) * ((uint32_t)b) >> 16; }\nstatic uint32_t futrts_umul_hi32(uint32_t a, uint32_t b) { return ((uint64_t)a) * ((uint64_t)b) >> 32; }\nstatic uint64_t futrts_umul_hi64(uint64_t a, uint64_t b) { return ((__uint128_t)a) * ((__uint128_t)b) >> 64; }\nstatic int8_t futrts_smul_hi8(int8_t a, int8_t b) { return ((int16_t)a) * ((int16_t)b) >> 8; }\nstatic int16_t futrts_smul_hi16(int16_t a, int16_t b) { return ((int32_t)a) * ((int32_t)b) >> 16; }\nstatic int32_t futrts_smul_hi32(int32_t a, int32_t b) { return ((int64_t)a) * ((int64_t)b) >> 32; }\nstatic int64_t futrts_smul_hi64(int64_t a, int64_t b) { return ((__int128_t)a) * ((__int128_t)b) >> 64; }\n#endif\n\n#if defined(__OPENCL_VERSION__)\nstatic  uint8_t futrts_umad_hi8 ( uint8_t a,  uint8_t b,  uint8_t c) { return mad_hi(a, b, c); }\nstatic uint16_t futrts_umad_hi16(uint16_t a, uint16_t b, uint16_t c) { return mad_hi(a, b, c); }\nstatic uint32_t futrts_umad_hi32(uint32_t a, uint32_t b, uint32_t c) { return mad_hi(a, b, c); }\nstatic uint64_t futrts_umad_hi64(uint64_t a, uint64_t b, uint64_t c) { return mad_hi(a, b, c); }\nstatic  uint8_t futrts_sm",
                                       "ad_hi8( int8_t a,  int8_t b,   int8_t c) { return mad_hi(a, b, c); }\nstatic uint16_t futrts_smad_hi16(int16_t a, int16_t b, int16_t c) { return mad_hi(a, b, c); }\nstatic uint32_t futrts_smad_hi32(int32_t a, int32_t b, int32_t c) { return mad_hi(a, b, c); }\nstatic uint64_t futrts_smad_hi64(int64_t a, int64_t b, int64_t c) { return mad_hi(a, b, c); }\n#else // Not OpenCL\n\nstatic  uint8_t futrts_umad_hi8( uint8_t a,  uint8_t b,  uint8_t c) { return futrts_umul_hi8(a, b) + c; }\nstatic uint16_t futrts_umad_hi16(uint16_t a, uint16_t b, uint16_t c) { return futrts_umul_hi16(a, b) + c; }\nstatic uint32_t futrts_umad_hi32(uint32_t a, uint32_t b, uint32_t c) { return futrts_umul_hi32(a, b) + c; }\nstatic uint64_t futrts_umad_hi64(uint64_t a, uint64_t b, uint64_t c) { return futrts_umul_hi64(a, b) + c; }\nstatic  uint8_t futrts_smad_hi8 ( int8_t a,  int8_t b,  int8_t c) { return futrts_smul_hi8(a, b) + c; }\nstatic uint16_t futrts_smad_hi16(int16_t a, int16_t b, int16_t c) { return futrts_smul_hi16(a, b) + c; }\nstatic uint32_t futrts_smad_hi32(int32_t a, int32_t b, int32_t c) { return futrts_smul_hi32(a, b) + c; }\nstatic uint64_t futrts_smad_hi64(int64_t a, int64_t b, int64_t c) { return futrts_smul_hi64(a, b) + c; }\n#endif\n\n#if defined(__OPENCL_VERSION__)\nstatic int32_t futrts_clzz8(int8_t x) {\n  return clz(x);\n}\n\nstatic int32_t futrts_clzz16(int16_t x) {\n  return clz(x);\n}\n\nstatic int32_t futrts_clzz32(int32_t x) {\n  return clz(x);\n}\n\nstatic int32_t futrts_clzz64(int64_t x) {\n  return clz(x);\n}\n\n#elif defined(__CUDA_ARCH__)\n\nstatic int32_t futrts_clzz8(int8_t x) {\n  return __clz(zext_i8_i32(x)) - 24;\n}\n\nstatic int32_t futrts_clzz16(int16_t x) {\n  return __clz(zext_i16_i32(x)) - 16;\n}\n\nstatic int32_t futrts_clzz32(int32_t x) {\n  return __clz(x);\n}\n\nstatic int32_t futrts_clzz64(int64_t x) {\n  return __clzll(x);\n}\n\n#elif ISPC\n\nstatic int32_t futrts_clzz8(int8_t x) {\n  return count_leading_zeros((int32_t)(uint8_t)x)-24;\n}\n\nstatic int32_t futrts_clzz16(int16_t x) {\n  return count_lead", "ing_zeros((int32_t)(uint16_t)x)-16;\n}\n\nstatic int32_t futrts_clzz32(int32_t x) {\n  return count_leading_zeros(x);\n}\n\nstatic int32_t futrts_clzz64(int64_t x) {\n  return count_leading_zeros(x);\n}\n\n#else // Not OpenCL, ISPC or CUDA, but plain C.\n\nstatic int32_t futrts_clzz8(int8_t x) {\n  return x == 0 ? 8 : __builtin_clz((uint32_t)zext_i8_i32(x)) - 24;\n}\n\nstatic int32_t futrts_clzz16(int16_t x) {\n  return x == 0 ? 16 : __builtin_clz((uint32_t)zext_i16_i32(x)) - 16;\n}\n\nstatic int32_t futrts_clzz32(int32_t x) {\n  return x == 0 ? 32 : __builtin_clz((uint32_t)x);\n}\n\nstatic int32_t futrts_clzz64(int64_t x) {\n  return x == 0 ? 64 : __builtin_clzll((uint64_t)x);\n}\n#endif\n\n#if defined(__OPENCL_VERSION__)\nstatic int32_t futrts_ctzz8(int8_t x) {\n  int i = 0;\n  for (; i < 8 && (x & 1) == 0; i++, x >>= 1)\n    ;\n  return i;\n}\n\nstatic int32_t futrts_ctzz16(int16_t x) {\n  int i = 0;\n  for (; i < 16 && (x & 1) == 0; i++, x >>= 1)\n    ;\n  return i;\n}\n\nstatic int32_t futrts_ctzz32(int32_t x) {\n  int i = 0;\n  for (; i < 32 && (x & 1) == 0; i++, x >>= 1)\n    ;\n  return i;\n}\n\nstatic int32_t futrts_ctzz64(int64_t x) {\n  int i = 0;\n  for (; i < 64 && (x & 1) == 0; i++, x >>= 1)\n    ;\n  return i;\n}\n\n#elif defined(__CUDA_ARCH__)\n\nstatic int32_t futrts_ctzz8(int8_t x) {\n  int y = __ffs(x);\n  return y == 0 ? 8 : y - 1;\n}\n\nstatic int32_t futrts_ctzz16(int16_t x) {\n  int y = __ffs(x);\n  return y == 0 ? 16 : y - 1;\n}\n\nstatic int32_t futrts_ctzz32(int32_t x) {\n  int y = __ffs(x);\n  return y == 0 ? 32 : y - 1;\n}\n\nstatic int32_t futrts_ctzz64(int64_t x) {\n  int y = __ffsll(x);\n  return y == 0 ? 64 : y - 1;\n}\n\n#elif ISPC\n\nstatic int32_t futrts_ctzz8(int8_t x) {\n  return x == 0 ? 8 : count_trailing_zeros((int32_t)x);\n}\n\nstatic int32_t futrts_ctzz16(int16_t x) {\n  return x == 0 ? 16 : count_trailing_zeros((int32_t)x);\n}\n\nstatic int32_t futrts_ctzz32(int32_t x) {\n  return count_trailing_zeros(x);\n}\n\nstatic int32_t futrts_ctzz64(int64_t x) {\n  return count_trailing_zeros(x);\n}\n\n#else // Not OpenCL or CUDA,", " but plain C.\n\nstatic int32_t futrts_ctzz8(int8_t x) {\n  return x == 0 ? 8 : __builtin_ctz((uint32_t)x);\n}\n\nstatic int32_t futrts_ctzz16(int16_t x) {\n  return x == 0 ? 16 : __builtin_ctz((uint32_t)x);\n}\n\nstatic int32_t futrts_ctzz32(int32_t x) {\n  return x == 0 ? 32 : __builtin_ctz((uint32_t)x);\n}\n\nstatic int32_t futrts_ctzz64(int64_t x) {\n  return x == 0 ? 64 : __builtin_ctzll((uint64_t)x);\n}\n#endif\n\nstatic inline float fdiv32(float x, float y) {\n  return x / y;\n}\n\nstatic inline float fadd32(float x, float y) {\n  return x + y;\n}\n\nstatic inline float fsub32(float x, float y) {\n  return x - y;\n}\n\nstatic inline float fmul32(float x, float y) {\n  return x * y;\n}\n\nstatic inline bool cmplt32(float x, float y) {\n  return x < y;\n}\n\nstatic inline bool cmple32(float x, float y) {\n  return x <= y;\n}\n\nstatic inline float sitofp_i8_f32(int8_t x) {\n  return (float) x;\n}\n\nstatic inline float sitofp_i16_f32(int16_t x) {\n  return (float) x;\n}\n\nstatic inline float sitofp_i32_f32(int32_t x) {\n  return (float) x;\n}\n\nstatic inline float sitofp_i64_f32(int64_t x) {\n  return (float) x;\n}\n\nstatic inline float uitofp_i8_f32(uint8_t x) {\n  return (float) x;\n}\n\nstatic inline float uitofp_i16_f32(uint16_t x) {\n  return (float) x;\n}\n\nstatic inline float uitofp_i32_f32(uint32_t x) {\n  return (float) x;\n}\n\nstatic inline float uitofp_i64_f32(uint64_t x) {\n  return (float) x;\n}\n\n#ifdef __OPENCL_VERSION__\nstatic inline float fabs32(float x) {\n  return fabs(x);\n}\n\nstatic inline float fmax32(float x, float y) {\n  return fmax(x, y);\n}\n\nstatic inline float fmin32(float x, float y) {\n  return fmin(x, y);\n}\n\nstatic inline float fpow32(float x, float y) {\n  return pow(x, y);\n}\n\n#elif ISPC\n\nstatic inline float fabs32(float x) {\n  return abs(x);\n}\n\nstatic inline float fmax32(float x, float y) {\n  return isnan(x) ? y : isnan(y) ? x : max(x, y);\n}\n\nstatic inline float fmin32(float x, float y) {\n  return isnan(x) ? y : isnan(y) ? x : min(x, y);\n}\n\nstatic inline float fpow32(float a, float b) {\n  float ret;\n  f",
                                       "oreach_active (i) {\n      uniform float r = __stdlib_powf(extract(a, i), extract(b, i));\n      ret = insert(ret, i, r);\n  }\n  return ret;\n}\n\n#else // Not OpenCL, but CUDA or plain C.\n\nstatic inline float fabs32(float x) {\n  return fabsf(x);\n}\n\nstatic inline float fmax32(float x, float y) {\n  return fmaxf(x, y);\n}\n\nstatic inline float fmin32(float x, float y) {\n  return fminf(x, y);\n}\n\nstatic inline float fpow32(float x, float y) {\n  return powf(x, y);\n}\n#endif\n\nstatic inline bool futrts_isnan32(float x) {\n  return isnan(x);\n}\n\n#if ISPC\n\nstatic inline bool futrts_isinf32(float x) {\n  return !isnan(x) && isnan(x - x);\n}\n\nstatic inline bool futrts_isfinite32(float x) {\n  return !isnan(x) && !futrts_isinf32(x);\n}\n\n#else\n\nstatic inline bool futrts_isinf32(float x) {\n  return isinf(x);\n}\n\n#endif\n\nstatic inline int8_t fptosi_f32_i8(float x) {\n  if (futrts_isnan32(x) || futrts_isinf32(x)) {\n    return 0;\n  } else {\n    return (int8_t) x;\n  }\n}\n\nstatic inline int16_t fptosi_f32_i16(float x) {\n  if (futrts_isnan32(x) || futrts_isinf32(x)) {\n    return 0;\n  } else {\n    return (int16_t) x;\n  }\n}\n\nstatic inline int32_t fptosi_f32_i32(float x) {\n  if (futrts_isnan32(x) || futrts_isinf32(x)) {\n    return 0;\n  } else {\n    return (int32_t) x;\n  }\n}\n\nstatic inline int64_t fptosi_f32_i64(float x) {\n  if (futrts_isnan32(x) || futrts_isinf32(x)) {\n    return 0;\n  } else {\n    return (int64_t) x;\n  };\n}\n\nstatic inline uint8_t fptoui_f32_i8(float x) {\n  if (futrts_isnan32(x) || futrts_isinf32(x)) {\n    return 0;\n  } else {\n    return (uint8_t) (int8_t) x;\n  }\n}\n\nstatic inline uint16_t fptoui_f32_i16(float x) {\n  if (futrts_isnan32(x) || futrts_isinf32(x)) {\n    return 0;\n  } else {\n    return (uint16_t) (int16_t) x;\n  }\n}\n\nstatic inline uint32_t fptoui_f32_i32(float x) {\n  if (futrts_isnan32(x) || futrts_isinf32(x)) {\n    return 0;\n  } else {\n    return (uint32_t) (int32_t) x;\n  }\n}\n\nstatic inline uint64_t fptoui_f32_i64(float x) {\n  if (futrts_isnan32(x) || futrts_isinf32(x)) {\n    ret", "urn 0;\n  } else {\n    return (uint64_t) (int64_t) x;\n  }\n}\n\nstatic inline bool ftob_f32_bool(float x) {\n  return x != 0;\n}\n\nstatic inline float btof_bool_f32(bool x) {\n  return x ? 1 : 0;\n}\n\n#ifdef __OPENCL_VERSION__\nstatic inline float futrts_log32(float x) {\n  return log(x);\n}\n\nstatic inline float futrts_log2_32(float x) {\n  return log2(x);\n}\n\nstatic inline float futrts_log10_32(float x) {\n  return log10(x);\n}\n\nstatic inline float futrts_log1p_32(float x) {\n  return log1p(x);\n}\n\nstatic inline float futrts_sqrt32(float x) {\n  return sqrt(x);\n}\n\nstatic inline float futrts_cbrt32(float x) {\n  return cbrt(x);\n}\n\nstatic inline float futrts_exp32(float x) {\n  return exp(x);\n}\n\nstatic inline float futrts_cos32(float x) {\n  return cos(x);\n}\n\nstatic inline float futrts_sin32(float x) {\n  return sin(x);\n}\n\nstatic inline float futrts_tan32(float x) {\n  return tan(x);\n}\n\nstatic inline float futrts_acos32(float x) {\n  return acos(x);\n}\n\nstatic inline float futrts_asin32(float x) {\n  return asin(x);\n}\n\nstatic inline float futrts_atan32(float x) {\n  return atan(x);\n}\n\nstatic inline float futrts_cosh32(float x) {\n  return cosh(x);\n}\n\nstatic inline float futrts_sinh32(float x) {\n  return sinh(x);\n}\n\nstatic inline float futrts_tanh32(float x) {\n  return tanh(x);\n}\n\nstatic inline float futrts_acosh32(float x) {\n  return acosh(x);\n}\n\nstatic inline float futrts_asinh32(float x) {\n  return asinh(x);\n}\n\nstatic inline float futrts_atanh32(float x) {\n  return atanh(x);\n}\n\nstatic inline float futrts_atan2_32(float x, float y) {\n  return atan2(x, y);\n}\n\nstatic inline float futrts_hypot32(float x, float y) {\n  return hypot(x, y);\n}\n\nstatic inline float futrts_gamma32(float x) {\n  return tgamma(x);\n}\n\nstatic inline float futrts_lgamma32(float x) {\n  return lgamma(x);\n}\n\nstatic inline float futrts_erf32(float x) {\n  return erf(x);\n}\n\nstatic inline float futrts_erfc32(float x) {\n  return erfc(x);\n}\n\nstatic inline float fmod32(float x, float y) {\n  return fmod(x, y);\n}\n\nstatic inline float futrt", "s_round32(float x) {\n  return rint(x);\n}\n\nstatic inline float futrts_floor32(float x) {\n  return floor(x);\n}\n\nstatic inline float futrts_ceil32(float x) {\n  return ceil(x);\n}\n\nstatic inline float futrts_nextafter32(float x, float y) {\n  return nextafter(x, y);\n}\n\nstatic inline float futrts_lerp32(float v0, float v1, float t) {\n  return mix(v0, v1, t);\n}\n\nstatic inline float futrts_mad32(float a, float b, float c) {\n  return mad(a, b, c);\n}\n\nstatic inline float futrts_fma32(float a, float b, float c) {\n  return fma(a, b, c);\n}\n\n#elif ISPC\n\nstatic inline float futrts_log32(float x) {\n  return futrts_isfinite32(x) || (futrts_isinf32(x) && x < 0)? log(x) : x;\n}\n\nstatic inline float futrts_log2_32(float x) {\n  return futrts_log32(x) / log(2.0f);\n}\n\nstatic inline float futrts_log10_32(float x) {\n  return futrts_log32(x) / log(10.0f);\n}\n\nstatic inline float futrts_log1p_32(float x) {\n  if(x == -1.0f || (futrts_isinf32(x) && x > 0.0f)) return x / 0.0f;\n  float y = 1.0f + x;\n  float z = y - 1.0f;\n  return log(y) - (z-x)/y;\n}\n\nstatic inline float futrts_sqrt32(float x) {\n  return sqrt(x);\n}\n\nextern \"C\" unmasked uniform float cbrtf(uniform float);\nstatic inline float futrts_cbrt32(float x) {\n  float res;\n  foreach_active (i) {\n    uniform float r = cbrtf(extract(x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nstatic inline float futrts_exp32(float x) {\n  return exp(x);\n}\n\nstatic inline float futrts_cos32(float x) {\n  return cos(x);\n}\n\nstatic inline float futrts_sin32(float x) {\n  return sin(x);\n}\n\nstatic inline float futrts_tan32(float x) {\n  return tan(x);\n}\n\nstatic inline float futrts_acos32(float x) {\n  return acos(x);\n}\n\nstatic inline float futrts_asin32(float x) {\n  return asin(x);\n}\n\nstatic inline float futrts_atan32(float x) {\n  return atan(x);\n}\n\nstatic inline float futrts_cosh32(float x) {\n  return (exp(x)+exp(-x)) / 2.0f;\n}\n\nstatic inline float futrts_sinh32(float x) {\n  return (exp(x)-exp(-x)) / 2.0f;\n}\n\nstatic inline float futrts_tanh32(float x) {\n  retur",
                                       "n futrts_sinh32(x)/futrts_cosh32(x);\n}\n\nstatic inline float futrts_acosh32(float x) {\n  float f = x+sqrt(x*x-1);\n  if(futrts_isfinite32(f)) return log(f);\n  return f;\n}\n\nstatic inline float futrts_asinh32(float x) {\n  float f = x+sqrt(x*x+1);\n  if(futrts_isfinite32(f)) return log(f);\n  return f;\n\n}\n\nstatic inline float futrts_atanh32(float x) {\n  float f = (1+x)/(1-x);\n  if(futrts_isfinite32(f)) return log(f)/2.0f;\n  return f;\n\n}\n\nstatic inline float futrts_atan2_32(float x, float y) {\n  return (x == 0.0f && y == 0.0f) ? 0.0f : atan2(x, y);\n}\n\nstatic inline float futrts_hypot32(float x, float y) {\n  if (futrts_isfinite32(x) && futrts_isfinite32(y)) {\n    x = abs(x);\n    y = abs(y);\n    float a;\n    float b;\n    if (x >= y){\n        a = x;\n        b = y;\n    } else {\n        a = y;\n        b = x;\n    }\n    if(b == 0){\n      return a;\n    }\n\n    int e;\n    float an;\n    float bn;\n    an = frexp (a, &e);\n    bn = ldexp (b, - e);\n    float cn;\n    cn = sqrt (an * an + bn * bn);\n    return ldexp (cn, e);\n  } else {\n    if (futrts_isinf32(x) || futrts_isinf32(y)) return INFINITY;\n    else return x + y;\n  }\n\n}\n\nextern \"C\" unmasked uniform float tgammaf(uniform float x);\nstatic inline float futrts_gamma32(float x) {\n  float res;\n  foreach_active (i) {\n    uniform float r = tgammaf(extract(x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nextern \"C\" unmasked uniform float lgammaf(uniform float x);\nstatic inline float futrts_lgamma32(float x) {\n  float res;\n  foreach_active (i) {\n    uniform float r = lgammaf(extract(x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nextern \"C\" unmasked uniform float erff(uniform float x);\nstatic inline float futrts_erf32(float x) {\n  float res;\n  foreach_active (i) {\n    uniform float r = erff(extract(x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nextern \"C\" unmasked uniform float erfcf(uniform float x);\nstatic inline float futrts_erfc32(float x) {\n  float res;\n  foreach_active (i) {\n    uniform float r = erfcf(extr", "act(x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nstatic inline float fmod32(float x, float y) {\n  return x - y * trunc(x/y);\n}\n\nstatic inline float futrts_round32(float x) {\n  return round(x);\n}\n\nstatic inline float futrts_floor32(float x) {\n  return floor(x);\n}\n\nstatic inline float futrts_ceil32(float x) {\n  return ceil(x);\n}\n\nextern \"C\" unmasked uniform float nextafterf(uniform float x, uniform float y);\nstatic inline float futrts_nextafter32(float x, float y) {\n  float res;\n  foreach_active (i) {\n    uniform float r = nextafterf(extract(x, i), extract(y, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nstatic inline float futrts_lerp32(float v0, float v1, float t) {\n  return v0 + (v1 - v0) * t;\n}\n\nstatic inline float futrts_mad32(float a, float b, float c) {\n  return a * b + c;\n}\n\nstatic inline float futrts_fma32(float a, float b, float c) {\n  return a * b + c;\n}\n\n#else // Not OpenCL or ISPC, but CUDA or plain C.\n\nstatic inline float futrts_log32(float x) {\n  return logf(x);\n}\n\nstatic inline float futrts_log2_32(float x) {\n  return log2f(x);\n}\n\nstatic inline float futrts_log10_32(float x) {\n  return log10f(x);\n}\n\nstatic inline float futrts_log1p_32(float x) {\n  return log1pf(x);\n}\n\nstatic inline float futrts_sqrt32(float x) {\n  return sqrtf(x);\n}\n\nstatic inline float futrts_cbrt32(float x) {\n  return cbrtf(x);\n}\n\nstatic inline float futrts_exp32(float x) {\n  return expf(x);\n}\n\nstatic inline float futrts_cos32(float x) {\n  return cosf(x);\n}\n\nstatic inline float futrts_sin32(float x) {\n  return sinf(x);\n}\n\nstatic inline float futrts_tan32(float x) {\n  return tanf(x);\n}\n\nstatic inline float futrts_acos32(float x) {\n  return acosf(x);\n}\n\nstatic inline float futrts_asin32(float x) {\n  return asinf(x);\n}\n\nstatic inline float futrts_atan32(float x) {\n  return atanf(x);\n}\n\nstatic inline float futrts_cosh32(float x) {\n  return coshf(x);\n}\n\nstatic inline float futrts_sinh32(float x) {\n  return sinhf(x);\n}\n\nstatic inline float futrts_tanh32(float x) {\n  r", "eturn tanhf(x);\n}\n\nstatic inline float futrts_acosh32(float x) {\n  return acoshf(x);\n}\n\nstatic inline float futrts_asinh32(float x) {\n  return asinhf(x);\n}\n\nstatic inline float futrts_atanh32(float x) {\n  return atanhf(x);\n}\n\nstatic inline float futrts_atan2_32(float x, float y) {\n  return atan2f(x, y);\n}\n\nstatic inline float futrts_hypot32(float x, float y) {\n  return hypotf(x, y);\n}\n\nstatic inline float futrts_gamma32(float x) {\n  return tgammaf(x);\n}\n\nstatic inline float futrts_lgamma32(float x) {\n  return lgammaf(x);\n}\n\nstatic inline float futrts_erf32(float x) {\n  return erff(x);\n}\n\nstatic inline float futrts_erfc32(float x) {\n  return erfcf(x);\n}\n\nstatic inline float fmod32(float x, float y) {\n  return fmodf(x, y);\n}\n\nstatic inline float futrts_round32(float x) {\n  return rintf(x);\n}\n\nstatic inline float futrts_floor32(float x) {\n  return floorf(x);\n}\n\nstatic inline float futrts_ceil32(float x) {\n  return ceilf(x);\n}\n\nstatic inline float futrts_nextafter32(float x, float y) {\n  return nextafterf(x, y);\n}\n\nstatic inline float futrts_lerp32(float v0, float v1, float t) {\n  return v0 + (v1 - v0) * t;\n}\n\nstatic inline float futrts_mad32(float a, float b, float c) {\n  return a * b + c;\n}\n\nstatic inline float futrts_fma32(float a, float b, float c) {\n  return fmaf(a, b, c);\n}\n#endif\n\n#if ISPC\nstatic inline int32_t futrts_to_bits32(float x) {\n  return intbits(x);\n}\n\nstatic inline float futrts_from_bits32(int32_t x) {\n  return floatbits(x);\n}\n#else\nstatic inline int32_t futrts_to_bits32(float x) {\n  union {\n    float f;\n    int32_t t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n\nstatic inline float futrts_from_bits32(int32_t x) {\n  union {\n    int32_t f;\n    float t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n#endif\n\nstatic inline float fsignum32(float x) {\n  return futrts_isnan32(x) ? x : (x > 0 ? 1 : 0) - (x < 0 ? 1 : 0);\n}\n\n#ifdef FUTHARK_F64_ENABLED\n\n#if ISPC\nstatic inline bool futrts_isinf64(float x) {\n  return !isnan(x) && isnan(x - x);\n}\n\nstatic inline bool futrts_isfinite64(fl",
                                       "oat x) {\n  return !isnan(x) && !futrts_isinf64(x);\n}\n\nstatic inline double fdiv64(double x, double y) {\n  return x / y;\n}\n\nstatic inline double fadd64(double x, double y) {\n  return x + y;\n}\n\nstatic inline double fsub64(double x, double y) {\n  return x - y;\n}\n\nstatic inline double fmul64(double x, double y) {\n  return x * y;\n}\n\nstatic inline bool cmplt64(double x, double y) {\n  return x < y;\n}\n\nstatic inline bool cmple64(double x, double y) {\n  return x <= y;\n}\n\nstatic inline double sitofp_i8_f64(int8_t x) {\n  return (double) x;\n}\n\nstatic inline double sitofp_i16_f64(int16_t x) {\n  return (double) x;\n}\n\nstatic inline double sitofp_i32_f64(int32_t x) {\n  return (double) x;\n}\n\nstatic inline double sitofp_i64_f64(int64_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i8_f64(uint8_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i16_f64(uint16_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i32_f64(uint32_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i64_f64(uint64_t x) {\n  return (double) x;\n}\n\nstatic inline double fabs64(double x) {\n  return abs(x);\n}\n\nstatic inline double fmax64(double x, double y) {\n  return isnan(x) ? y : isnan(y) ? x : max(x, y);\n}\n\nstatic inline double fmin64(double x, double y) {\n  return isnan(x) ? y : isnan(y) ? x : min(x, y);\n}\n\nstatic inline double fpow64(double a, double b) {\n  float ret;\n  foreach_active (i) {\n      uniform float r = __stdlib_powf(extract(a, i), extract(b, i));\n      ret = insert(ret, i, r);\n  }\n  return ret;\n}\n\nstatic inline double futrts_log64(double x) {\n  return futrts_isfinite64(x) || (futrts_isinf64(x) && x < 0)? log(x) : x;\n}\n\nstatic inline double futrts_log2_64(double x) {\n  return futrts_log64(x)/log(2.0d);\n}\n\nstatic inline double futrts_log10_64(double x) {\n  return futrts_log64(x)/log(10.0d);\n}\n\nstatic inline double futrts_log1p_64(double x) {\n  if(x == -1.0d || (futrts_isinf64(x) && x > 0.0d)) return x / 0.0d;\n  double y = 1.0d + x;\n  double z = y - 1.0d;\n  return log", "(y) - (z-x)/y;\n}\n\nstatic inline double futrts_sqrt64(double x) {\n  return sqrt(x);\n}\n\nextern \"C\" unmasked uniform double cbrt(uniform double);\nstatic inline double futrts_cbrt64(double x) {\n  double res;\n  foreach_active (i) {\n    uniform double r = cbrtf(extract(x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nstatic inline double futrts_exp64(double x) {\n  return exp(x);\n}\n\nstatic inline double futrts_cos64(double x) {\n  return cos(x);\n}\n\nstatic inline double futrts_sin64(double x) {\n  return sin(x);\n}\n\nstatic inline double futrts_tan64(double x) {\n  return tan(x);\n}\n\nstatic inline double futrts_acos64(double x) {\n  return acos(x);\n}\n\nstatic inline double futrts_asin64(double x) {\n  return asin(x);\n}\n\nstatic inline double futrts_atan64(double x) {\n  return atan(x);\n}\n\nstatic inline double futrts_cosh64(double x) {\n  return (exp(x)+exp(-x)) / 2.0d;\n}\n\nstatic inline double futrts_sinh64(double x) {\n  return (exp(x)-exp(-x)) / 2.0d;\n}\n\nstatic inline double futrts_tanh64(double x) {\n  return futrts_sinh64(x)/futrts_cosh64(x);\n}\n\nstatic inline double futrts_acosh64(double x) {\n  double f = x+sqrt(x*x-1.0d);\n  if(futrts_isfinite64(f)) return log(f);\n  return f;\n}\n\nstatic inline double futrts_asinh64(double x) {\n  double f = x+sqrt(x*x+1.0d);\n  if(futrts_isfinite64(f)) return log(f);\n  return f;\n}\n\nstatic inline double futrts_atanh64(double x) {\n  double f = (1.0d+x)/(1.0d-x);\n  if(futrts_isfinite64(f)) return log(f)/2.0d;\n  return f;\n\n}\n\nstatic inline double futrts_atan2_64(double x, double y) {\n  return atan2(x, y);\n}\n\nextern \"C\" unmasked uniform double hypot(uniform double x, uniform double y);\nstatic inline double futrts_hypot64(double x, double y) {\n  double res;\n  foreach_active (i) {\n    uniform double r = hypot(extract(x, i), extract(y, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nextern \"C\" unmasked uniform double tgamma(uniform double x);\nstatic inline double futrts_gamma64(double x) {\n  double res;\n  foreach_active (i) {\n    uniform double r", " = tgamma(extract(x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nextern \"C\" unmasked uniform double lgamma(uniform double x);\nstatic inline double futrts_lgamma64(double x) {\n  double res;\n  foreach_active (i) {\n    uniform double r = lgamma(extract(x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nextern \"C\" unmasked uniform double erf(uniform double x);\nstatic inline double futrts_erf64(double x) {\n  double res;\n  foreach_active (i) {\n    uniform double r = erf(extract(x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nextern \"C\" unmasked uniform double erfc(uniform double x);\nstatic inline double futrts_erfc64(double x) {\n  double res;\n  foreach_active (i) {\n    uniform double r = erfc(extract(x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nstatic inline double futrts_fma64(double a, double b, double c) {\n  return a * b + c;\n}\n\nstatic inline double futrts_round64(double x) {\n  return round(x);\n}\n\nstatic inline double futrts_ceil64(double x) {\n  return ceil(x);\n}\n\nextern \"C\" unmasked uniform double nextafter(uniform float x, uniform double y);\nstatic inline float futrts_nextafter64(double x, double y) {\n  double res;\n  foreach_active (i) {\n    uniform double r = nextafter(extract(x, i), extract(y, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nstatic inline double futrts_floor64(double x) {\n  return floor(x);\n}\n\nstatic inline bool futrts_isnan64(double x) {\n  return isnan(x);\n}\n\nstatic inline int8_t fptosi_f64_i8(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (int8_t) x;\n  }\n}\n\nstatic inline int16_t fptosi_f64_i16(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (int16_t) x;\n  }\n}\n\nstatic inline int32_t fptosi_f64_i32(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (int32_t) x;\n  }\n}\n\nstatic inline int64_t fptosi_f64_i64(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {",
                                       "\n    return 0;\n  } else {\n    return (int64_t) x;\n  }\n}\n\nstatic inline uint8_t fptoui_f64_i8(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (uint8_t) (int8_t) x;\n  }\n}\n\nstatic inline uint16_t fptoui_f64_i16(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (uint16_t) (int16_t) x;\n  }\n}\n\nstatic inline uint32_t fptoui_f64_i32(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (uint32_t) (int32_t) x;\n  }\n}\n\nstatic inline uint64_t fptoui_f64_i64(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (uint64_t) (int64_t) x;\n  }\n}\n\nstatic inline bool ftob_f64_bool(double x) {\n  return x != 0.0;\n}\n\nstatic inline double btof_bool_f64(bool x) {\n  return x ? 1.0 : 0.0;\n}\n\nstatic inline int64_t futrts_to_bits64(double x) {\n  int64_t res;\n  foreach_active (i) {\n    uniform double tmp = extract(x, i);\n    uniform int64_t r = *((uniform int64_t* uniform)&tmp);\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nstatic inline double futrts_from_bits64(int64_t x) {\n  double res;\n  foreach_active (i) {\n    uniform int64_t tmp = extract(x, i);\n    uniform double r = *((uniform double* uniform)&tmp);\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nstatic inline double fmod64(double x, double y) {\n  return x - y * trunc(x/y);\n}\n\nstatic inline double fsignum64(double x) {\n  return futrts_isnan64(x) ? x : (x > 0 ? 1.0d : 0.0d) - (x < 0 ? 1.0d : 0.0d);\n}\n\nstatic inline double futrts_lerp64(double v0, double v1, double t) {\n  return v0 + (v1 - v0) * t;\n}\n\nstatic inline double futrts_mad64(double a, double b, double c) {\n  return a * b + c;\n}\n\nstatic inline float fpconv_f32_f32(float x) {\n  return (float) x;\n}\n\nstatic inline double fpconv_f32_f64(float x) {\n  return (double) x;\n}\n\nstatic inline float fpconv_f64_f32(double x) {\n  return (float) x;\n}\n\nstatic inline double fpconv_f64_f64(double x) {\n  return (double", ") x;\n}\n\n#else\n\nstatic inline double fdiv64(double x, double y) {\n  return x / y;\n}\n\nstatic inline double fadd64(double x, double y) {\n  return x + y;\n}\n\nstatic inline double fsub64(double x, double y) {\n  return x - y;\n}\n\nstatic inline double fmul64(double x, double y) {\n  return x * y;\n}\n\nstatic inline bool cmplt64(double x, double y) {\n  return x < y;\n}\n\nstatic inline bool cmple64(double x, double y) {\n  return x <= y;\n}\n\nstatic inline double sitofp_i8_f64(int8_t x) {\n  return (double) x;\n}\n\nstatic inline double sitofp_i16_f64(int16_t x) {\n  return (double) x;\n}\n\nstatic inline double sitofp_i32_f64(int32_t x) {\n  return (double) x;\n}\n\nstatic inline double sitofp_i64_f64(int64_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i8_f64(uint8_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i16_f64(uint16_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i32_f64(uint32_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i64_f64(uint64_t x) {\n  return (double) x;\n}\n\nstatic inline double fabs64(double x) {\n  return fabs(x);\n}\n\nstatic inline double fmax64(double x, double y) {\n  return fmax(x, y);\n}\n\nstatic inline double fmin64(double x, double y) {\n  return fmin(x, y);\n}\n\nstatic inline double fpow64(double x, double y) {\n  return pow(x, y);\n}\n\nstatic inline double futrts_log64(double x) {\n  return log(x);\n}\n\nstatic inline double futrts_log2_64(double x) {\n  return log2(x);\n}\n\nstatic inline double futrts_log10_64(double x) {\n  return log10(x);\n}\n\nstatic inline double futrts_log1p_64(double x) {\n  return log1p(x);\n}\n\nstatic inline double futrts_sqrt64(double x) {\n  return sqrt(x);\n}\n\nstatic inline double futrts_cbrt64(double x) {\n  return cbrt(x);\n}\n\nstatic inline double futrts_exp64(double x) {\n  return exp(x);\n}\n\nstatic inline double futrts_cos64(double x) {\n  return cos(x);\n}\n\nstatic inline double futrts_sin64(double x) {\n  return sin(x);\n}\n\nstatic inline double futrts_tan64(double x) {\n  return tan(x);\n}\n\nstatic inline double futrts_a", "cos64(double x) {\n  return acos(x);\n}\n\nstatic inline double futrts_asin64(double x) {\n  return asin(x);\n}\n\nstatic inline double futrts_atan64(double x) {\n  return atan(x);\n}\n\nstatic inline double futrts_cosh64(double x) {\n  return cosh(x);\n}\n\nstatic inline double futrts_sinh64(double x) {\n  return sinh(x);\n}\n\nstatic inline double futrts_tanh64(double x) {\n  return tanh(x);\n}\n\nstatic inline double futrts_acosh64(double x) {\n  return acosh(x);\n}\n\nstatic inline double futrts_asinh64(double x) {\n  return asinh(x);\n}\n\nstatic inline double futrts_atanh64(double x) {\n  return atanh(x);\n}\n\nstatic inline double futrts_atan2_64(double x, double y) {\n  return atan2(x, y);\n}\n\nstatic inline double futrts_hypot64(double x, double y) {\n  return hypot(x, y);\n}\n\nstatic inline double futrts_gamma64(double x) {\n  return tgamma(x);\n}\n\nstatic inline double futrts_lgamma64(double x) {\n  return lgamma(x);\n}\n\nstatic inline double futrts_erf64(double x) {\n  return erf(x);\n}\n\nstatic inline double futrts_erfc64(double x) {\n  return erfc(x);\n}\n\nstatic inline double futrts_fma64(double a, double b, double c) {\n  return fma(a, b, c);\n}\n\nstatic inline double futrts_round64(double x) {\n  return rint(x);\n}\n\nstatic inline double futrts_ceil64(double x) {\n  return ceil(x);\n}\n\nstatic inline float futrts_nextafter64(float x, float y) {\n  return nextafter(x, y);\n}\n\nstatic inline double futrts_floor64(double x) {\n  return floor(x);\n}\n\nstatic inline bool futrts_isnan64(double x) {\n  return isnan(x);\n}\n\nstatic inline bool futrts_isinf64(double x) {\n  return isinf(x);\n}\n\nstatic inline int8_t fptosi_f64_i8(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (int8_t) x;\n  }\n}\n\nstatic inline int16_t fptosi_f64_i16(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (int16_t) x;\n  }\n}\n\nstatic inline int32_t fptosi_f64_i32(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (int32_t",
                                       ") x;\n  }\n}\n\nstatic inline int64_t fptosi_f64_i64(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (int64_t) x;\n  }\n}\n\nstatic inline uint8_t fptoui_f64_i8(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (uint8_t) (int8_t) x;\n  }\n}\n\nstatic inline uint16_t fptoui_f64_i16(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (uint16_t) (int16_t) x;\n  }\n}\n\nstatic inline uint32_t fptoui_f64_i32(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (uint32_t) (int32_t) x;\n  }\n}\n\nstatic inline uint64_t fptoui_f64_i64(double x) {\n  if (futrts_isnan64(x) || futrts_isinf64(x)) {\n    return 0;\n  } else {\n    return (uint64_t) (int64_t) x;\n  }\n}\n\nstatic inline bool ftob_f64_bool(double x) {\n  return x != 0;\n}\n\nstatic inline double btof_bool_f64(bool x) {\n  return x ? 1 : 0;\n}\n\nstatic inline int64_t futrts_to_bits64(double x) {\n  union {\n    double f;\n    int64_t t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n\nstatic inline double futrts_from_bits64(int64_t x) {\n  union {\n    int64_t f;\n    double t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n\nstatic inline double fmod64(double x, double y) {\n  return fmod(x, y);\n}\n\nstatic inline double fsignum64(double x) {\n  return futrts_isnan64(x) ? x : (x > 0) - (x < 0);\n}\n\nstatic inline double futrts_lerp64(double v0, double v1, double t) {\n#ifdef __OPENCL_VERSION__\n  return mix(v0, v1, t);\n#else\n  return v0 + (v1 - v0) * t;\n#endif\n}\n\nstatic inline double futrts_mad64(double a, double b, double c) {\n#ifdef __OPENCL_VERSION__\n  return mad(a, b, c);\n#else\n  return a * b + c;\n#endif\n}\n\nstatic inline float fpconv_f32_f32(float x) {\n  return (float) x;\n}\n\nstatic inline double fpconv_f32_f64(float x) {\n  return (double) x;\n}\n\nstatic inline float fpconv_f64_f32(double x) {\n  return (float) x;\n}\n\nstatic inline double fpconv_f64_f64(double x) {\n  return (double) x;\n}\n\n#endif\n\n#endif\n\n// End", " of scalar.h.\n// Start of scalar_f16.h.\n\n// Half-precision is emulated if needed (e.g. in straight C) with the\n// native type used if possible.  The emulation works by typedef'ing\n// 'float' to 'f16', and then implementing all operations on single\n// precision.  To cut down on duplication, we use the same code for\n// those Futhark functions that require just operators or casts.  The\n// in-memory representation for arrays will still be 16 bits even\n// under emulation, so the compiler will have to be careful when\n// generating reads or writes.\n\n#if !defined(cl_khr_fp16) && !(defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 600) && !(defined(ISPC))\n#define EMULATE_F16\n#endif\n\n#if !defined(EMULATE_F16) && defined(__OPENCL_VERSION__)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif\n\n#ifdef EMULATE_F16\n\n// Note that the half-precision storage format is still 16 bits - the\n// compiler will have to be real careful!\ntypedef float f16;\n\n#elif ISPC\ntypedef float16 f16;\n\n#else\n\n#ifdef __CUDA_ARCH__\n#include <cuda_fp16.h>\n#endif\n\ntypedef half f16;\n\n#endif\n\n// Some of these functions convert to single precision because half\n// precision versions are not available.\n\nstatic inline f16 fadd16(f16 x, f16 y) {\n  return x + y;\n}\n\nstatic inline f16 fsub16(f16 x, f16 y) {\n  return x - y;\n}\n\nstatic inline f16 fmul16(f16 x, f16 y) {\n  return x * y;\n}\n\nstatic inline bool cmplt16(f16 x, f16 y) {\n  return x < y;\n}\n\nstatic inline bool cmple16(f16 x, f16 y) {\n  return x <= y;\n}\n\nstatic inline f16 sitofp_i8_f16(int8_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 sitofp_i16_f16(int16_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 sitofp_i32_f16(int32_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 sitofp_i64_f16(int64_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 uitofp_i8_f16(uint8_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 uitofp_i16_f16(uint16_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 uitofp_i32_f16(uint32_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 uitofp_i64_f16(uint64_t x) {\n  return (f1", "6) x;\n}\n\nstatic inline int8_t fptosi_f16_i8(f16 x) {\n  return (int8_t) (float) x;\n}\n\nstatic inline int16_t fptosi_f16_i16(f16 x) {\n  return (int16_t) x;\n}\n\nstatic inline int32_t fptosi_f16_i32(f16 x) {\n  return (int32_t) x;\n}\n\nstatic inline int64_t fptosi_f16_i64(f16 x) {\n  return (int64_t) x;\n}\n\nstatic inline uint8_t fptoui_f16_i8(f16 x) {\n  return (uint8_t) (float) x;\n}\n\nstatic inline uint16_t fptoui_f16_i16(f16 x) {\n  return (uint16_t) x;\n}\n\nstatic inline uint32_t fptoui_f16_i32(f16 x) {\n  return (uint32_t) x;\n}\n\nstatic inline uint64_t fptoui_f16_i64(f16 x) {\n  return (uint64_t) x;\n}\n\nstatic inline bool ftob_f16_bool(f16 x) {\n  return x != (f16)0;\n}\n\nstatic inline f16 btof_bool_f16(bool x) {\n  return x ? 1 : 0;\n}\n\n#ifndef EMULATE_F16\nstatic inline bool futrts_isnan16(f16 x) {\n  return isnan((float)x);\n}\n\n#ifdef __OPENCL_VERSION__\n\nstatic inline f16 fabs16(f16 x) {\n  return fabs(x);\n}\n\nstatic inline f16 fmax16(f16 x, f16 y) {\n  return fmax(x, y);\n}\n\nstatic inline f16 fmin16(f16 x, f16 y) {\n  return fmin(x, y);\n}\n\nstatic inline f16 fpow16(f16 x, f16 y) {\n  return pow(x, y);\n}\n\n#elif ISPC\nstatic inline f16 fabs16(f16 x) {\n  return abs(x);\n}\n\nstatic inline f16 fmax16(f16 x, f16 y) {\n  return futrts_isnan16(x) ? y : futrts_isnan16(y) ? x : max(x, y);\n}\n\nstatic inline f16 fmin16(f16 x, f16 y) {\n  return futrts_isnan16(x) ? y : futrts_isnan16(y) ? x : min(x, y);\n}\n\nstatic inline f16 fpow16(f16 x, f16 y) {\n  return pow(x, y);\n}\n#else // Assuming CUDA.\n\nstatic inline f16 fabs16(f16 x) {\n  return fabsf(x);\n}\n\nstatic inline f16 fmax16(f16 x, f16 y) {\n  return fmaxf(x, y);\n}\n\nstatic inline f16 fmin16(f16 x, f16 y) {\n  return fminf(x, y);\n}\n\nstatic inline f16 fpow16(f16 x, f16 y) {\n  return powf(x, y);\n}\n#endif\n\n#if ISPC\nstatic inline bool futrts_isinf16(float x) {\n  return !futrts_isnan16(x) && futrts_isnan16(x - x);\n}\nstatic inline bool futrts_isfinite16(float x) {\n  return !futrts_isnan16(x) && !futrts_isinf16(x);\n}\n\n#else\n\nstatic inline bool futrts_isinf16(f16 x) {\n  retu",
                                       "rn isinf((float)x);\n}\n#endif\n\n#ifdef __OPENCL_VERSION__\nstatic inline f16 futrts_log16(f16 x) {\n  return log(x);\n}\n\nstatic inline f16 futrts_log2_16(f16 x) {\n  return log2(x);\n}\n\nstatic inline f16 futrts_log10_16(f16 x) {\n  return log10(x);\n}\n\nstatic inline f16 futrts_log1p_16(f16 x) {\n  return log1p(x);\n}\n\nstatic inline f16 futrts_sqrt16(f16 x) {\n  return sqrt(x);\n}\n\nstatic inline f16 futrts_cbrt16(f16 x) {\n  return cbrt(x);\n}\n\nstatic inline f16 futrts_exp16(f16 x) {\n  return exp(x);\n}\n\nstatic inline f16 futrts_cos16(f16 x) {\n  return cos(x);\n}\n\nstatic inline f16 futrts_sin16(f16 x) {\n  return sin(x);\n}\n\nstatic inline f16 futrts_tan16(f16 x) {\n  return tan(x);\n}\n\nstatic inline f16 futrts_acos16(f16 x) {\n  return acos(x);\n}\n\nstatic inline f16 futrts_asin16(f16 x) {\n  return asin(x);\n}\n\nstatic inline f16 futrts_atan16(f16 x) {\n  return atan(x);\n}\n\nstatic inline f16 futrts_cosh16(f16 x) {\n  return cosh(x);\n}\n\nstatic inline f16 futrts_sinh16(f16 x) {\n  return sinh(x);\n}\n\nstatic inline f16 futrts_tanh16(f16 x) {\n  return tanh(x);\n}\n\nstatic inline f16 futrts_acosh16(f16 x) {\n  return acosh(x);\n}\n\nstatic inline f16 futrts_asinh16(f16 x) {\n  return asinh(x);\n}\n\nstatic inline f16 futrts_atanh16(f16 x) {\n  return atanh(x);\n}\n\nstatic inline f16 futrts_atan2_16(f16 x, f16 y) {\n  return atan2(x, y);\n}\n\nstatic inline f16 futrts_hypot16(f16 x, f16 y) {\n  return hypot(x, y);\n}\n\nstatic inline f16 futrts_gamma16(f16 x) {\n  return tgamma(x);\n}\n\nstatic inline f16 futrts_lgamma16(f16 x) {\n  return lgamma(x);\n}\n\nstatic inline f16 futrts_erf16(f16 x) {\n  return erf(x);\n}\n\nstatic inline f16 futrts_erfc16(f16 x) {\n  return erfc(x);\n}\n\nstatic inline f16 fmod16(f16 x, f16 y) {\n  return fmod(x, y);\n}\n\nstatic inline f16 futrts_round16(f16 x) {\n  return rint(x);\n}\n\nstatic inline f16 futrts_floor16(f16 x) {\n  return floor(x);\n}\n\nstatic inline f16 futrts_ceil16(f16 x) {\n  return ceil(x);\n}\n\nstatic inline f16 futrts_nextafter16(f16 x, f16 y) {\n  return nextafter(x, y);\n}\n\nstatic inline f16 futrts_", "lerp16(f16 v0, f16 v1, f16 t) {\n  return mix(v0, v1, t);\n}\n\nstatic inline f16 futrts_mad16(f16 a, f16 b, f16 c) {\n  return mad(a, b, c);\n}\n\nstatic inline f16 futrts_fma16(f16 a, f16 b, f16 c) {\n  return fma(a, b, c);\n}\n#elif ISPC\n\nstatic inline f16 futrts_log16(f16 x) {\n  return futrts_isfinite16(x) || (futrts_isinf16(x) && x < 0) ? log(x) : x;\n}\n\nstatic inline f16 futrts_log2_16(f16 x) {\n  return futrts_log16(x) / log(2.0f16);\n}\n\nstatic inline f16 futrts_log10_16(f16 x) {\n  return futrts_log16(x) / log(10.0f16);\n}\n\nstatic inline f16 futrts_log1p_16(f16 x) {\n  if(x == -1.0f16 || (futrts_isinf16(x) && x > 0.0f16)) return x / 0.0f16;\n  f16 y = 1.0f16 + x;\n  f16 z = y - 1.0f16;\n  return log(y) - (z-x)/y;\n}\n\nstatic inline f16 futrts_sqrt16(f16 x) {\n  return (float16)sqrt((float)x);\n}\n\nstatic inline f16 futrts_exp16(f16 x) {\n  return exp(x);\n}\n\nstatic inline f16 futrts_cos16(f16 x) {\n  return (float16)cos((float)x);\n}\n\nstatic inline f16 futrts_sin16(f16 x) {\n  return (float16)sin((float)x);\n}\n\nstatic inline f16 futrts_tan16(f16 x) {\n  return (float16)tan((float)x);\n}\n\nstatic inline f16 futrts_acos16(f16 x) {\n  return (float16)acos((float)x);\n}\n\nstatic inline f16 futrts_asin16(f16 x) {\n  return (float16)asin((float)x);\n}\n\nstatic inline f16 futrts_atan16(f16 x) {\n  return (float16)atan((float)x);\n}\n\nstatic inline f16 futrts_cosh16(f16 x) {\n  return (exp(x)+exp(-x)) / 2.0f16;\n}\n\nstatic inline f16 futrts_sinh16(f16 x) {\n  return (exp(x)-exp(-x)) / 2.0f16;\n}\n\nstatic inline f16 futrts_tanh16(f16 x) {\n  return futrts_sinh16(x)/futrts_cosh16(x);\n}\n\nstatic inline f16 futrts_acosh16(f16 x) {\n  float16 f = x+(float16)sqrt((float)(x*x-1));\n  if(futrts_isfinite16(f)) return log(f);\n  return f;\n}\n\nstatic inline f16 futrts_asinh16(f16 x) {\n  float16 f = x+(float16)sqrt((float)(x*x+1));\n  if(futrts_isfinite16(f)) return log(f);\n  return f;\n}\n\nstatic inline f16 futrts_atanh16(f16 x) {\n  float16 f = (1+x)/(1-x);\n  if(futrts_isfinite16(f)) return log(f)/2.0f16;\n  return f;\n}\n\nstatic inline", " f16 futrts_atan2_16(f16 x, f16 y) {\n  return (float16)atan2((float)x, (float)y);\n}\n\nstatic inline f16 futrts_hypot16(f16 x, f16 y) {\n  return (float16)futrts_hypot32((float)x, (float)y);\n}\n\nextern \"C\" unmasked uniform float tgammaf(uniform float x);\nstatic inline f16 futrts_gamma16(f16 x) {\n  f16 res;\n  foreach_active (i) {\n    uniform f16 r = (f16)tgammaf(extract((float)x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nextern \"C\" unmasked uniform float lgammaf(uniform float x);\nstatic inline f16 futrts_lgamma16(f16 x) {\n  f16 res;\n  foreach_active (i) {\n    uniform f16 r = (f16)lgammaf(extract((float)x, i));\n    res = insert(res, i, r);\n  }\n  return res;\n}\n\nstatic inline f16 futrts_cbrt16(f16 x) {\n  f16 res = (f16)futrts_cbrt32((float)x);\n  return res;\n}\n\nstatic inline f16 futrts_erf16(f16 x) {\n  f16 res = (f16)futrts_erf32((float)x);\n  return res;\n}\n\nstatic inline f16 futrts_erfc16(f16 x) {\n  f16 res = (f16)futrts_erfc32((float)x);\n  return res;\n}\n\nstatic inline f16 fmod16(f16 x, f16 y) {\n  return x - y * (float16)trunc((float) (x/y));\n}\n\nstatic inline f16 futrts_round16(f16 x) {\n  return (float16)round((float)x);\n}\n\nstatic inline f16 futrts_floor16(f16 x) {\n  return (float16)floor((float)x);\n}\n\nstatic inline f16 futrts_ceil16(f16 x) {\n  return (float16)ceil((float)x);\n}\n\nstatic inline f16 futrts_nextafter16(f16 x, f16 y) {\n  return (float16)futrts_nextafter32((float)x, (float) y);\n}\n\nstatic inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {\n  return v0 + (v1 - v0) * t;\n}\n\nstatic inline f16 futrts_mad16(f16 a, f16 b, f16 c) {\n  return a * b + c;\n}\n\nstatic inline f16 futrts_fma16(f16 a, f16 b, f16 c) {\n  return a * b + c;\n}\n\n#else // Assume CUDA.\n\nstatic inline f16 futrts_log16(f16 x) {\n  return hlog(x);\n}\n\nstatic inline f16 futrts_log2_16(f16 x) {\n  return hlog2(x);\n}\n\nstatic inline f16 futrts_log10_16(f16 x) {\n  return hlog10(x);\n}\n\nstatic inline f16 futrts_log1p_16(f16 x) {\n  return (f16)log1pf((float)x);\n}\n\nstatic inline f16 futrts_sqrt16(f16 x) {\n  ret",
                                       "urn hsqrt(x);\n}\n\nstatic inline f16 futrts_cbrt16(f16 x) {\n  return cbrtf(x);\n}\n\nstatic inline f16 futrts_exp16(f16 x) {\n  return hexp(x);\n}\n\nstatic inline f16 futrts_cos16(f16 x) {\n  return hcos(x);\n}\n\nstatic inline f16 futrts_sin16(f16 x) {\n  return hsin(x);\n}\n\nstatic inline f16 futrts_tan16(f16 x) {\n  return tanf(x);\n}\n\nstatic inline f16 futrts_acos16(f16 x) {\n  return acosf(x);\n}\n\nstatic inline f16 futrts_asin16(f16 x) {\n  return asinf(x);\n}\n\nstatic inline f16 futrts_atan16(f16 x) {\n  return atanf(x);\n}\n\nstatic inline f16 futrts_cosh16(f16 x) {\n  return coshf(x);\n}\n\nstatic inline f16 futrts_sinh16(f16 x) {\n  return sinhf(x);\n}\n\nstatic inline f16 futrts_tanh16(f16 x) {\n  return tanhf(x);\n}\n\nstatic inline f16 futrts_acosh16(f16 x) {\n  return acoshf(x);\n}\n\nstatic inline f16 futrts_asinh16(f16 x) {\n  return asinhf(x);\n}\n\nstatic inline f16 futrts_atanh16(f16 x) {\n  return atanhf(x);\n}\n\nstatic inline f16 futrts_atan2_16(f16 x, f16 y) {\n  return atan2f(x, y);\n}\n\nstatic inline f16 futrts_hypot16(f16 x, f16 y) {\n  return hypotf(x, y);\n}\n\nstatic inline f16 futrts_gamma16(f16 x) {\n  return tgammaf(x);\n}\n\nstatic inline f16 futrts_lgamma16(f16 x) {\n  return lgammaf(x);\n}\n\nstatic inline f16 futrts_erf16(f16 x) {\n  return erff(x);\n}\n\nstatic inline f16 futrts_erfc16(f16 x) {\n  return erfcf(x);\n}\n\nstatic inline f16 fmod16(f16 x, f16 y) {\n  return fmodf(x, y);\n}\n\nstatic inline f16 futrts_round16(f16 x) {\n  return rintf(x);\n}\n\nstatic inline f16 futrts_floor16(f16 x) {\n  return hfloor(x);\n}\n\nstatic inline f16 futrts_ceil16(f16 x) {\n  return hceil(x);\n}\n\nstatic inline f16 futrts_nextafter16(f16 x, f16 y) {\n  return __ushort_as_half(halfbitsnextafter(__half_as_ushort(x), __half_as_ushort(y)));\n}\n\nstatic inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {\n  return v0 + (v1 - v0) * t;\n}\n\nstatic inline f16 futrts_mad16(f16 a, f16 b, f16 c) {\n  return a * b + c;\n}\n\nstatic inline f16 futrts_fma16(f16 a, f16 b, f16 c) {\n  return fmaf(a, b, c);\n}\n\n#endif\n\n// The CUDA __half type cannot be put ", "in unions for some reason, so we\n// use bespoke conversion functions instead.\n#ifdef __CUDA_ARCH__\nstatic inline int16_t futrts_to_bits16(f16 x) {\n  return __half_as_ushort(x);\n}\nstatic inline f16 futrts_from_bits16(int16_t x) {\n  return __ushort_as_half(x);\n}\n#elif ISPC\n\nstatic inline int16_t futrts_to_bits16(f16 x) {\n  varying int16_t y = *((varying int16_t * uniform)&x);\n  return y;\n}\n\nstatic inline f16 futrts_from_bits16(int16_t x) {\n  varying f16 y = *((varying f16 * uniform)&x);\n  return y;\n}\n#else\nstatic inline int16_t futrts_to_bits16(f16 x) {\n  union {\n    f16 f;\n    int16_t t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n\nstatic inline f16 futrts_from_bits16(int16_t x) {\n  union {\n    int16_t f;\n    f16 t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n#endif\n\n#else // No native f16 - emulate.\n\nstatic inline f16 fabs16(f16 x) {\n  return fabs32(x);\n}\n\nstatic inline f16 fmax16(f16 x, f16 y) {\n  return fmax32(x, y);\n}\n\nstatic inline f16 fmin16(f16 x, f16 y) {\n  return fmin32(x, y);\n}\n\nstatic inline f16 fpow16(f16 x, f16 y) {\n  return fpow32(x, y);\n}\n\nstatic inline bool futrts_isnan16(f16 x) {\n  return futrts_isnan32(x);\n}\n\nstatic inline bool futrts_isinf16(f16 x) {\n  return futrts_isinf32(x);\n}\n\nstatic inline f16 futrts_log16(f16 x) {\n  return futrts_log32(x);\n}\n\nstatic inline f16 futrts_log2_16(f16 x) {\n  return futrts_log2_32(x);\n}\n\nstatic inline f16 futrts_log10_16(f16 x) {\n  return futrts_log10_32(x);\n}\n\nstatic inline f16 futrts_log1p_16(f16 x) {\n  return futrts_log1p_32(x);\n}\n\nstatic inline f16 futrts_sqrt16(f16 x) {\n  return futrts_sqrt32(x);\n}\n\nstatic inline f16 futrts_cbrt16(f16 x) {\n  return futrts_cbrt32(x);\n}\n\nstatic inline f16 futrts_exp16(f16 x) {\n  return futrts_exp32(x);\n}\n\nstatic inline f16 futrts_cos16(f16 x) {\n  return futrts_cos32(x);\n}\n\nstatic inline f16 futrts_sin16(f16 x) {\n  return futrts_sin32(x);\n}\n\nstatic inline f16 futrts_tan16(f16 x) {\n  return futrts_tan32(x);\n}\n\nstatic inline f16 futrts_acos16(f16 x) {\n  return futrts_acos32(x);\n}\n\nstatic inline f16 f", "utrts_asin16(f16 x) {\n  return futrts_asin32(x);\n}\n\nstatic inline f16 futrts_atan16(f16 x) {\n  return futrts_atan32(x);\n}\n\nstatic inline f16 futrts_cosh16(f16 x) {\n  return futrts_cosh32(x);\n}\n\nstatic inline f16 futrts_sinh16(f16 x) {\n  return futrts_sinh32(x);\n}\n\nstatic inline f16 futrts_tanh16(f16 x) {\n  return futrts_tanh32(x);\n}\n\nstatic inline f16 futrts_acosh16(f16 x) {\n  return futrts_acosh32(x);\n}\n\nstatic inline f16 futrts_asinh16(f16 x) {\n  return futrts_asinh32(x);\n}\n\nstatic inline f16 futrts_atanh16(f16 x) {\n  return futrts_atanh32(x);\n}\n\nstatic inline f16 futrts_atan2_16(f16 x, f16 y) {\n  return futrts_atan2_32(x, y);\n}\n\nstatic inline f16 futrts_hypot16(f16 x, f16 y) {\n  return futrts_hypot32(x, y);\n}\n\nstatic inline f16 futrts_gamma16(f16 x) {\n  return futrts_gamma32(x);\n}\n\nstatic inline f16 futrts_lgamma16(f16 x) {\n  return futrts_lgamma32(x);\n}\n\nstatic inline f16 futrts_erf16(f16 x) {\n  return futrts_erf32(x);\n}\n\nstatic inline f16 futrts_erfc16(f16 x) {\n  return futrts_erfc32(x);\n}\n\nstatic inline f16 fmod16(f16 x, f16 y) {\n  return fmod32(x, y);\n}\n\nstatic inline f16 futrts_round16(f16 x) {\n  return futrts_round32(x);\n}\n\nstatic inline f16 futrts_floor16(f16 x) {\n  return futrts_floor32(x);\n}\n\nstatic inline f16 futrts_ceil16(f16 x) {\n  return futrts_ceil32(x);\n}\n\nstatic inline f16 futrts_nextafter16(f16 x, f16 y) {\n  return halfbits2float(halfbitsnextafter(float2halfbits(x), float2halfbits(y)));\n}\n\nstatic inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {\n  return futrts_lerp32(v0, v1, t);\n}\n\nstatic inline f16 futrts_mad16(f16 a, f16 b, f16 c) {\n  return futrts_mad32(a, b, c);\n}\n\nstatic inline f16 futrts_fma16(f16 a, f16 b, f16 c) {\n  return futrts_fma32(a, b, c);\n}\n\n// Even when we are using an OpenCL that does not support cl_khr_fp16,\n// it must still support vload_half for actually creating a\n// half-precision number, which can then be efficiently converted to a\n// float.  Similarly for vstore_half.\n#ifdef __OPENCL_VERSION__\n\nstatic inline int16_t futrt",
                                       "s_to_bits16(f16 x) {\n  int16_t y;\n  // Violating strict aliasing here.\n  vstore_half((float)x, 0, (half*)&y);\n  return y;\n}\n\nstatic inline f16 futrts_from_bits16(int16_t x) {\n  return (f16)vload_half(0, (half*)&x);\n}\n\n#else\n\nstatic inline int16_t futrts_to_bits16(f16 x) {\n  return (int16_t)float2halfbits(x);\n}\n\nstatic inline f16 futrts_from_bits16(int16_t x) {\n  return halfbits2float((uint16_t)x);\n}\n\nstatic inline f16 fsignum16(f16 x) {\n  return futrts_isnan16(x) ? x : (x > 0 ? 1 : 0) - (x < 0 ? 1 : 0);\n}\n\n#endif\n\n#endif\n\nstatic inline float fpconv_f16_f16(f16 x) {\n  return x;\n}\n\nstatic inline float fpconv_f16_f32(f16 x) {\n  return x;\n}\n\nstatic inline f16 fpconv_f32_f16(float x) {\n  return (f16) x;\n}\n\n#ifdef FUTHARK_F64_ENABLED\n\nstatic inline double fpconv_f16_f64(f16 x) {\n  return (double) x;\n}\n\n#if ISPC\nstatic inline f16 fpconv_f64_f16(double x) {\n  return (f16) ((float)x);\n}\n#else\nstatic inline f16 fpconv_f64_f16(double x) {\n  return (f16) x;\n}\n#endif\n#endif\n\n\n// End of scalar_f16.h.\n// Start of atomics.h\n\ninline int32_t atomic_xchg_i32_global(volatile __global int32_t *p, int32_t x);\ninline int32_t atomic_xchg_i32_local(volatile __local int32_t *p, int32_t x);\ninline int32_t atomic_cmpxchg_i32_global(volatile __global int32_t *p,\n                                         int32_t cmp, int32_t val);\ninline int32_t atomic_cmpxchg_i32_local(volatile __local int32_t *p,\n                                        int32_t cmp, int32_t val);\ninline int32_t atomic_add_i32_global(volatile __global int32_t *p, int32_t x);\ninline int32_t atomic_add_i32_local(volatile __local int32_t *p, int32_t x);\ninline float atomic_fadd_f32_global(volatile __global float *p, float x);\ninline float atomic_fadd_f32_local(volatile __local float *p, float x);\ninline int32_t atomic_smax_i32_global(volatile __global int32_t *p, int32_t x);\ninline int32_t atomic_smax_i32_local(volatile __local int32_t *p, int32_t x);\ninline int32_t atomic_smin_i32_global(volatile __global int32_t *p, int32_t x);\nin", "line int32_t atomic_smin_i32_local(volatile __local int32_t *p, int32_t x);\ninline uint32_t atomic_umax_i32_global(volatile __global uint32_t *p, uint32_t x);\ninline uint32_t atomic_umax_i32_local(volatile __local uint32_t *p, uint32_t x);\ninline uint32_t atomic_umin_i32_global(volatile __global uint32_t *p, uint32_t x);\ninline uint32_t atomic_umin_i32_local(volatile __local uint32_t *p, uint32_t x);\ninline int32_t atomic_and_i32_global(volatile __global int32_t *p, int32_t x);\ninline int32_t atomic_and_i32_local(volatile __local int32_t *p, int32_t x);\ninline int32_t atomic_or_i32_global(volatile __global int32_t *p, int32_t x);\ninline int32_t atomic_or_i32_local(volatile __local int32_t *p, int32_t x);\ninline int32_t atomic_xor_i32_global(volatile __global int32_t *p, int32_t x);\ninline int32_t atomic_xor_i32_local(volatile __local int32_t *p, int32_t x);\n\ninline int32_t atomic_xchg_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicExch((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\ninline int32_t atomic_xchg_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicExch((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\ninline int32_t atomic_cmpxchg_i32_global(volatile __global int32_t *p,\n                                         int32_t cmp, int32_t val) {\n#ifdef FUTHARK_CUDA\n  return atomicCAS((int32_t*)p, cmp, val);\n#else\n  return atomic_cmpxchg(p, cmp, val);\n#endif\n}\n\ninline int32_t atomic_cmpxchg_i32_local(volatile __local int32_t *p,\n                                        int32_t cmp, int32_t val) {\n#ifdef FUTHARK_CUDA\n  return atomicCAS((int32_t*)p, cmp, val);\n#else\n  return atomic_cmpxchg(p, cmp, val);\n#endif\n}\n\ninline int32_t atomic_add_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((int32_t*)p, x);\n#else\n  return atomic_add(p, x);\n#endif\n}\n\ninline int32_t atomic_add_i32_local(volatile __local int32_t *p, int32_t x) {\n#", "ifdef FUTHARK_CUDA\n  return atomicAdd((int32_t*)p, x);\n#else\n  return atomic_add(p, x);\n#endif\n}\n\ninline float atomic_fadd_f32_global(volatile __global float *p, float x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((float*)p, x);\n#else\n  union { int32_t i; float f; } old;\n  union { int32_t i; float f; } assumed;\n  old.f = *p;\n  do {\n    assumed.f = old.f;\n    old.f = old.f + x;\n    old.i = atomic_cmpxchg_i32_global((volatile __global int32_t*)p, assumed.i, old.i);\n  } while (assumed.i != old.i);\n  return old.f;\n#endif\n}\n\ninline float atomic_fadd_f32_local(volatile __local float *p, float x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((float*)p, x);\n#else\n  union { int32_t i; float f; } old;\n  union { int32_t i; float f; } assumed;\n  old.f = *p;\n  do {\n    assumed.f = old.f;\n    old.f = old.f + x;\n    old.i = atomic_cmpxchg_i32_local((volatile __local int32_t*)p, assumed.i, old.i);\n  } while (assumed.i != old.i);\n  return old.f;\n#endif\n}\n\ninline int32_t atomic_smax_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((int32_t*)p, x);\n#else\n  return atomic_max(p, x);\n#endif\n}\n\ninline int32_t atomic_smax_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((int32_t*)p, x);\n#else\n  return atomic_max(p, x);\n#endif\n}\n\ninline int32_t atomic_smin_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((int32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline int32_t atomic_smin_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((int32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline uint32_t atomic_umax_i32_global(volatile __global uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((uint32_t*)p, x);\n#else\n  return atomic_max(p, x);\n#endif\n}\n\ninline uint32_t atomic_umax_i32_local(volatile __local uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((uint32_t*)p, x);\n#else\n  return ",
                                       "atomic_max(p, x);\n#endif\n}\n\ninline uint32_t atomic_umin_i32_global(volatile __global uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((uint32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline uint32_t atomic_umin_i32_local(volatile __local uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((uint32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline int32_t atomic_and_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAnd((int32_t*)p, x);\n#else\n  return atomic_and(p, x);\n#endif\n}\n\ninline int32_t atomic_and_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAnd((int32_t*)p, x);\n#else\n  return atomic_and(p, x);\n#endif\n}\n\ninline int32_t atomic_or_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicOr((int32_t*)p, x);\n#else\n  return atomic_or(p, x);\n#endif\n}\n\ninline int32_t atomic_or_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicOr((int32_t*)p, x);\n#else\n  return atomic_or(p, x);\n#endif\n}\n\ninline int32_t atomic_xor_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicXor((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\ninline int32_t atomic_xor_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicXor((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\n// Start of 64 bit atomics\n\n#if defined(FUTHARK_CUDA) || defined(cl_khr_int64_base_atomics) && defined(cl_khr_int64_extended_atomics)\n\ninline int64_t atomic_xchg_i64_global(volatile __global int64_t *p, int64_t x);\ninline int64_t atomic_xchg_i64_local(volatile __local int64_t *p, int64_t x);\ninline int64_t atomic_cmpxchg_i64_global(volatile __global int64_t *p,\n                                         int64_t cmp, int64_t val);\ninline int64_t atomic_cmpxchg_i64_local(volatile __local int64_t *p,\n                                        int", "64_t cmp, int64_t val);\ninline int64_t atomic_add_i64_global(volatile __global int64_t *p, int64_t x);\ninline int64_t atomic_add_i64_local(volatile __local int64_t *p, int64_t x);\ninline int64_t atomic_smax_i64_global(volatile __global int64_t *p, int64_t x);\ninline int64_t atomic_smax_i64_local(volatile __local int64_t *p, int64_t x);\ninline int64_t atomic_smin_i64_global(volatile __global int64_t *p, int64_t x);\ninline int64_t atomic_smin_i64_local(volatile __local int64_t *p, int64_t x);\ninline uint64_t atomic_umax_i64_global(volatile __global uint64_t *p, uint64_t x);\ninline uint64_t atomic_umax_i64_local(volatile __local uint64_t *p, uint64_t x);\ninline uint64_t atomic_umin_i64_global(volatile __global uint64_t *p, uint64_t x);\nuint64_t atomic_umin_i64_local(volatile __local uint64_t *p, uint64_t x);\ninline int64_t atomic_and_i64_global(volatile __global int64_t *p, int64_t x);\ninline int64_t atomic_and_i64_local(volatile __local int64_t *p, int64_t x);\ninline int64_t atomic_or_i64_global(volatile __global int64_t *p, int64_t x);\ninline int64_t atomic_or_i64_local(volatile __local int64_t *p, int64_t x);\ninline int64_t atomic_xor_i64_global(volatile __global int64_t *p, int64_t x);\ninline int64_t atomic_xor_i64_local(volatile __local int64_t *p, int64_t x);\n\n#ifdef FUTHARK_F64_ENABLED\ninline double atomic_fadd_f64_global(volatile __global double *p, double x);\ninline double atomic_fadd_f64_local(volatile __local double *p, double x);\n#endif\n\ninline int64_t atomic_xchg_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicExch((uint64_t*)p, x);\n#else\n  return atom_xor(p, x);\n#endif\n}\n\ninline int64_t atomic_xchg_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicExch((uint64_t*)p, x);\n#else\n  return atom_xor(p, x);\n#endif\n}\n\ninline int64_t atomic_cmpxchg_i64_global(volatile __global int64_t *p,\n                                         int64_t cmp, int64_t val) {\n#ifdef FUTHARK_CUDA\n  return at", "omicCAS((uint64_t*)p, cmp, val);\n#else\n  return atom_cmpxchg(p, cmp, val);\n#endif\n}\n\ninline int64_t atomic_cmpxchg_i64_local(volatile __local int64_t *p,\n                                        int64_t cmp, int64_t val) {\n#ifdef FUTHARK_CUDA\n  return atomicCAS((uint64_t*)p, cmp, val);\n#else\n  return atom_cmpxchg(p, cmp, val);\n#endif\n}\n\ninline int64_t atomic_add_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((uint64_t*)p, x);\n#else\n  return atom_add(p, x);\n#endif\n}\n\ninline int64_t atomic_add_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((uint64_t*)p, x);\n#else\n  return atom_add(p, x);\n#endif\n}\n\n#ifdef FUTHARK_F64_ENABLED\n\ninline double atomic_fadd_f64_global(volatile __global double *p, double x) {\n#if defined(FUTHARK_CUDA) && __CUDA_ARCH__ >= 600\n  return atomicAdd((double*)p, x);\n#else\n  union { int64_t i; double f; } old;\n  union { int64_t i; double f; } assumed;\n  old.f = *p;\n  do {\n    assumed.f = old.f;\n    old.f = old.f + x;\n    old.i = atomic_cmpxchg_i64_global((volatile __global int64_t*)p, assumed.i, old.i);\n  } while (assumed.i != old.i);\n  return old.f;\n#endif\n}\n\ninline double atomic_fadd_f64_local(volatile __local double *p, double x) {\n#if defined(FUTHARK_CUDA) && __CUDA_ARCH__ >= 600\n  return atomicAdd((double*)p, x);\n#else\n  union { int64_t i; double f; } old;\n  union { int64_t i; double f; } assumed;\n  old.f = *p;\n  do {\n    assumed.f = old.f;\n    old.f = old.f + x;\n    old.i = atomic_cmpxchg_i64_local((volatile __local int64_t*)p, assumed.i, old.i);\n  } while (assumed.i != old.i);\n  return old.f;\n#endif\n}\n\n#endif\n\ninline int64_t atomic_smax_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((int64_t*)p, x);\n#else\n  return atom_max(p, x);\n#endif\n}\n\ninline int64_t atomic_smax_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((int64_t*)p, x);\n#else\n  return atom_max(p, x);\n#endif\n}",
                                       "\n\ninline int64_t atomic_smin_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((int64_t*)p, x);\n#else\n  return atom_min(p, x);\n#endif\n}\n\ninline int64_t atomic_smin_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((int64_t*)p, x);\n#else\n  return atom_min(p, x);\n#endif\n}\n\ninline uint64_t atomic_umax_i64_global(volatile __global uint64_t *p, uint64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((uint64_t*)p, x);\n#else\n  return atom_max(p, x);\n#endif\n}\n\ninline uint64_t atomic_umax_i64_local(volatile __local uint64_t *p, uint64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((uint64_t*)p, x);\n#else\n  return atom_max(p, x);\n#endif\n}\n\ninline uint64_t atomic_umin_i64_global(volatile __global uint64_t *p, uint64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((uint64_t*)p, x);\n#else\n  return atom_min(p, x);\n#endif\n}\n\ninline uint64_t atomic_umin_i64_local(volatile __local uint64_t *p, uint64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((uint64_t*)p, x);\n#else\n  return atom_min(p, x);\n#endif\n}\n\ninline int64_t atomic_and_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAnd((int64_t*)p, x);\n#else\n  return atom_and(p, x);\n#endif\n}\n\ninline int64_t atomic_and_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAnd((int64_t*)p, x);\n#else\n  return atom_and(p, x);\n#endif\n}\n\ninline int64_t atomic_or_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicOr((int64_t*)p, x);\n#else\n  return atom_or(p, x);\n#endif\n}\n\ninline int64_t atomic_or_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicOr((int64_t*)p, x);\n#else\n  return atom_or(p, x);\n#endif\n}\n\ninline int64_t atomic_xor_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicXor((int64_t*)p, x);\n#else\n  return atom_xor(p, x);\n#endif\n}\n\ninline int64_t atomic_xor_i64_local(volatile ", "__local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicXor((int64_t*)p, x);\n#else\n  return atom_xor(p, x);\n#endif\n}\n\n#endif // defined(FUTHARK_CUDA) || defined(cl_khr_int64_base_atomics) && defined(cl_khr_int64_extended_atomics)\n\n// End of atomics.h\n\n\n\n__kernel void builtinzhreplicate_f32zireplicate_26114(int64_t num_elems_26110, float val_26111, int64_t replicate_n_26113, int64_t virt_num_groups_26119, int64_t num_groups_26120, __global unsigned char *mem_26109)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    int32_t replicate_ltid_26115;\n    int64_t group_sizze_26117;\n    int32_t replicate_gid_26116;\n    \n    replicate_ltid_26115 = get_local_id(0);\n    group_sizze_26117 = get_local_size(0);\n    replicate_gid_26116 = get_group_id(0);\n    \n    int32_t replicate_gtid_26114 = replicate_gid_26116 * group_sizze_26117 + replicate_ltid_26115;\n    int32_t phys_group_id_26121;\n    \n    phys_group_id_26121 = get_group_id(0);\n    \n    int32_t iterations_26122 = sdiv_up32(sext_i64_i32(virt_num_groups_26119) - phys_group_id_26121, sext_i64_i32(num_groups_26120));\n    \n    for (int32_t i_26123 = 0; i_26123 < iterations_26122; i_26123++) {\n        int32_t virt_group_id_26124 = phys_group_id_26121 + i_26123 * sext_i64_i32(num_groups_26120);\n        int64_t global_tid_26125 = sext_i32_i64(virt_group_id_26124) * sext_i32_i64(group_sizze_26117) + sext_i32_i64(replicate_ltid_26115);\n        int64_t slice_26127 = num_elems_26110;\n        int64_t rep_i_26126 = global_tid_26125;\n        int64_t remnant_26128 = global_tid_26125 - rep_i_26126;\n        \n        if (slt64(global_tid_26125, replicate_n_26113)) {\n            ((__global float *) mem_26109)[rep_i_26126] = val_26111;\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n}\n__kernel void builtinzhreplicate_i32zireplicate_26267(int64_t num_elems_26263, int32_t val_26264, int64_t replicate_n_26266, int64_t virt_num_groups_2", "6272, int64_t num_groups_26273, __global unsigned char *mem_26262)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    int32_t replicate_ltid_26268;\n    int64_t group_sizze_26270;\n    int32_t replicate_gid_26269;\n    \n    replicate_ltid_26268 = get_local_id(0);\n    group_sizze_26270 = get_local_size(0);\n    replicate_gid_26269 = get_group_id(0);\n    \n    int32_t replicate_gtid_26267 = replicate_gid_26269 * group_sizze_26270 + replicate_ltid_26268;\n    int32_t phys_group_id_26274;\n    \n    phys_group_id_26274 = get_group_id(0);\n    \n    int32_t iterations_26275 = sdiv_up32(sext_i64_i32(virt_num_groups_26272) - phys_group_id_26274, sext_i64_i32(num_groups_26273));\n    \n    for (int32_t i_26276 = 0; i_26276 < iterations_26275; i_26276++) {\n        int32_t virt_group_id_26277 = phys_group_id_26274 + i_26276 * sext_i64_i32(num_groups_26273);\n        int64_t global_tid_26278 = sext_i32_i64(virt_group_id_26277) * sext_i32_i64(group_sizze_26270) + sext_i32_i64(replicate_ltid_26268);\n        int64_t slice_26280 = num_elems_26263;\n        int64_t rep_i_26279 = global_tid_26278;\n        int64_t remnant_26281 = global_tid_26278 - rep_i_26279;\n        \n        if (slt64(global_tid_26278, replicate_n_26266)) {\n            ((__global int32_t *) mem_26262)[rep_i_26279] = val_26264;\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n}\n__kernel void builtinzhreplicate_i64zireplicate_26134(int64_t num_elems_26130, int64_t val_26131, int64_t replicate_n_26133, int64_t virt_num_groups_26139, int64_t num_groups_26140, __global unsigned char *mem_26129)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    int32_t replicate_ltid_26135;\n    int64_t group_sizze_26137;\n    int32_t replicate_gid_26136;\n    \n    replicate_ltid_26135 = get_local_id(0);\n    group_sizze_26137 = get_local_size(0);\n    replicate_gid_26136 = get_group_id(0);\n    \n    int32_t rep",
                                       "licate_gtid_26134 = replicate_gid_26136 * group_sizze_26137 + replicate_ltid_26135;\n    int32_t phys_group_id_26141;\n    \n    phys_group_id_26141 = get_group_id(0);\n    \n    int32_t iterations_26142 = sdiv_up32(sext_i64_i32(virt_num_groups_26139) - phys_group_id_26141, sext_i64_i32(num_groups_26140));\n    \n    for (int32_t i_26143 = 0; i_26143 < iterations_26142; i_26143++) {\n        int32_t virt_group_id_26144 = phys_group_id_26141 + i_26143 * sext_i64_i32(num_groups_26140);\n        int64_t global_tid_26145 = sext_i32_i64(virt_group_id_26144) * sext_i32_i64(group_sizze_26137) + sext_i32_i64(replicate_ltid_26135);\n        int64_t slice_26147 = num_elems_26130;\n        int64_t rep_i_26146 = global_tid_26145;\n        int64_t remnant_26148 = global_tid_26145 - rep_i_26146;\n        \n        if (slt64(global_tid_26145, replicate_n_26133)) {\n            ((__global int64_t *) mem_26129)[rep_i_26146] = val_26131;\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n}\n__kernel void copy_1d_i8(int64_t dest_offset_1, int64_t dest_stride_2, int64_t dest_shape_3, int64_t src_offset_5, int64_t src_stride_6, int64_t src_shape_7, int64_t num_groups_9, __global unsigned char *destmem_0, __global unsigned char *srcmem_4)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    int64_t group_id_1000;\n    int64_t local_id_1001;\n    int64_t local_sizze_1002;\n    int64_t global_id_1003;\n    \n    local_id_1001 = get_local_id(0);\n    local_sizze_1002 = get_local_size(0);\n    group_id_1000 = get_group_id(0);\n    for (int64_t group_iter_1004 = 0; group_iter_1004 < sdiv_up64(dest_shape_3, local_sizze_1002 * num_groups_9); group_iter_1004++) {\n        global_id_1003 = (group_id_1000 + group_iter_1004 * num_groups_9) * local_sizze_1002 + local_id_1001;\n        \n        int64_t i_1005 = global_id_1003;\n        \n        if (slt64(i_1005, dest_shape_3)) {\n            int8_t element_1006 = ((__global int8_t *", ") srcmem_4)[src_offset_5 + i_1005 * src_stride_6];\n            \n            ((__global int8_t *) destmem_0)[dest_offset_1 + i_1005 * dest_stride_2] = element_1006;\n        }\n    }\n    \n  error_0:\n    return;\n}\n__kernel void copy_2d_f32(int64_t dest_offset_1, int64_t dest_stride_2, int64_t dest_shape_3, int64_t dest_stride_4, int64_t dest_shape_5, int64_t src_offset_7, int64_t src_stride_8, int64_t src_shape_9, int64_t src_stride_10, int64_t src_shape_11, int64_t num_groups_13, __global unsigned char *destmem_0, __global unsigned char *srcmem_6)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    int64_t group_id_1000;\n    int64_t local_id_1001;\n    int64_t local_sizze_1002;\n    int64_t global_id_1003;\n    \n    local_id_1001 = get_local_id(0);\n    local_sizze_1002 = get_local_size(0);\n    group_id_1000 = get_group_id(0);\n    for (int64_t group_iter_1004 = 0; group_iter_1004 < sdiv_up64(dest_shape_3 * dest_shape_5, local_sizze_1002 * num_groups_13); group_iter_1004++) {\n        global_id_1003 = (group_id_1000 + group_iter_1004 * num_groups_13) * local_sizze_1002 + local_id_1001;\n        \n        int64_t i_1005;\n        int64_t i_1006;\n        \n        i_1005 = squot64(global_id_1003, dest_shape_5);\n        i_1006 = global_id_1003 - squot64(global_id_1003, dest_shape_5) * dest_shape_5;\n        if (slt64(i_1005, dest_shape_3) && slt64(i_1006, dest_shape_5)) {\n            float element_1007 = ((__global float *) srcmem_6)[src_offset_7 + (i_1005 * src_stride_8 + i_1006 * src_stride_10)];\n            \n            ((__global float *) destmem_0)[dest_offset_1 + (i_1005 * dest_stride_2 + i_1006 * dest_stride_4)] = element_1007;\n        }\n    }\n    \n  error_0:\n    return;\n}\n__kernel void copy_2d_i64(int64_t dest_offset_1, int64_t dest_stride_2, int64_t dest_shape_3, int64_t dest_stride_4, int64_t dest_shape_5, int64_t src_offset_7, int64_t src_stride_8, int64_t src_shape_9, int64_t src_stride_10, int64_t src_shape_11, int64_t num_gro", "ups_13, __global unsigned char *destmem_0, __global unsigned char *srcmem_6)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    int64_t group_id_1000;\n    int64_t local_id_1001;\n    int64_t local_sizze_1002;\n    int64_t global_id_1003;\n    \n    local_id_1001 = get_local_id(0);\n    local_sizze_1002 = get_local_size(0);\n    group_id_1000 = get_group_id(0);\n    for (int64_t group_iter_1004 = 0; group_iter_1004 < sdiv_up64(dest_shape_3 * dest_shape_5, local_sizze_1002 * num_groups_13); group_iter_1004++) {\n        global_id_1003 = (group_id_1000 + group_iter_1004 * num_groups_13) * local_sizze_1002 + local_id_1001;\n        \n        int64_t i_1005;\n        int64_t i_1006;\n        \n        i_1005 = squot64(global_id_1003, dest_shape_5);\n        i_1006 = global_id_1003 - squot64(global_id_1003, dest_shape_5) * dest_shape_5;\n        if (slt64(i_1005, dest_shape_3) && slt64(i_1006, dest_shape_5)) {\n            int64_t element_1007 = ((__global int64_t *) srcmem_6)[src_offset_7 + (i_1005 * src_stride_8 + i_1006 * src_stride_10)];\n            \n            ((__global int64_t *) destmem_0)[dest_offset_1 + (i_1005 * dest_stride_2 + i_1006 * dest_stride_4)] = element_1007;\n        }\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(32, 4, 1)))\n__kernel void gpu_map_transpose_f32_i32(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get",
                                       "_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int32_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int32_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int32_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int32_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int32_t our_array_offset_30 = get_group_id_2_43 * sext_i64_i32(x_elems_5) * sext_i64_i32(y_elems_6);\n    int32_t odata_offset_33 = squot32(sext_i64_i32(destoffset_1), 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(sext_i64_i32(srcoffset_3), 4) + our_array_offset_30;\n    int32_t x_index_31 = get_global_id_0_37;\n    int32_t y_index_32 = get_group_id_1_42 * 32 + get_local_id_1_39;\n    float val_45;\n    \n    if (slt32(x_index_31, sext_i64_i32(x_elems_5))) {\n        for (int32_t j_44 = 0; j_44 < 8; j_44++) {\n            int32_t index_in_35 = (y_index_32 + j_44 * 4) * sext_i64_i32(x_elems_5) + x_index_31;\n            \n            if (slt32(y_index_32 + j_44 * 4, sext_i64_i32(y_elems_6))) {\n                val_45 = ((__global float *) srcmem_2)[sext_i32_i64(idata_offset_34 + index_in_35)];\n                ((__local float *) block_9)[sext_i32_i64((get_local_id_1_39 + j_44 * 4) * 33 + get_local_id_0_38)] = val_45;\n            }\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * 32 + get_local_id_0_38;\n    y_index_32 = get_group_id_0_41 * 32 + get_local_id_1_39;\n    if (slt32(x_index_31, sext_i64_i32(y_elems_6))) {\n        for (int32_t j_44 = 0; j_44 < 8; j_44++) {\n            int32_t index_out_36 = (y_index_32 + j_44 * 4) * sext_i64_i32(y_elems_6) + x_index_31;\n            \n            if (slt32(y_index_32 + j_44 * 4, sext_i64_i32(x_elems_5))) {\n                val_45 = ((__local float *) block_9)", "[sext_i32_i64(get_local_id_0_38 * 33 + get_local_id_1_39 + j_44 * 4)];\n                ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 + index_out_36)] = val_45;\n            }\n        }\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(32, 4, 1)))\n__kernel void gpu_map_transpose_f32_i64(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int64_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int64_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int64_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int64_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int64_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int64_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int64_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int64_t our_array_offset_30 = get_group_id_2_43 * x_elems_5 * y_elems_6;\n    int64_t odata_offset_33 = squot64(destoffset_1, (int64_t) 4) + our_array_offset_30;\n    int64_t idata_offset_34 = squot64(srcoffset_3, (int64_t) 4) + our_array_offset_30;\n    int64_t x_index_31 = get_global_id_0_37;\n    int64_t y_index_32 = get_group_id_1_42 * (int64_t) 32 + get_local_id_1_39;\n    float val_45;\n    \n    if (slt64(x_index_31, x_elems_5)) {\n        for (int64_t j_44 = 0; j_44 < (int64_t) 8; j_44++) {\n  ", "          int64_t index_in_35 = (y_index_32 + j_44 * (int64_t) 4) * x_elems_5 + x_index_31;\n            \n            if (slt64(y_index_32 + j_44 * (int64_t) 4, y_elems_6)) {\n                val_45 = ((__global float *) srcmem_2)[idata_offset_34 + index_in_35];\n                ((__local float *) block_9)[(get_local_id_1_39 + j_44 * (int64_t) 4) * (int64_t) 33 + get_local_id_0_38] = val_45;\n            }\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * (int64_t) 32 + get_local_id_0_38;\n    y_index_32 = get_group_id_0_41 * (int64_t) 32 + get_local_id_1_39;\n    if (slt64(x_index_31, y_elems_6)) {\n        for (int64_t j_44 = 0; j_44 < (int64_t) 8; j_44++) {\n            int64_t index_out_36 = (y_index_32 + j_44 * (int64_t) 4) * y_elems_6 + x_index_31;\n            \n            if (slt64(y_index_32 + j_44 * (int64_t) 4, x_elems_5)) {\n                val_45 = ((__local float *) block_9)[get_local_id_0_38 * (int64_t) 33 + get_local_id_1_39 + j_44 * (int64_t) 4];\n                ((__global float *) destmem_0)[odata_offset_33 + index_out_36] = val_45;\n            }\n        }\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(16, 16, 1)))\n__kernel void gpu_map_transpose_f32_low_height_i32(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n ",
                                       "   int32_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int32_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int32_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int32_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int32_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int32_t our_array_offset_30 = get_group_id_2_43 * sext_i64_i32(x_elems_5) * sext_i64_i32(y_elems_6);\n    int32_t odata_offset_33 = squot32(sext_i64_i32(destoffset_1), 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(sext_i64_i32(srcoffset_3), 4) + our_array_offset_30;\n    int32_t x_index_31 = get_group_id_0_41 * 16 * sext_i64_i32(mulx_7) + get_local_id_0_38 + srem32(get_local_id_1_39, sext_i64_i32(mulx_7)) * 16;\n    int32_t y_index_32 = get_group_id_1_42 * 16 + squot32(get_local_id_1_39, sext_i64_i32(mulx_7));\n    float val_45;\n    int32_t index_in_35 = y_index_32 * sext_i64_i32(x_elems_5) + x_index_31;\n    \n    if (slt32(x_index_31, sext_i64_i32(x_elems_5)) && slt32(y_index_32, sext_i64_i32(y_elems_6))) {\n        val_45 = ((__global float *) srcmem_2)[sext_i32_i64(idata_offset_34 + index_in_35)];\n        ((__local float *) block_9)[sext_i32_i64(get_local_id_1_39 * 17 + get_local_id_0_38)] = val_45;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * 16 + squot32(get_local_id_0_38, sext_i64_i32(mulx_7));\n    y_index_32 = get_group_id_0_41 * 16 * sext_i64_i32(mulx_7) + get_local_id_1_39 + srem32(get_local_id_0_38, sext_i64_i32(mulx_7)) * 16;\n    \n    int32_t index_out_36 = y_index_32 * sext_i64_i32(y_elems_6) + x_index_31;\n    \n    if (slt32(x_index_31, sext_i64_i32(y_elems_6)) && slt32(y_index_32, sext_i64_i32(x_elems_5))) {\n        val_45 = ((__local float *) block_9)[sext_i32_i64(get_local_id_0_38 * 17 + get_local_id_1_39)];\n        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 + index", "_out_36)] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(16, 16, 1)))\n__kernel void gpu_map_transpose_f32_low_height_i64(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int64_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int64_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int64_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int64_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int64_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int64_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int64_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int64_t our_array_offset_30 = get_group_id_2_43 * x_elems_5 * y_elems_6;\n    int64_t odata_offset_33 = squot64(destoffset_1, (int64_t) 4) + our_array_offset_30;\n    int64_t idata_offset_34 = squot64(srcoffset_3, (int64_t) 4) + our_array_offset_30;\n    int64_t x_index_31 = get_group_id_0_41 * (int64_t) 16 * mulx_7 + get_local_id_0_38 + srem64(get_local_id_1_39, mulx_7) * (int64_t) 16;\n    int64_t y_index_32 = get_group_id_1_42 * (int64_t) 16 + squot64(get_local_id_1_39, mulx_7);\n    float val_45;\n    int64_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    \n    if (slt64(x_index_31, x_elems_5) && slt64(y_index_32, y_elems_6)) {\n        val_45 = ((__gl", "obal float *) srcmem_2)[idata_offset_34 + index_in_35];\n        ((__local float *) block_9)[get_local_id_1_39 * (int64_t) 17 + get_local_id_0_38] = val_45;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * (int64_t) 16 + squot64(get_local_id_0_38, mulx_7);\n    y_index_32 = get_group_id_0_41 * (int64_t) 16 * mulx_7 + get_local_id_1_39 + srem64(get_local_id_0_38, mulx_7) * (int64_t) 16;\n    \n    int64_t index_out_36 = y_index_32 * y_elems_6 + x_index_31;\n    \n    if (slt64(x_index_31, y_elems_6) && slt64(y_index_32, x_elems_5)) {\n        val_45 = ((__local float *) block_9)[get_local_id_0_38 * (int64_t) 17 + get_local_id_1_39];\n        ((__global float *) destmem_0)[odata_offset_33 + index_out_36] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(16, 16, 1)))\n__kernel void gpu_map_transpose_f32_low_width_i32(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int32_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int32_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int32_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int32_t get_global_id_0_37 = get_group",
                                       "_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int32_t our_array_offset_30 = get_group_id_2_43 * sext_i64_i32(x_elems_5) * sext_i64_i32(y_elems_6);\n    int32_t odata_offset_33 = squot32(sext_i64_i32(destoffset_1), 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(sext_i64_i32(srcoffset_3), 4) + our_array_offset_30;\n    int32_t x_index_31 = get_group_id_0_41 * 16 + squot32(get_local_id_0_38, sext_i64_i32(muly_8));\n    int32_t y_index_32 = get_group_id_1_42 * 16 * sext_i64_i32(muly_8) + get_local_id_1_39 + srem32(get_local_id_0_38, sext_i64_i32(muly_8)) * 16;\n    float val_45;\n    int32_t index_in_35 = y_index_32 * sext_i64_i32(x_elems_5) + x_index_31;\n    \n    if (slt32(x_index_31, sext_i64_i32(x_elems_5)) && slt32(y_index_32, sext_i64_i32(y_elems_6))) {\n        val_45 = ((__global float *) srcmem_2)[sext_i32_i64(idata_offset_34 + index_in_35)];\n        ((__local float *) block_9)[sext_i32_i64(get_local_id_1_39 * 17 + get_local_id_0_38)] = val_45;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * 16 * sext_i64_i32(muly_8) + get_local_id_0_38 + srem32(get_local_id_1_39, sext_i64_i32(muly_8)) * 16;\n    y_index_32 = get_group_id_0_41 * 16 + squot32(get_local_id_1_39, sext_i64_i32(muly_8));\n    \n    int32_t index_out_36 = y_index_32 * sext_i64_i32(y_elems_6) + x_index_31;\n    \n    if (slt32(x_index_31, sext_i64_i32(y_elems_6)) && slt32(y_index_32, sext_i64_i32(x_elems_5))) {\n        val_45 = ((__local float *) block_9)[sext_i32_i64(get_local_id_0_38 * 17 + get_local_id_1_39)];\n        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 + index_out_36)] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(16, 16, 1)))\n__kernel void gpu_map_transpose_f32_low_width_i64(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0,", " __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int64_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int64_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int64_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int64_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int64_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int64_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int64_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int64_t our_array_offset_30 = get_group_id_2_43 * x_elems_5 * y_elems_6;\n    int64_t odata_offset_33 = squot64(destoffset_1, (int64_t) 4) + our_array_offset_30;\n    int64_t idata_offset_34 = squot64(srcoffset_3, (int64_t) 4) + our_array_offset_30;\n    int64_t x_index_31 = get_group_id_0_41 * (int64_t) 16 + squot64(get_local_id_0_38, muly_8);\n    int64_t y_index_32 = get_group_id_1_42 * (int64_t) 16 * muly_8 + get_local_id_1_39 + srem64(get_local_id_0_38, muly_8) * (int64_t) 16;\n    float val_45;\n    int64_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    \n    if (slt64(x_index_31, x_elems_5) && slt64(y_index_32, y_elems_6)) {\n        val_45 = ((__global float *) srcmem_2)[idata_offset_34 + index_in_35];\n        ((__local float *) block_9)[get_local_id_1_39 * (int64_t) 17 + get_local_id_0_38] = val_45;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * (int64_t) 16 * muly_8 + get_local_id_0_38 + srem64(get_local_id_1_39, muly_8) * (int64_t) 16;\n    y_index_32 = get_group_id_0_41 * (int64_t) 16 +", " squot64(get_local_id_1_39, muly_8);\n    \n    int64_t index_out_36 = y_index_32 * y_elems_6 + x_index_31;\n    \n    if (slt64(x_index_31, y_elems_6) && slt64(y_index_32, x_elems_5)) {\n        val_45 = ((__local float *) block_9)[get_local_id_0_38 * (int64_t) 17 + get_local_id_1_39];\n        ((__global float *) destmem_0)[odata_offset_33 + index_out_36] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(256, 1, 1)))\n__kernel void gpu_map_transpose_f32_small_i32(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int32_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int32_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int32_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int32_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int32_t our_array_offset_30 = squot32(get_global_id_0_37, sext_i64_i32(y_elems_6) * sext_i64_i32(x_elems_5)) * (sext_i64_i32(y_elems_6) * sext_i64_i32(x_elems_5));\n    int32_t x_index_31 = squot32(srem32(get_global_id_0_37, sext_i64_i32(y_elems_6) * sext_i64_i32(x_elems_5)), sext_i64_i32(y_elems_6));\n    int32_t y_index_32 ",
                                       "= srem32(get_global_id_0_37, sext_i64_i32(y_elems_6));\n    float val_45;\n    int32_t odata_offset_33 = squot32(sext_i64_i32(destoffset_1), 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(sext_i64_i32(srcoffset_3), 4) + our_array_offset_30;\n    int32_t index_in_35 = y_index_32 * sext_i64_i32(x_elems_5) + x_index_31;\n    int32_t index_out_36 = x_index_31 * sext_i64_i32(y_elems_6) + y_index_32;\n    \n    if (slt32(get_global_id_0_37, sext_i64_i32(x_elems_5) * sext_i64_i32(y_elems_6) * sext_i64_i32(num_arrays_4))) {\n        val_45 = ((__global float *) srcmem_2)[sext_i32_i64(idata_offset_34 + index_in_35)];\n        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 + index_out_36)] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(256, 1, 1)))\n__kernel void gpu_map_transpose_f32_small_i64(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int64_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int64_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int64_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int64_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int64_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int64_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int64_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizz", "e_0_40 + get_local_id_0_38;\n    int64_t our_array_offset_30 = squot64(get_global_id_0_37, y_elems_6 * x_elems_5) * (y_elems_6 * x_elems_5);\n    int64_t x_index_31 = squot64(srem64(get_global_id_0_37, y_elems_6 * x_elems_5), y_elems_6);\n    int64_t y_index_32 = srem64(get_global_id_0_37, y_elems_6);\n    float val_45;\n    int64_t odata_offset_33 = squot64(destoffset_1, (int64_t) 4) + our_array_offset_30;\n    int64_t idata_offset_34 = squot64(srcoffset_3, (int64_t) 4) + our_array_offset_30;\n    int64_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    int64_t index_out_36 = x_index_31 * y_elems_6 + y_index_32;\n    \n    if (slt64(get_global_id_0_37, x_elems_5 * y_elems_6 * num_arrays_4)) {\n        val_45 = ((__global float *) srcmem_2)[idata_offset_34 + index_in_35];\n        ((__global float *) destmem_0)[odata_offset_33 + index_out_36] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(32, 4, 1)))\n__kernel void gpu_map_transpose_i64_i32(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int32_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int32_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int32_t get_local_siz", "ze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int32_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int32_t our_array_offset_30 = get_group_id_2_43 * sext_i64_i32(x_elems_5) * sext_i64_i32(y_elems_6);\n    int32_t odata_offset_33 = squot32(sext_i64_i32(destoffset_1), 8) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(sext_i64_i32(srcoffset_3), 8) + our_array_offset_30;\n    int32_t x_index_31 = get_global_id_0_37;\n    int32_t y_index_32 = get_group_id_1_42 * 32 + get_local_id_1_39;\n    int64_t val_45;\n    \n    if (slt32(x_index_31, sext_i64_i32(x_elems_5))) {\n        for (int32_t j_44 = 0; j_44 < 8; j_44++) {\n            int32_t index_in_35 = (y_index_32 + j_44 * 4) * sext_i64_i32(x_elems_5) + x_index_31;\n            \n            if (slt32(y_index_32 + j_44 * 4, sext_i64_i32(y_elems_6))) {\n                val_45 = ((__global int64_t *) srcmem_2)[sext_i32_i64(idata_offset_34 + index_in_35)];\n                ((__local int64_t *) block_9)[sext_i32_i64((get_local_id_1_39 + j_44 * 4) * 33 + get_local_id_0_38)] = val_45;\n            }\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * 32 + get_local_id_0_38;\n    y_index_32 = get_group_id_0_41 * 32 + get_local_id_1_39;\n    if (slt32(x_index_31, sext_i64_i32(y_elems_6))) {\n        for (int32_t j_44 = 0; j_44 < 8; j_44++) {\n            int32_t index_out_36 = (y_index_32 + j_44 * 4) * sext_i64_i32(y_elems_6) + x_index_31;\n            \n            if (slt32(y_index_32 + j_44 * 4, sext_i64_i32(x_elems_5))) {\n                val_45 = ((__local int64_t *) block_9)[sext_i32_i64(get_local_id_0_38 * 33 + get_local_id_1_39 + j_44 * 4)];\n                ((__global int64_t *) destmem_0)[sext_i32_i64(odata_offset_33 + index_out_36)] = val_45;\n            }\n        }\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(32, 4, 1)))\n__kernel void gpu_map_transpose_i64_i64(__local volatile int64_t *block_9_backin",
                                       "g_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int64_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int64_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int64_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int64_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int64_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int64_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int64_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int64_t our_array_offset_30 = get_group_id_2_43 * x_elems_5 * y_elems_6;\n    int64_t odata_offset_33 = squot64(destoffset_1, (int64_t) 8) + our_array_offset_30;\n    int64_t idata_offset_34 = squot64(srcoffset_3, (int64_t) 8) + our_array_offset_30;\n    int64_t x_index_31 = get_global_id_0_37;\n    int64_t y_index_32 = get_group_id_1_42 * (int64_t) 32 + get_local_id_1_39;\n    int64_t val_45;\n    \n    if (slt64(x_index_31, x_elems_5)) {\n        for (int64_t j_44 = 0; j_44 < (int64_t) 8; j_44++) {\n            int64_t index_in_35 = (y_index_32 + j_44 * (int64_t) 4) * x_elems_5 + x_index_31;\n            \n            if (slt64(y_index_32 + j_44 * (int64_t) 4, y_elems_6)) {\n                val_45 = ((__global int64_t *) srcmem_2)[idata_offset_34 + index_in_35];\n                ((__local int64_t *) block_9)[(get_local_id_1_39 + j_44 * (int64_t) 4) * (int64_t", ") 33 + get_local_id_0_38] = val_45;\n            }\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * (int64_t) 32 + get_local_id_0_38;\n    y_index_32 = get_group_id_0_41 * (int64_t) 32 + get_local_id_1_39;\n    if (slt64(x_index_31, y_elems_6)) {\n        for (int64_t j_44 = 0; j_44 < (int64_t) 8; j_44++) {\n            int64_t index_out_36 = (y_index_32 + j_44 * (int64_t) 4) * y_elems_6 + x_index_31;\n            \n            if (slt64(y_index_32 + j_44 * (int64_t) 4, x_elems_5)) {\n                val_45 = ((__local int64_t *) block_9)[get_local_id_0_38 * (int64_t) 33 + get_local_id_1_39 + j_44 * (int64_t) 4];\n                ((__global int64_t *) destmem_0)[odata_offset_33 + index_out_36] = val_45;\n            }\n        }\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(16, 16, 1)))\n__kernel void gpu_map_transpose_i64_low_height_i32(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int32_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int32_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int32_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int32_t get_g", "lobal_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int32_t our_array_offset_30 = get_group_id_2_43 * sext_i64_i32(x_elems_5) * sext_i64_i32(y_elems_6);\n    int32_t odata_offset_33 = squot32(sext_i64_i32(destoffset_1), 8) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(sext_i64_i32(srcoffset_3), 8) + our_array_offset_30;\n    int32_t x_index_31 = get_group_id_0_41 * 16 * sext_i64_i32(mulx_7) + get_local_id_0_38 + srem32(get_local_id_1_39, sext_i64_i32(mulx_7)) * 16;\n    int32_t y_index_32 = get_group_id_1_42 * 16 + squot32(get_local_id_1_39, sext_i64_i32(mulx_7));\n    int64_t val_45;\n    int32_t index_in_35 = y_index_32 * sext_i64_i32(x_elems_5) + x_index_31;\n    \n    if (slt32(x_index_31, sext_i64_i32(x_elems_5)) && slt32(y_index_32, sext_i64_i32(y_elems_6))) {\n        val_45 = ((__global int64_t *) srcmem_2)[sext_i32_i64(idata_offset_34 + index_in_35)];\n        ((__local int64_t *) block_9)[sext_i32_i64(get_local_id_1_39 * 17 + get_local_id_0_38)] = val_45;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * 16 + squot32(get_local_id_0_38, sext_i64_i32(mulx_7));\n    y_index_32 = get_group_id_0_41 * 16 * sext_i64_i32(mulx_7) + get_local_id_1_39 + srem32(get_local_id_0_38, sext_i64_i32(mulx_7)) * 16;\n    \n    int32_t index_out_36 = y_index_32 * sext_i64_i32(y_elems_6) + x_index_31;\n    \n    if (slt32(x_index_31, sext_i64_i32(y_elems_6)) && slt32(y_index_32, sext_i64_i32(x_elems_5))) {\n        val_45 = ((__local int64_t *) block_9)[sext_i32_i64(get_local_id_0_38 * 17 + get_local_id_1_39)];\n        ((__global int64_t *) destmem_0)[sext_i32_i64(odata_offset_33 + index_out_36)] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(16, 16, 1)))\n__kernel void gpu_map_transpose_i64_low_height_i64(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8",
                                       ", __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int64_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int64_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int64_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int64_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int64_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int64_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int64_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int64_t our_array_offset_30 = get_group_id_2_43 * x_elems_5 * y_elems_6;\n    int64_t odata_offset_33 = squot64(destoffset_1, (int64_t) 8) + our_array_offset_30;\n    int64_t idata_offset_34 = squot64(srcoffset_3, (int64_t) 8) + our_array_offset_30;\n    int64_t x_index_31 = get_group_id_0_41 * (int64_t) 16 * mulx_7 + get_local_id_0_38 + srem64(get_local_id_1_39, mulx_7) * (int64_t) 16;\n    int64_t y_index_32 = get_group_id_1_42 * (int64_t) 16 + squot64(get_local_id_1_39, mulx_7);\n    int64_t val_45;\n    int64_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    \n    if (slt64(x_index_31, x_elems_5) && slt64(y_index_32, y_elems_6)) {\n        val_45 = ((__global int64_t *) srcmem_2)[idata_offset_34 + index_in_35];\n        ((__local int64_t *) block_9)[get_local_id_1_39 * (int64_t) 17 + get_local_id_0_38] = val_45;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * (int64_t) 16 + squot64(get_local_id_0_38, mulx_7);\n    y_index_32 = get_group_id_0_41 * (int64_t) 16 * ", "mulx_7 + get_local_id_1_39 + srem64(get_local_id_0_38, mulx_7) * (int64_t) 16;\n    \n    int64_t index_out_36 = y_index_32 * y_elems_6 + x_index_31;\n    \n    if (slt64(x_index_31, y_elems_6) && slt64(y_index_32, x_elems_5)) {\n        val_45 = ((__local int64_t *) block_9)[get_local_id_0_38 * (int64_t) 17 + get_local_id_1_39];\n        ((__global int64_t *) destmem_0)[odata_offset_33 + index_out_36] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(16, 16, 1)))\n__kernel void gpu_map_transpose_i64_low_width_i32(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int32_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int32_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int32_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int32_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int32_t our_array_offset_30 = get_group_id_2_43 * sext_i64_i32(x_elems_5) * sext_i64_i32(y_elems_6);\n    int32_t odata_offset_33 = squot32(sext_i64_i32(destoffset_1), 8) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(sext_i64_i32(srcoffset_3), 8) + our_array_of", "fset_30;\n    int32_t x_index_31 = get_group_id_0_41 * 16 + squot32(get_local_id_0_38, sext_i64_i32(muly_8));\n    int32_t y_index_32 = get_group_id_1_42 * 16 * sext_i64_i32(muly_8) + get_local_id_1_39 + srem32(get_local_id_0_38, sext_i64_i32(muly_8)) * 16;\n    int64_t val_45;\n    int32_t index_in_35 = y_index_32 * sext_i64_i32(x_elems_5) + x_index_31;\n    \n    if (slt32(x_index_31, sext_i64_i32(x_elems_5)) && slt32(y_index_32, sext_i64_i32(y_elems_6))) {\n        val_45 = ((__global int64_t *) srcmem_2)[sext_i32_i64(idata_offset_34 + index_in_35)];\n        ((__local int64_t *) block_9)[sext_i32_i64(get_local_id_1_39 * 17 + get_local_id_0_38)] = val_45;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * 16 * sext_i64_i32(muly_8) + get_local_id_0_38 + srem32(get_local_id_1_39, sext_i64_i32(muly_8)) * 16;\n    y_index_32 = get_group_id_0_41 * 16 + squot32(get_local_id_1_39, sext_i64_i32(muly_8));\n    \n    int32_t index_out_36 = y_index_32 * sext_i64_i32(y_elems_6) + x_index_31;\n    \n    if (slt32(x_index_31, sext_i64_i32(y_elems_6)) && slt32(y_index_32, sext_i64_i32(x_elems_5))) {\n        val_45 = ((__local int64_t *) block_9)[sext_i32_i64(get_local_id_0_38 * 17 + get_local_id_1_39)];\n        ((__global int64_t *) destmem_0)[sext_i32_i64(odata_offset_33 + index_out_36)] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(16, 16, 1)))\n__kernel void gpu_map_transpose_i64_low_width_i64(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsi",
                                       "gned char *) block_9_backing_0;\n    \n    int64_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int64_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int64_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int64_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int64_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int64_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int64_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int64_t our_array_offset_30 = get_group_id_2_43 * x_elems_5 * y_elems_6;\n    int64_t odata_offset_33 = squot64(destoffset_1, (int64_t) 8) + our_array_offset_30;\n    int64_t idata_offset_34 = squot64(srcoffset_3, (int64_t) 8) + our_array_offset_30;\n    int64_t x_index_31 = get_group_id_0_41 * (int64_t) 16 + squot64(get_local_id_0_38, muly_8);\n    int64_t y_index_32 = get_group_id_1_42 * (int64_t) 16 * muly_8 + get_local_id_1_39 + srem64(get_local_id_0_38, muly_8) * (int64_t) 16;\n    int64_t val_45;\n    int64_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    \n    if (slt64(x_index_31, x_elems_5) && slt64(y_index_32, y_elems_6)) {\n        val_45 = ((__global int64_t *) srcmem_2)[idata_offset_34 + index_in_35];\n        ((__local int64_t *) block_9)[get_local_id_1_39 * (int64_t) 17 + get_local_id_0_38] = val_45;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_42 * (int64_t) 16 * muly_8 + get_local_id_0_38 + srem64(get_local_id_1_39, muly_8) * (int64_t) 16;\n    y_index_32 = get_group_id_0_41 * (int64_t) 16 + squot64(get_local_id_1_39, muly_8);\n    \n    int64_t index_out_36 = y_index_32 * y_elems_6 + x_index_31;\n    \n    if (slt64(x_index_31, y_elems_6) && slt64(y_index_32, x_elems_5)) {\n        val_45 = ((__local int64_t *) block_9)[get_local_id_0_38 * (int64_t) 17 + get_local_id_1_39];\n        ((__global int64_t *) d", "estmem_0)[odata_offset_33 + index_out_36] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(256, 1, 1)))\n__kernel void gpu_map_transpose_i64_small_i32(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int32_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int32_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int32_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int32_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int32_t our_array_offset_30 = squot32(get_global_id_0_37, sext_i64_i32(y_elems_6) * sext_i64_i32(x_elems_5)) * (sext_i64_i32(y_elems_6) * sext_i64_i32(x_elems_5));\n    int32_t x_index_31 = squot32(srem32(get_global_id_0_37, sext_i64_i32(y_elems_6) * sext_i64_i32(x_elems_5)), sext_i64_i32(y_elems_6));\n    int32_t y_index_32 = srem32(get_global_id_0_37, sext_i64_i32(y_elems_6));\n    int64_t val_45;\n    int32_t odata_offset_33 = squot32(sext_i64_i32(destoffset_1), 8) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(sext_i64_i32(srcoffset_3), 8) + our_array_offset_30;\n    int32_t index_in_35 = y_index_32 * sext_i64_i32(x_", "elems_5) + x_index_31;\n    int32_t index_out_36 = x_index_31 * sext_i64_i32(y_elems_6) + y_index_32;\n    \n    if (slt32(get_global_id_0_37, sext_i64_i32(x_elems_5) * sext_i64_i32(y_elems_6) * sext_i64_i32(num_arrays_4))) {\n        val_45 = ((__global int64_t *) srcmem_2)[sext_i32_i64(idata_offset_34 + index_in_35)];\n        ((__global int64_t *) destmem_0)[sext_i32_i64(odata_offset_33 + index_out_36)] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(256, 1, 1)))\n__kernel void gpu_map_transpose_i64_small_i64(__local volatile int64_t *block_9_backing_aligned_0, int64_t destoffset_1, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6, int64_t mulx_7, int64_t muly_8, __global unsigned char *destmem_0, __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 = (__local volatile unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int64_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int64_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int64_t get_group_id_0_41;\n    \n    get_group_id_0_41 = get_group_id(0);\n    \n    int64_t get_group_id_1_42;\n    \n    get_group_id_1_42 = get_group_id(1);\n    \n    int64_t get_group_id_2_43;\n    \n    get_group_id_2_43 = get_group_id(2);\n    \n    int64_t get_local_sizze_0_40;\n    \n    get_local_sizze_0_40 = get_local_size(0);\n    \n    int64_t get_global_id_0_37 = get_group_id_0_41 * get_local_sizze_0_40 + get_local_id_0_38;\n    int64_t our_array_offset_30 = squot64(get_global_id_0_37, y_elems_6 * x_elems_5) * (y_elems_6 * x_elems_5);\n    int64_t x_index_31 = squot64(srem64(get_global_id_0_37, y_elems_6 * x_elems_5), y_elems_6);\n    int64_t y_index_32 = srem64(get_global_id_0_37, y_elems_6);\n    in",
                                       "t64_t val_45;\n    int64_t odata_offset_33 = squot64(destoffset_1, (int64_t) 8) + our_array_offset_30;\n    int64_t idata_offset_34 = squot64(srcoffset_3, (int64_t) 8) + our_array_offset_30;\n    int64_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    int64_t index_out_36 = x_index_31 * y_elems_6 + y_index_32;\n    \n    if (slt64(get_global_id_0_37, x_elems_5 * y_elems_6 * num_arrays_4)) {\n        val_45 = ((__global int64_t *) srcmem_2)[idata_offset_34 + index_in_35];\n        ((__global int64_t *) destmem_0)[odata_offset_33 + index_out_36] = val_45;\n    }\n    \n  error_0:\n    return;\n}\n__attribute__((reqd_work_group_size(renderzisegscan_group_sizze_25064, 1, 1)))\n__kernel void renderziscan_stage1_25070(__global int *global_failure, __local volatile int64_t *scan_arr_mem_26384_backing_aligned_0, int64_t height_20354, float screen_calculations_20357, float screen_calculations_20358, float screen_calculations_20359, float screen_calculations_20360, float screen_calculations_20362, float screen_calculations_20363, int64_t width_20367, int64_t loop_dz2083Uz2086U_22380, int64_t dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, int64_t sizzezq_22389, int32_t num_threads_26378, __global unsigned char *ext_mem_26003, __global unsigned char *ext_mem_26004, __global unsigned char *mem_26027, __global unsigned char *mem_26030)\n{\n    #define segscan_group_sizze_25065 (renderzisegscan_group_sizze_25064)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict scan_arr_mem_26384_backing_0 = (__local volatile unsigned char *) scan_arr_mem_26384_backing_aligned_0;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26380;\n    int64_t group_sizze_26383;\n    int32_t wave_sizze_26382;\n    int32_t group_tid_26381;\n    \n    local_tid_26380 = get_local_id(0);\n    group_sizze_26383 = get_local_size(0);\n    wave_sizze_26382 = LOCKSTEP_WIDTH;\n    group_tid_26381 = get_group_id(0);\n    \n  ", "  int32_t global_tid_26379 = group_tid_26381 * group_sizze_26383 + local_tid_26380;\n    int32_t phys_tid_25070 = global_tid_26379;\n    __local unsigned char *scan_arr_mem_26384;\n    \n    scan_arr_mem_26384 = (__local unsigned char *) scan_arr_mem_26384_backing_0;\n    \n    int64_t x_22500;\n    int64_t y_22501;\n    \n    x_22500 = (int64_t) 0;\n    for (int64_t j_26386 = 0; j_26386 < sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, sext_i32_i64(num_threads_26378)); j_26386++) {\n        int64_t chunk_offset_26387 = segscan_group_sizze_25065 * j_26386 + sext_i32_i64(group_tid_26381) * (segscan_group_sizze_25065 * sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, sext_i32_i64(num_threads_26378)));\n        int64_t flat_idx_26388 = chunk_offset_26387 + sext_i32_i64(local_tid_26380);\n        int64_t gtid_25069 = flat_idx_26388;\n        \n        // threads in bounds read input\n        {\n            if (slt64(gtid_25069, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n                int64_t new_index_25818 = squot64(gtid_25069, (int64_t) 4);\n                int64_t binop_y_25820 = (int64_t) 4 * new_index_25818;\n                int64_t new_index_25821 = gtid_25069 - binop_y_25820;\n                int64_t x_23689 = ((__global int64_t *) ext_mem_26004)[new_index_25821 * loop_dz2083Uz2086U_22380 + new_index_25818];\n                int64_t x_23690 = ((__global int64_t *) ext_mem_26003)[new_index_25821 * loop_dz2083Uz2086U_22380 + new_index_25818];\n                int64_t tmp_23691 = mul64(sizzezq_22389, x_23689);\n                int64_t tmp_23692 = mul64(sizzezq_22389, x_23690);\n                int64_t sc_arg0_23693 = add64(sizzezq_22389, tmp_23691);\n                int64_t sc_arg0_23694 = add64(sizzezq_22389, tmp_23692);\n                float i64_res_23695 = sitofp_i64_f32(sc_arg0_23693);\n                float i64_res_23696 = sitofp_i64_f32(sc_arg0_23694);\n                float zt_res_23697 = screen_calculations_20362 * i64_res_23696;\n                float zt_res_23698 = scre", "en_calculations_20362 * i64_res_23695;\n                float zm_res_23699 = zt_res_23697 - screen_calculations_20357;\n                float zm_res_23700 = zt_res_23698 - screen_calculations_20358;\n                float zt_res_23701 = screen_calculations_20363 * zm_res_23699;\n                float zt_res_23702 = screen_calculations_20363 * zm_res_23700;\n                float zp_res_23703 = screen_calculations_20359 + zt_res_23701;\n                float zp_res_23704 = screen_calculations_20360 + zt_res_23702;\n                int64_t f32_res_23705 = fptosi_f32_i64(zp_res_23704);\n                int64_t f32_res_23706 = fptosi_f32_i64(zp_res_23703);\n                float i64_res_23707 = sitofp_i64_f32(tmp_23691);\n                float i64_res_23708 = sitofp_i64_f32(tmp_23692);\n                float zt_res_23709 = screen_calculations_20362 * i64_res_23708;\n                float zt_res_23710 = screen_calculations_20362 * i64_res_23707;\n                float zm_res_23711 = zt_res_23709 - screen_calculations_20357;\n                float zm_res_23712 = zt_res_23710 - screen_calculations_20358;\n                float zt_res_23713 = screen_calculations_20363 * zm_res_23711;\n                float zt_res_23714 = screen_calculations_20363 * zm_res_23712;\n                float zp_res_23715 = screen_calculations_20359 + zt_res_23713;\n                float zp_res_23716 = screen_calculations_20360 + zt_res_23714;\n                int64_t f32_res_23717 = fptosi_f32_i64(zp_res_23716);\n                int64_t f32_res_23718 = fptosi_f32_i64(zp_res_23715);\n                bool cond_23719 = slt64(f32_res_23705, (int64_t) 0);\n                bool cond_f_res_23720 = sle64(height_20354, f32_res_23717);\n                bool x_23721 = !cond_23719;\n                bool y_23722 = cond_f_res_23720 && x_23721;\n                bool cond_23723 = cond_23719 || y_23722;\n                bool cond_f_res_23724 = slt64(f32_res_23706, (int64_t) 0);\n                bool x_23725 = !cond_23723;\n                bo",
                                       "ol y_23726 = cond_f_res_23724 && x_23725;\n                bool cond_23727 = cond_23723 || y_23726;\n                bool lifted_rect_outside_window_res_f_res_23728 = sle64(width_20367, f32_res_23718);\n                bool x_23729 = !cond_23727;\n                bool y_23730 = lifted_rect_outside_window_res_f_res_23728 && x_23729;\n                bool lifted_rect_outside_window_res_23731 = cond_23727 || y_23730;\n                int64_t defunc_0_partition_arg1_res_23732 = btoi_bool_i64(lifted_rect_outside_window_res_23731);\n                bool is_i_23733 = defunc_0_partition_arg1_res_23732 == (int64_t) 0;\n                bool cond_neg_23734 = !is_i_23733;\n                int64_t part_res_23735 = btoi_bool_i64(cond_neg_23734);\n                int64_t part_res_23736 = btoi_bool_i64(is_i_23733);\n                \n                // write to-scan values to parameters\n                {\n                    y_22501 = part_res_23736;\n                }\n                // write mapped values results to global memory\n                {\n                    ((__global int64_t *) mem_26030)[gtid_25069] = part_res_23735;\n                }\n            }\n        }\n        // do one intra-group scan operation\n        {\n            // maybe restore some to-scan values to parameters, or read neutral\n            {\n                if (!slt64(gtid_25069, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n                    y_22501 = (int64_t) 0;\n                }\n            }\n            // combine with carry and write to local memory\n            {\n                int64_t zz_22502 = x_22500 + y_22501;\n                \n                ((__local int64_t *) scan_arr_mem_26384)[sext_i32_i64(local_tid_26380)] = zz_22502;\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            \n            int64_t x_26389;\n            int64_t y_26390;\n            int64_t x_26392;\n            int64_t y_26393;\n            bool ltid_in_bounds_26395 = slt64(sext_i32_i64(local_tid_26380), segscan_group_sizze_250", "65);\n            int32_t skip_threads_26396;\n            \n            // read input for in-block scan\n            {\n                if (ltid_in_bounds_26395) {\n                    y_26390 = ((volatile __local int64_t *) scan_arr_mem_26384)[sext_i32_i64(local_tid_26380)];\n                    if ((local_tid_26380 - squot32(local_tid_26380, 32) * 32) == 0) {\n                        x_26389 = y_26390;\n                    }\n                }\n            }\n            // in-block scan (hopefully no barriers needed)\n            {\n                skip_threads_26396 = 1;\n                while (slt32(skip_threads_26396, 32)) {\n                    bool thread_active_26397 = sle32(skip_threads_26396, local_tid_26380 - squot32(local_tid_26380, 32) * 32) && ltid_in_bounds_26395;\n                    \n                    if (thread_active_26397) {\n                        // read operands\n                        {\n                            x_26389 = ((volatile __local int64_t *) scan_arr_mem_26384)[sext_i32_i64(local_tid_26380) - sext_i32_i64(skip_threads_26396)];\n                        }\n                    }\n                    // perform operation\n                    {\n                        if (thread_active_26397) {\n                            int64_t zz_26391 = x_26389 + y_26390;\n                            \n                            x_26389 = zz_26391;\n                        }\n                    }\n                    if (sle32(wave_sizze_26382, skip_threads_26396)) {\n                        barrier(CLK_LOCAL_MEM_FENCE);\n                    }\n                    if (thread_active_26397) {\n                        // write result\n                        {\n                            ((volatile __local int64_t *) scan_arr_mem_26384)[sext_i32_i64(local_tid_26380)] = x_26389;\n                            y_26390 = x_26389;\n                        }\n                    }\n                    if (sle32(wave_sizze_26382, skip_threads_26396)) {\n                        barrier(CLK", "_LOCAL_MEM_FENCE);\n                    }\n                    skip_threads_26396 *= 2;\n                }\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            // last thread of block 'i' writes its result to offset 'i'\n            {\n                if ((local_tid_26380 - squot32(local_tid_26380, 32) * 32) == 31 && ltid_in_bounds_26395) {\n                    ((volatile __local int64_t *) scan_arr_mem_26384)[sext_i32_i64(squot32(local_tid_26380, 32))] = x_26389;\n                }\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            // scan the first block, after which offset 'i' contains carry-in for block 'i+1'\n            {\n                int32_t skip_threads_26398;\n                \n                // read input for in-block scan\n                {\n                    if (squot32(local_tid_26380, 32) == 0 && ltid_in_bounds_26395) {\n                        y_26393 = ((volatile __local int64_t *) scan_arr_mem_26384)[sext_i32_i64(local_tid_26380)];\n                        if ((local_tid_26380 - squot32(local_tid_26380, 32) * 32) == 0) {\n                            x_26392 = y_26393;\n                        }\n                    }\n                }\n                // in-block scan (hopefully no barriers needed)\n                {\n                    skip_threads_26398 = 1;\n                    while (slt32(skip_threads_26398, 32)) {\n                        bool thread_active_26399 = sle32(skip_threads_26398, local_tid_26380 - squot32(local_tid_26380, 32) * 32) && (squot32(local_tid_26380, 32) == 0 && ltid_in_bounds_26395);\n                        \n                        if (thread_active_26399) {\n                            // read operands\n                            {\n                                x_26392 = ((volatile __local int64_t *) scan_arr_mem_26384)[sext_i32_i64(local_tid_26380) - sext_i32_i64(skip_threads_26398)];\n                            }\n                        }\n                        // perform operation\n                  ",
                                       "      {\n                            if (thread_active_26399) {\n                                int64_t zz_26394 = x_26392 + y_26393;\n                                \n                                x_26392 = zz_26394;\n                            }\n                        }\n                        if (sle32(wave_sizze_26382, skip_threads_26398)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        if (thread_active_26399) {\n                            // write result\n                            {\n                                ((volatile __local int64_t *) scan_arr_mem_26384)[sext_i32_i64(local_tid_26380)] = x_26392;\n                                y_26393 = x_26392;\n                            }\n                        }\n                        if (sle32(wave_sizze_26382, skip_threads_26398)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        skip_threads_26398 *= 2;\n                    }\n                }\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            \n            bool no_carry_in_26400 = squot32(local_tid_26380, 32) == 0 || !ltid_in_bounds_26395;\n            \n            // carry-in for every block except the first\n            {\n                // read operands\n                {\n                    if (!no_carry_in_26400) {\n                        y_26390 = x_26389;\n                        x_26389 = ((__local int64_t *) scan_arr_mem_26384)[sext_i32_i64(squot32(local_tid_26380, 32)) - (int64_t) 1];\n                    }\n                }\n                // perform operation\n                {\n                    if (!no_carry_in_26400) {\n                        int64_t zz_26391 = x_26389 + y_26390;\n                        \n                        x_26389 = zz_26391;\n                    }\n                }\n                // write final result\n                {\n                    if (!no_carry_in_26400) {\n                        (", "(__local int64_t *) scan_arr_mem_26384)[sext_i32_i64(local_tid_26380)] = x_26389;\n                    }\n                }\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            // restore correct values for first block\n            {\n                if (squot32(local_tid_26380, 32) == 0 && ltid_in_bounds_26395) {\n                    ((__local int64_t *) scan_arr_mem_26384)[sext_i32_i64(local_tid_26380)] = y_26390;\n                }\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            // threads in bounds write partial scan result\n            {\n                if (slt64(gtid_25069, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n                    int64_t tmp_26401 = ((__local int64_t *) scan_arr_mem_26384)[sext_i32_i64(local_tid_26380)];\n                    \n                    ((__global int64_t *) mem_26027)[gtid_25069] = tmp_26401;\n                }\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            // first thread reads last element as carry-in for next iteration\n            {\n                bool crosses_segment_26402 = 0;\n                bool should_load_carry_26403 = local_tid_26380 == 0 && !crosses_segment_26402;\n                \n                if (should_load_carry_26403) {\n                    x_22500 = ((__local int64_t *) scan_arr_mem_26384)[segscan_group_sizze_25065 - (int64_t) 1];\n                }\n                if (!should_load_carry_26403) {\n                    x_22500 = (int64_t) 0;\n                }\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segscan_group_sizze_25065\n}\n__kernel void renderziscan_stage2_25070(__global int *global_failure, __local volatile int64_t *scan_arr_mem_26409_backing_aligned_0, int64_t dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, int64_t stage1_num_groups_26377, int32_t num_threads_26378, __global unsigned char *mem_26027)\n{\n    #define segscan_group_sizze_25065 (renderzisegscan_group_sizze_25064)\n    \n    const int ", "block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict scan_arr_mem_26409_backing_0 = (__local volatile unsigned char *) scan_arr_mem_26409_backing_aligned_0;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26405;\n    int64_t group_sizze_26408;\n    int32_t wave_sizze_26407;\n    int32_t group_tid_26406;\n    \n    local_tid_26405 = get_local_id(0);\n    group_sizze_26408 = get_local_size(0);\n    wave_sizze_26407 = LOCKSTEP_WIDTH;\n    group_tid_26406 = get_group_id(0);\n    \n    int32_t global_tid_26404 = group_tid_26406 * group_sizze_26408 + local_tid_26405;\n    int32_t phys_tid_25070 = global_tid_26404;\n    __local unsigned char *scan_arr_mem_26409;\n    \n    scan_arr_mem_26409 = (__local unsigned char *) scan_arr_mem_26409_backing_0;\n    \n    int64_t flat_idx_26411 = (sext_i32_i64(local_tid_26405) + (int64_t) 1) * (segscan_group_sizze_25065 * sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, sext_i32_i64(num_threads_26378))) - (int64_t) 1;\n    int64_t gtid_25069 = flat_idx_26411;\n    \n    // threads in bound read carries; others get neutral element\n    {\n        if (slt64(gtid_25069, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n            int64_t tmp_26412 = ((__global int64_t *) mem_26027)[gtid_25069];\n            \n            ((__local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405)] = tmp_26412;\n        } else {\n            ((__local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405)] = (int64_t) 0;\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int64_t x_22500;\n    int64_t y_22501;\n    int64_t x_26413;\n    int64_t y_26414;\n    bool ltid_in_bounds_26416 = slt64(sext_i32_i64(local_tid_26405), stage1_num_groups_26377);\n    int32_t skip_threads_26417;\n    \n    // read input for in-block scan\n    {\n        if (ltid_in_bounds_26416) {\n            y_22501 = ((volatile __local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405)];\n ",
                                       "           if ((local_tid_26405 - squot32(local_tid_26405, 32) * 32) == 0) {\n                x_22500 = y_22501;\n            }\n        }\n    }\n    // in-block scan (hopefully no barriers needed)\n    {\n        skip_threads_26417 = 1;\n        while (slt32(skip_threads_26417, 32)) {\n            bool thread_active_26418 = sle32(skip_threads_26417, local_tid_26405 - squot32(local_tid_26405, 32) * 32) && ltid_in_bounds_26416;\n            \n            if (thread_active_26418) {\n                // read operands\n                {\n                    x_22500 = ((volatile __local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405) - sext_i32_i64(skip_threads_26417)];\n                }\n            }\n            // perform operation\n            {\n                if (thread_active_26418) {\n                    int64_t zz_22502 = x_22500 + y_22501;\n                    \n                    x_22500 = zz_22502;\n                }\n            }\n            if (sle32(wave_sizze_26407, skip_threads_26417)) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n            }\n            if (thread_active_26418) {\n                // write result\n                {\n                    ((volatile __local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405)] = x_22500;\n                    y_22501 = x_22500;\n                }\n            }\n            if (sle32(wave_sizze_26407, skip_threads_26417)) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n            }\n            skip_threads_26417 *= 2;\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // last thread of block 'i' writes its result to offset 'i'\n    {\n        if ((local_tid_26405 - squot32(local_tid_26405, 32) * 32) == 31 && ltid_in_bounds_26416) {\n            ((volatile __local int64_t *) scan_arr_mem_26409)[sext_i32_i64(squot32(local_tid_26405, 32))] = x_22500;\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // scan the first block, after which offset 'i' contains carry-in for block 'i+1'\n    {\n        int32_t skip_", "threads_26419;\n        \n        // read input for in-block scan\n        {\n            if (squot32(local_tid_26405, 32) == 0 && ltid_in_bounds_26416) {\n                y_26414 = ((volatile __local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405)];\n                if ((local_tid_26405 - squot32(local_tid_26405, 32) * 32) == 0) {\n                    x_26413 = y_26414;\n                }\n            }\n        }\n        // in-block scan (hopefully no barriers needed)\n        {\n            skip_threads_26419 = 1;\n            while (slt32(skip_threads_26419, 32)) {\n                bool thread_active_26420 = sle32(skip_threads_26419, local_tid_26405 - squot32(local_tid_26405, 32) * 32) && (squot32(local_tid_26405, 32) == 0 && ltid_in_bounds_26416);\n                \n                if (thread_active_26420) {\n                    // read operands\n                    {\n                        x_26413 = ((volatile __local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405) - sext_i32_i64(skip_threads_26419)];\n                    }\n                }\n                // perform operation\n                {\n                    if (thread_active_26420) {\n                        int64_t zz_26415 = x_26413 + y_26414;\n                        \n                        x_26413 = zz_26415;\n                    }\n                }\n                if (sle32(wave_sizze_26407, skip_threads_26419)) {\n                    barrier(CLK_LOCAL_MEM_FENCE);\n                }\n                if (thread_active_26420) {\n                    // write result\n                    {\n                        ((volatile __local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405)] = x_26413;\n                        y_26414 = x_26413;\n                    }\n                }\n                if (sle32(wave_sizze_26407, skip_threads_26419)) {\n                    barrier(CLK_LOCAL_MEM_FENCE);\n                }\n                skip_threads_26419 *= 2;\n            }\n        }\n    }\n    barrier(CL", "K_LOCAL_MEM_FENCE);\n    \n    bool no_carry_in_26421 = squot32(local_tid_26405, 32) == 0 || !ltid_in_bounds_26416;\n    \n    // carry-in for every block except the first\n    {\n        // read operands\n        {\n            if (!no_carry_in_26421) {\n                y_22501 = x_22500;\n                x_22500 = ((__local int64_t *) scan_arr_mem_26409)[sext_i32_i64(squot32(local_tid_26405, 32)) - (int64_t) 1];\n            }\n        }\n        // perform operation\n        {\n            if (!no_carry_in_26421) {\n                int64_t zz_22502 = x_22500 + y_22501;\n                \n                x_22500 = zz_22502;\n            }\n        }\n        // write final result\n        {\n            if (!no_carry_in_26421) {\n                ((__local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405)] = x_22500;\n            }\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // restore correct values for first block\n    {\n        if (squot32(local_tid_26405, 32) == 0 && ltid_in_bounds_26416) {\n            ((__local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405)] = y_22501;\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // threads in bounds write scanned carries\n    {\n        if (slt64(gtid_25069, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n            int64_t tmp_26422 = ((__local int64_t *) scan_arr_mem_26409)[sext_i32_i64(local_tid_26405)];\n            \n            ((__global int64_t *) mem_26027)[gtid_25069] = tmp_26422;\n        }\n    }\n    \n  error_0:\n    return;\n    #undef segscan_group_sizze_25065\n}\n__attribute__((reqd_work_group_size(renderzisegscan_group_sizze_25064, 1, 1)))\n__kernel void renderziscan_stage3_25070(__global int *global_failure, int64_t dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, int64_t num_groups_25067, int32_t num_threads_26378, int32_t required_groups_26423, __global unsigned char *mem_26027)\n{\n    #define segscan_group_sizze_25065 (renderzisegscan_group_sizze_25064)\n    \n    const int block_dim0 = 0;\n    const int block",
                                       "_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26425;\n    int64_t group_sizze_26428;\n    int32_t wave_sizze_26427;\n    int32_t group_tid_26426;\n    \n    local_tid_26425 = get_local_id(0);\n    group_sizze_26428 = get_local_size(0);\n    wave_sizze_26427 = LOCKSTEP_WIDTH;\n    group_tid_26426 = get_group_id(0);\n    \n    int32_t global_tid_26424 = group_tid_26426 * group_sizze_26428 + local_tid_26425;\n    int32_t phys_tid_25070 = global_tid_26424;\n    int32_t phys_group_id_26429;\n    \n    phys_group_id_26429 = get_group_id(0);\n    \n    int32_t iterations_26430 = sdiv_up32(required_groups_26423 - phys_group_id_26429, sext_i64_i32(num_groups_25067));\n    \n    for (int32_t i_26431 = 0; i_26431 < iterations_26430; i_26431++) {\n        int32_t virt_group_id_26432 = phys_group_id_26429 + i_26431 * sext_i64_i32(num_groups_25067);\n        int64_t flat_idx_26433 = sext_i32_i64(virt_group_id_26432) * segscan_group_sizze_25065 + sext_i32_i64(local_tid_26425);\n        int64_t gtid_25069 = flat_idx_26433;\n        int64_t orig_group_26434 = squot64(flat_idx_26433, segscan_group_sizze_25065 * sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, sext_i32_i64(num_threads_26378)));\n        int64_t carry_in_flat_idx_26435 = orig_group_26434 * (segscan_group_sizze_25065 * sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, sext_i32_i64(num_threads_26378))) - (int64_t) 1;\n        \n        if (slt64(gtid_25069, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n            if (!(orig_group_26434 == (int64_t) 0 || flat_idx_26433 == (orig_group_26434 + (int64_t) 1) * (segscan_group_sizze_25065 * sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, sext_i32_i64(num_threads_26378))) - (int64_t) 1)) {\n                int64_t x_22500;\n                int64_t y_22501;\n                \n                x_22500 = ((__global int64_t *) mem_26027)[carry_in_flat_idx_26435];\n                y_22501 = ((__global int64_t *) mem_26027)[gtid_2", "5069];\n                \n                int64_t zz_22502 = x_22500 + y_22501;\n                \n                x_22500 = zz_22502;\n                ((__global int64_t *) mem_26027)[gtid_25069] = x_22500;\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segscan_group_sizze_25065\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_24229, 1, 1)))\n__kernel void renderzisegmap_24379(__global int *global_failure, int64_t loop_dz2083Uz2086U_22380, int64_t num_groups_24370, int32_t virt_num_groups_26179, __global unsigned char *mem_param_25862, __global unsigned char *mem_param_25867, __global unsigned char *mem_param_25872, __global unsigned char *mem_param_25877, __global unsigned char *mem_param_25882, __global unsigned char *mem_param_25887, __global unsigned char *mem_25964, __global unsigned char *mem_25967, __global unsigned char *mem_25970, __global unsigned char *mem_25973, __global unsigned char *mem_25976, __global unsigned char *mem_25979)\n{\n    #define segmap_group_sizze_24369 (renderzisegmap_group_sizze_24229)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26181;\n    int64_t group_sizze_26184;\n    int32_t wave_sizze_26183;\n    int32_t group_tid_26182;\n    \n    local_tid_26181 = get_local_id(0);\n    group_sizze_26184 = get_local_size(0);\n    wave_sizze_26183 = LOCKSTEP_WIDTH;\n    group_tid_26182 = get_group_id(0);\n    \n    int32_t global_tid_26180 = group_tid_26182 * group_sizze_26184 + local_tid_26181;\n    int32_t phys_tid_24379 = global_tid_26180;\n    int32_t phys_group_id_26185;\n    \n    phys_group_id_26185 = get_group_id(0);\n    \n    int32_t iterations_26186 = sdiv_up32(virt_num_groups_26179 - phys_group_id_26185, sext_i64_i32(num_groups_24370));\n    \n    for (int32_t i_26187 = 0; i_26187 < iterations_26186; i_26187++) {\n        int32_t virt_", "group_id_26188 = phys_group_id_26185 + i_26187 * sext_i64_i32(num_groups_24370);\n        int64_t global_tid_26189 = sext_i32_i64(virt_group_id_26188) * segmap_group_sizze_24369 + sext_i32_i64(local_tid_26181);\n        int64_t slice_26190 = loop_dz2083Uz2086U_22380;\n        int64_t gtid_24378 = global_tid_26189;\n        int64_t remnant_26191 = global_tid_26189 - gtid_24378;\n        \n        if (slt64(gtid_24378, loop_dz2083Uz2086U_22380)) {\n            float eta_p_24380 = ((__global float *) mem_param_25862)[gtid_24378];\n            int64_t eta_p_24381 = ((__global int64_t *) mem_param_25867)[gtid_24378];\n            int64_t eta_p_24382 = ((__global int64_t *) mem_param_25872)[gtid_24378];\n            float eta_p_24383 = ((__global float *) mem_param_25877)[gtid_24378];\n            int64_t eta_p_24384 = ((__global int64_t *) mem_param_25882)[gtid_24378];\n            int64_t eta_p_24385 = ((__global int64_t *) mem_param_25887)[gtid_24378];\n            float sin_res_24386 = futrts_sin32(eta_p_24383);\n            float abs_res_24387 = (float) fabs(sin_res_24386);\n            float tzq_24388 = 0.1F * abs_res_24387;\n            int64_t zc_rhs_24389 = shl64(eta_p_24384, (int64_t) 23);\n            int64_t x_24390 = eta_p_24384 ^ zc_rhs_24389;\n            int64_t zc_lhs_24391 = eta_p_24385 ^ x_24390;\n            int64_t zc_rhs_24392 = lshr64(x_24390, (int64_t) 17);\n            int64_t zc_lhs_24393 = zc_lhs_24391 ^ zc_rhs_24392;\n            int64_t zc_rhs_24394 = lshr64(eta_p_24385, (int64_t) 26);\n            int64_t new_y_24395 = zc_lhs_24393 ^ zc_rhs_24394;\n            int64_t tmp_24396 = add64(eta_p_24385, new_y_24395);\n            float u64_res_24397 = uitofp_i64_f32(tmp_24396);\n            float zs_res_24398 = u64_res_24397 / 1.8446744e19F;\n            int64_t zc_rhs_24399 = shl64(eta_p_24385, (int64_t) 23);\n            int64_t x_24400 = eta_p_24385 ^ zc_rhs_24399;\n            int64_t zc_lhs_24401 = new_y_24395 ^ x_24400;\n            int64_t zc_rhs_24402 = lshr64(x_24400",
                                       ", (int64_t) 17);\n            int64_t zc_lhs_24403 = zc_lhs_24401 ^ zc_rhs_24402;\n            int64_t zc_rhs_24404 = lshr64(new_y_24395, (int64_t) 26);\n            int64_t new_y_24405 = zc_lhs_24403 ^ zc_rhs_24404;\n            int64_t tmp_24406 = add64(new_y_24395, new_y_24405);\n            float u64_res_24407 = uitofp_i64_f32(tmp_24406);\n            float zs_res_24408 = u64_res_24407 / 1.8446744e19F;\n            int64_t zc_rhs_24409 = shl64(new_y_24395, (int64_t) 23);\n            int64_t x_24410 = new_y_24395 ^ zc_rhs_24409;\n            int64_t zc_lhs_24411 = new_y_24405 ^ x_24410;\n            int64_t zc_rhs_24412 = lshr64(x_24410, (int64_t) 17);\n            int64_t zc_lhs_24413 = zc_lhs_24411 ^ zc_rhs_24412;\n            int64_t zc_rhs_24414 = lshr64(new_y_24405, (int64_t) 26);\n            int64_t new_y_24415 = zc_lhs_24413 ^ zc_rhs_24414;\n            int64_t tmp_24416 = add64(new_y_24405, new_y_24415);\n            float u64_res_24417 = uitofp_i64_f32(tmp_24416);\n            float zs_res_24418 = u64_res_24417 / 1.8446744e19F;\n            int64_t zc_rhs_24419 = shl64(new_y_24405, (int64_t) 23);\n            int64_t x_24420 = new_y_24405 ^ zc_rhs_24419;\n            int64_t zc_lhs_24421 = new_y_24415 ^ x_24420;\n            int64_t zc_rhs_24422 = lshr64(x_24420, (int64_t) 17);\n            int64_t zc_lhs_24423 = zc_lhs_24421 ^ zc_rhs_24422;\n            int64_t zc_rhs_24424 = lshr64(new_y_24415, (int64_t) 26);\n            int64_t new_y_24425 = zc_lhs_24423 ^ zc_rhs_24424;\n            int64_t tmp_24426 = add64(new_y_24415, new_y_24425);\n            float u64_res_24427 = uitofp_i64_f32(tmp_24426);\n            float zs_res_24428 = u64_res_24427 / 1.8446744e19F;\n            float mem_25946[(int64_t) 4];\n            \n            mem_25946[(int64_t) 0] = zs_res_24398;\n            mem_25946[(int64_t) 1] = zs_res_24408;\n            mem_25946[(int64_t) 2] = zs_res_24418;\n            mem_25946[(int64_t) 3] = zs_res_24428;\n            \n            float mem_25947[(int64_t) 4];\n      ", "      float defunc_0_reduce_comm_res_24430;\n            float redout_25829 = 0.0F;\n            \n            for (int64_t i_25831 = 0; i_25831 < (int64_t) 4; i_25831++) {\n                float eta_p_24435 = mem_25946[i_25831];\n                float lifted_lambda_res_24436 = tzq_24388 + eta_p_24435;\n                float defunc_0_op_res_24434 = lifted_lambda_res_24436 + redout_25829;\n                \n                mem_25947[i_25831] = lifted_lambda_res_24436;\n                \n                float redout_tmp_26192 = defunc_0_op_res_24434;\n                \n                redout_25829 = redout_tmp_26192;\n            }\n            defunc_0_reduce_comm_res_24430 = redout_25829;\n            \n            float v_avg_24437 = defunc_0_reduce_comm_res_24430 / 4.0F;\n            float v_factor_24438 = eta_p_24380 / v_avg_24437;\n            float mem_25950[(int64_t) 4];\n            \n            for (int64_t i_25835 = 0; i_25835 < (int64_t) 4; i_25835++) {\n                float eta_p_24440 = mem_25947[i_25835];\n                float lifted_lambda_res_24441 = v_factor_24438 * eta_p_24440;\n                \n                mem_25950[i_25835] = lifted_lambda_res_24441;\n            }\n            \n            int64_t tmp_24442 = mul64((int64_t) 2, eta_p_24381);\n            int64_t tmp_24443 = mul64((int64_t) 2, eta_p_24382);\n            int64_t tmp_24444 = add64((int64_t) 1, tmp_24443);\n            int64_t tmp_24445 = add64((int64_t) 1, tmp_24442);\n            int64_t mem_25953[(int64_t) 4];\n            \n            mem_25953[(int64_t) 0] = tmp_24442;\n            mem_25953[(int64_t) 1] = tmp_24442;\n            mem_25953[(int64_t) 2] = tmp_24445;\n            mem_25953[(int64_t) 3] = tmp_24445;\n            \n            int64_t mem_25954[(int64_t) 4];\n            \n            mem_25954[(int64_t) 0] = tmp_24443;\n            mem_25954[(int64_t) 1] = tmp_24444;\n            mem_25954[(int64_t) 2] = tmp_24443;\n            mem_25954[(int64_t) 3] = tmp_24444;\n            \n            float rep", "licate_arg1_24448 = 0.9F * eta_p_24383;\n            float mem_25955[(int64_t) 4];\n            \n            for (int64_t nest_i_26195 = 0; nest_i_26195 < (int64_t) 4; nest_i_26195++) {\n                mem_25955[nest_i_26195] = replicate_arg1_24448;\n            }\n            \n            int64_t mem_25956[(int64_t) 4];\n            int64_t mem_25957[(int64_t) 4];\n            \n            for (int64_t i_25841 = 0; i_25841 < (int64_t) 4; i_25841++) {\n                int64_t i64_arg0_24453 = (int64_t) 4 ^ i_25841;\n                int32_t i64_res_24454 = sext_i64_i32(i64_arg0_24453);\n                int32_t zc_lhs_24455 = lshr32(i64_res_24454, 16);\n                int32_t zt_lhs_24456 = i64_res_24454 ^ zc_lhs_24455;\n                int32_t x_24457 = mul32(73244475, zt_lhs_24456);\n                int32_t zc_lhs_24458 = lshr32(x_24457, 16);\n                int32_t zt_lhs_24459 = x_24457 ^ zc_lhs_24458;\n                int32_t x_24460 = mul32(73244475, zt_lhs_24459);\n                int32_t zc_lhs_24461 = lshr32(x_24460, 16);\n                int32_t x_24462 = x_24460 ^ zc_lhs_24461;\n                int32_t zc_lhs_24463 = lshr32(x_24462, 16);\n                int32_t zt_lhs_24464 = x_24462 ^ zc_lhs_24463;\n                int32_t x_24465 = mul32(73244475, zt_lhs_24464);\n                int32_t zc_lhs_24466 = lshr32(x_24465, 16);\n                int32_t zt_lhs_24467 = x_24465 ^ zc_lhs_24466;\n                int32_t x_24468 = mul32(73244475, zt_lhs_24467);\n                int32_t zc_lhs_24469 = lshr32(x_24468, 16);\n                int32_t x_24470 = x_24468 ^ zc_lhs_24469;\n                int64_t unsign_arg0_24471 = zext_i32_i64(x_24470);\n                int64_t rand_arg0_24472 = (int64_t) 539527247 ^ unsign_arg0_24471;\n                int64_t zc_rhs_24473 = shl64(rand_arg0_24472, (int64_t) 23);\n                int64_t x_24474 = rand_arg0_24472 ^ zc_rhs_24473;\n                int64_t zc_lhs_24475 = (int64_t) 824515495 ^ x_24474;\n                int64_t zc_rhs_24476 = lshr64(x_24474",
                                       ", (int64_t) 17);\n                int64_t zc_lhs_24477 = zc_lhs_24475 ^ zc_rhs_24476;\n                int64_t new_y_24478 = (int64_t) 12 ^ zc_lhs_24477;\n                int64_t zc_lhs_24479 = (int64_t) 6916485073332985 ^ zc_lhs_24477;\n                int64_t zc_rhs_24480 = lshr64(new_y_24478, (int64_t) 26);\n                int64_t new_y_24481 = zc_lhs_24479 ^ zc_rhs_24480;\n                int64_t zc_rhs_24482 = shl64(new_y_24478, (int64_t) 23);\n                int64_t x_24483 = new_y_24478 ^ zc_rhs_24482;\n                int64_t zc_lhs_24484 = new_y_24481 ^ x_24483;\n                int64_t zc_rhs_24485 = lshr64(x_24483, (int64_t) 17);\n                int64_t zc_lhs_24486 = zc_lhs_24484 ^ zc_rhs_24485;\n                int64_t zc_rhs_24487 = lshr64(new_y_24481, (int64_t) 26);\n                int64_t new_y_24488 = zc_lhs_24486 ^ zc_rhs_24487;\n                int64_t zc_rhs_24489 = shl64(new_y_24481, (int64_t) 23);\n                int64_t x_24490 = new_y_24481 ^ zc_rhs_24489;\n                int64_t zc_lhs_24491 = new_y_24488 ^ x_24490;\n                int64_t zc_rhs_24492 = lshr64(x_24490, (int64_t) 17);\n                int64_t zc_lhs_24493 = zc_lhs_24491 ^ zc_rhs_24492;\n                int64_t zc_rhs_24494 = lshr64(new_y_24488, (int64_t) 26);\n                int64_t new_y_24495 = zc_lhs_24493 ^ zc_rhs_24494;\n                int64_t rand_arg0_24496 = new_y_24415 ^ new_y_24488;\n                int64_t rand_arg0_24497 = new_y_24425 ^ new_y_24495;\n                int64_t zc_rhs_24498 = shl64(rand_arg0_24496, (int64_t) 23);\n                int64_t x_24499 = rand_arg0_24496 ^ zc_rhs_24498;\n                int64_t zc_lhs_24500 = rand_arg0_24497 ^ x_24499;\n                int64_t zc_rhs_24501 = lshr64(x_24499, (int64_t) 17);\n                int64_t zc_lhs_24502 = zc_lhs_24500 ^ zc_rhs_24501;\n                int64_t zc_rhs_24503 = lshr64(rand_arg0_24497, (int64_t) 26);\n                int64_t new_y_24504 = zc_lhs_24502 ^ zc_rhs_24503;\n                int64_t zc_rhs_24505 = shl6", "4(rand_arg0_24497, (int64_t) 23);\n                int64_t x_24506 = rand_arg0_24497 ^ zc_rhs_24505;\n                int64_t zc_lhs_24507 = new_y_24504 ^ x_24506;\n                int64_t zc_rhs_24508 = lshr64(x_24506, (int64_t) 17);\n                int64_t zc_lhs_24509 = zc_lhs_24507 ^ zc_rhs_24508;\n                int64_t zc_rhs_24510 = lshr64(new_y_24504, (int64_t) 26);\n                int64_t new_y_24511 = zc_lhs_24509 ^ zc_rhs_24510;\n                \n                mem_25956[i_25841] = new_y_24504;\n                mem_25957[i_25841] = new_y_24511;\n            }\n            for (int64_t i_26198 = 0; i_26198 < (int64_t) 4; i_26198++) {\n                float tmp_26199 = mem_25950[i_26198];\n                \n                ((__global float *) mem_25964)[gtid_24378 + i_26198 * loop_dz2083Uz2086U_22380] = tmp_26199;\n            }\n            for (int64_t i_26200 = 0; i_26200 < (int64_t) 4; i_26200++) {\n                int64_t tmp_26201 = mem_25953[i_26200];\n                \n                ((__global int64_t *) mem_25967)[gtid_24378 + i_26200 * loop_dz2083Uz2086U_22380] = tmp_26201;\n            }\n            for (int64_t i_26202 = 0; i_26202 < (int64_t) 4; i_26202++) {\n                int64_t tmp_26203 = mem_25954[i_26202];\n                \n                ((__global int64_t *) mem_25970)[gtid_24378 + i_26202 * loop_dz2083Uz2086U_22380] = tmp_26203;\n            }\n            for (int64_t i_26204 = 0; i_26204 < (int64_t) 4; i_26204++) {\n                float tmp_26205 = mem_25955[i_26204];\n                \n                ((__global float *) mem_25973)[gtid_24378 + i_26204 * loop_dz2083Uz2086U_22380] = tmp_26205;\n            }\n            for (int64_t i_26206 = 0; i_26206 < (int64_t) 4; i_26206++) {\n                int64_t tmp_26207 = mem_25956[i_26206];\n                \n                ((__global int64_t *) mem_25976)[gtid_24378 + i_26206 * loop_dz2083Uz2086U_22380] = tmp_26207;\n            }\n            for (int64_t i_26208 = 0; i_26208 < (int64_t) 4; i_26208++) {\n  ", "              int64_t tmp_26209 = mem_25957[i_26208];\n                \n                ((__global int64_t *) mem_25979)[gtid_24378 + i_26208 * loop_dz2083Uz2086U_22380] = tmp_26209;\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segmap_group_sizze_24369\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_24792, 1, 1)))\n__kernel void renderzisegmap_24855(__global int *global_failure, int64_t loop_dz2083Uz2086U_22380, int64_t num_groups_24848, int32_t virt_num_groups_26210, __global unsigned char *mem_param_25877, __global unsigned char *mem_param_25882, __global unsigned char *mem_param_25887, __global unsigned char *mem_25892, __global unsigned char *mem_25895, __global unsigned char *mem_25898, __global unsigned char *mem_25901)\n{\n    #define segmap_group_sizze_24847 (renderzisegmap_group_sizze_24792)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26212;\n    int64_t group_sizze_26215;\n    int32_t wave_sizze_26214;\n    int32_t group_tid_26213;\n    \n    local_tid_26212 = get_local_id(0);\n    group_sizze_26215 = get_local_size(0);\n    wave_sizze_26214 = LOCKSTEP_WIDTH;\n    group_tid_26213 = get_group_id(0);\n    \n    int32_t global_tid_26211 = group_tid_26213 * group_sizze_26215 + local_tid_26212;\n    int32_t phys_tid_24855 = global_tid_26211;\n    int32_t phys_group_id_26216;\n    \n    phys_group_id_26216 = get_group_id(0);\n    \n    int32_t iterations_26217 = sdiv_up32(virt_num_groups_26210 - phys_group_id_26216, sext_i64_i32(num_groups_24848));\n    \n    for (int32_t i_26218 = 0; i_26218 < iterations_26217; i_26218++) {\n        int32_t virt_group_id_26219 = phys_group_id_26216 + i_26218 * sext_i64_i32(num_groups_24848);\n        int64_t global_tid_26220 = sext_i32_i64(virt_group_id_26219) * segmap_group_sizze_24847 + sext_i32_i64(local_tid_26212);\n     ",
                                       "   int64_t slice_26221 = loop_dz2083Uz2086U_22380;\n        int64_t gtid_24854 = global_tid_26220;\n        int64_t remnant_26222 = global_tid_26220 - gtid_24854;\n        \n        if (slt64(gtid_24854, loop_dz2083Uz2086U_22380)) {\n            float eta_p_24856 = ((__global float *) mem_param_25877)[gtid_24854];\n            int64_t eta_p_24857 = ((__global int64_t *) mem_param_25882)[gtid_24854];\n            int64_t eta_p_24858 = ((__global int64_t *) mem_param_25887)[gtid_24854];\n            float sin_res_24859 = futrts_sin32(eta_p_24856);\n            float abs_res_24860 = (float) fabs(sin_res_24859);\n            float tzq_24861 = 0.1F * abs_res_24860;\n            int64_t zc_rhs_24862 = shl64(eta_p_24857, (int64_t) 23);\n            int64_t x_24863 = eta_p_24857 ^ zc_rhs_24862;\n            int64_t zc_lhs_24864 = eta_p_24858 ^ x_24863;\n            int64_t zc_rhs_24865 = lshr64(x_24863, (int64_t) 17);\n            int64_t zc_lhs_24866 = zc_lhs_24864 ^ zc_rhs_24865;\n            int64_t zc_rhs_24867 = lshr64(eta_p_24858, (int64_t) 26);\n            int64_t new_y_24868 = zc_lhs_24866 ^ zc_rhs_24867;\n            int64_t tmp_24869 = add64(eta_p_24858, new_y_24868);\n            float u64_res_24870 = uitofp_i64_f32(tmp_24869);\n            float zs_res_24871 = u64_res_24870 / 1.8446744e19F;\n            int64_t zc_rhs_24872 = shl64(eta_p_24858, (int64_t) 23);\n            int64_t x_24873 = eta_p_24858 ^ zc_rhs_24872;\n            int64_t zc_lhs_24874 = new_y_24868 ^ x_24873;\n            int64_t zc_rhs_24875 = lshr64(x_24873, (int64_t) 17);\n            int64_t zc_lhs_24876 = zc_lhs_24874 ^ zc_rhs_24875;\n            int64_t zc_rhs_24877 = lshr64(new_y_24868, (int64_t) 26);\n            int64_t new_y_24878 = zc_lhs_24876 ^ zc_rhs_24877;\n            int64_t tmp_24879 = add64(new_y_24868, new_y_24878);\n            float u64_res_24880 = uitofp_i64_f32(tmp_24879);\n            float zs_res_24881 = u64_res_24880 / 1.8446744e19F;\n            int64_t zc_rhs_24882 = shl64(new_y_24868, (int64_t) 2", "3);\n            int64_t x_24883 = new_y_24868 ^ zc_rhs_24882;\n            int64_t zc_lhs_24884 = new_y_24878 ^ x_24883;\n            int64_t zc_rhs_24885 = lshr64(x_24883, (int64_t) 17);\n            int64_t zc_lhs_24886 = zc_lhs_24884 ^ zc_rhs_24885;\n            int64_t zc_rhs_24887 = lshr64(new_y_24878, (int64_t) 26);\n            int64_t new_y_24888 = zc_lhs_24886 ^ zc_rhs_24887;\n            int64_t tmp_24889 = add64(new_y_24878, new_y_24888);\n            float u64_res_24890 = uitofp_i64_f32(tmp_24889);\n            float zs_res_24891 = u64_res_24890 / 1.8446744e19F;\n            int64_t zc_rhs_24892 = shl64(new_y_24878, (int64_t) 23);\n            int64_t x_24893 = new_y_24878 ^ zc_rhs_24892;\n            int64_t zc_lhs_24894 = new_y_24888 ^ x_24893;\n            int64_t zc_rhs_24895 = lshr64(x_24893, (int64_t) 17);\n            int64_t zc_lhs_24896 = zc_lhs_24894 ^ zc_rhs_24895;\n            int64_t zc_rhs_24897 = lshr64(new_y_24888, (int64_t) 26);\n            int64_t new_y_24898 = zc_lhs_24896 ^ zc_rhs_24897;\n            int64_t tmp_24899 = add64(new_y_24888, new_y_24898);\n            float u64_res_24900 = uitofp_i64_f32(tmp_24899);\n            float zs_res_24901 = u64_res_24900 / 1.8446744e19F;\n            float mem_25889[(int64_t) 4];\n            \n            mem_25889[(int64_t) 0] = zs_res_24871;\n            mem_25889[(int64_t) 1] = zs_res_24881;\n            mem_25889[(int64_t) 2] = zs_res_24891;\n            mem_25889[(int64_t) 3] = zs_res_24901;\n            ((__global float *) mem_25892)[gtid_24854] = tzq_24861;\n            for (int64_t i_26223 = 0; i_26223 < (int64_t) 4; i_26223++) {\n                float tmp_26224 = mem_25889[i_26223];\n                \n                ((__global float *) mem_25895)[gtid_24854 + i_26223 * loop_dz2083Uz2086U_22380] = tmp_26224;\n            }\n            ((__global int64_t *) mem_25898)[gtid_24854] = new_y_24888;\n            ((__global int64_t *) mem_25901)[gtid_24854] = new_y_24898;\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | C", "LK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segmap_group_sizze_24847\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_24758, 1, 1)))\n__kernel void renderzisegmap_24925(__global int *global_failure, int64_t loop_dz2083Uz2086U_22380, __global unsigned char *mem_param_25862, __global unsigned char *mem_25905, __global unsigned char *mem_25913)\n{\n    #define segmap_group_sizze_24921 (renderzisegmap_group_sizze_24758)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26317;\n    int64_t group_sizze_26320;\n    int32_t wave_sizze_26319;\n    int32_t group_tid_26318;\n    \n    local_tid_26317 = get_local_id(0);\n    group_sizze_26320 = get_local_size(0);\n    wave_sizze_26319 = LOCKSTEP_WIDTH;\n    group_tid_26318 = get_group_id(0);\n    \n    int32_t global_tid_26316 = group_tid_26318 * group_sizze_26320 + local_tid_26317;\n    int32_t phys_tid_24925 = global_tid_26316;\n    int64_t global_tid_26321 = sext_i32_i64(group_tid_26318) * segmap_group_sizze_24921 + sext_i32_i64(local_tid_26317);\n    int64_t slice_26322 = loop_dz2083Uz2086U_22380;\n    int64_t gtid_24924 = global_tid_26321;\n    int64_t remnant_26323 = global_tid_26321 - gtid_24924;\n    \n    if (slt64(gtid_24924, loop_dz2083Uz2086U_22380)) {\n        float eta_p_24926 = ((__global float *) mem_param_25862)[gtid_24924];\n        float defunc_0_reduce_comm_res_24927 = ((__global float *) mem_25905)[gtid_24924];\n        float v_avg_24928 = defunc_0_reduce_comm_res_24927 / 4.0F;\n        float v_factor_24929 = eta_p_24926 / v_avg_24928;\n        \n        ((__global float *) mem_25913)[gtid_24924] = v_factor_24929;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_24921\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_24734, 1, 1)))\n__kernel void renderzisegmap_24941(__global int *global_failure, int64_t loop_dz2083Uz2086U_22380, __global unsigne",
                                       "d char *mem_25909, __global unsigned char *mem_25913, __global unsigned char *mem_25918)\n{\n    #define segmap_group_sizze_24936 (renderzisegmap_group_sizze_24734)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26326;\n    int64_t group_sizze_26329;\n    int32_t wave_sizze_26328;\n    int32_t group_tid_26327;\n    \n    local_tid_26326 = get_local_id(0);\n    group_sizze_26329 = get_local_size(0);\n    wave_sizze_26328 = LOCKSTEP_WIDTH;\n    group_tid_26327 = get_group_id(0);\n    \n    int32_t global_tid_26325 = group_tid_26327 * group_sizze_26329 + local_tid_26326;\n    int32_t phys_tid_24941 = global_tid_26325;\n    int64_t global_tid_26330 = sext_i32_i64(group_tid_26327) * segmap_group_sizze_24936 + sext_i32_i64(local_tid_26326);\n    int64_t slice_26331 = (int64_t) 4;\n    int64_t slice_26332 = loop_dz2083Uz2086U_22380 * slice_26331;\n    int64_t gtid_24939 = squot64(global_tid_26330, slice_26331);\n    int64_t remnant_26333 = global_tid_26330 - gtid_24939 * slice_26331;\n    int64_t gtid_24940 = remnant_26333;\n    int64_t remnant_26334 = remnant_26333 - gtid_24940;\n    \n    if (slt64(gtid_24939, loop_dz2083Uz2086U_22380) && slt64(gtid_24940, (int64_t) 4)) {\n        float v_factor_24942 = ((__global float *) mem_25913)[gtid_24939];\n        float eta_p_24943 = ((__global float *) mem_25909)[gtid_24939 * (int64_t) 4 + gtid_24940];\n        float lifted_lambda_res_24944 = v_factor_24942 * eta_p_24943;\n        \n        ((__global float *) mem_25918)[gtid_24939 * (int64_t) 4 + gtid_24940] = lifted_lambda_res_24944;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_24936\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_24702, 1, 1)))\n__kernel void renderzisegmap_24954(__global int *global_failure, int64_t loop_dz2083Uz2086U_22380, int64_t num_groups_24948, int32_t virt_num_groups_26335, __global unsigned char *mem_param_25867, __glo", "bal unsigned char *mem_param_25872, __global unsigned char *mem_param_25877, __global unsigned char *mem_25924, __global unsigned char *mem_25927, __global unsigned char *mem_25930)\n{\n    #define segmap_group_sizze_24947 (renderzisegmap_group_sizze_24702)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26337;\n    int64_t group_sizze_26340;\n    int32_t wave_sizze_26339;\n    int32_t group_tid_26338;\n    \n    local_tid_26337 = get_local_id(0);\n    group_sizze_26340 = get_local_size(0);\n    wave_sizze_26339 = LOCKSTEP_WIDTH;\n    group_tid_26338 = get_group_id(0);\n    \n    int32_t global_tid_26336 = group_tid_26338 * group_sizze_26340 + local_tid_26337;\n    int32_t phys_tid_24954 = global_tid_26336;\n    int32_t phys_group_id_26341;\n    \n    phys_group_id_26341 = get_group_id(0);\n    \n    int32_t iterations_26342 = sdiv_up32(virt_num_groups_26335 - phys_group_id_26341, sext_i64_i32(num_groups_24948));\n    \n    for (int32_t i_26343 = 0; i_26343 < iterations_26342; i_26343++) {\n        int32_t virt_group_id_26344 = phys_group_id_26341 + i_26343 * sext_i64_i32(num_groups_24948);\n        int64_t global_tid_26345 = sext_i32_i64(virt_group_id_26344) * segmap_group_sizze_24947 + sext_i32_i64(local_tid_26337);\n        int64_t slice_26346 = loop_dz2083Uz2086U_22380;\n        int64_t gtid_24953 = global_tid_26345;\n        int64_t remnant_26347 = global_tid_26345 - gtid_24953;\n        \n        if (slt64(gtid_24953, loop_dz2083Uz2086U_22380)) {\n            int64_t eta_p_24955 = ((__global int64_t *) mem_param_25867)[gtid_24953];\n            int64_t eta_p_24956 = ((__global int64_t *) mem_param_25872)[gtid_24953];\n            float eta_p_24957 = ((__global float *) mem_param_25877)[gtid_24953];\n            int64_t tmp_24958 = mul64((int64_t) 2, eta_p_24955);\n            int64_t tmp_24959 = mul64((int64_t) 2, eta_p_24956);\n            int64_t tmp_24960 = add64((in", "t64_t) 1, tmp_24959);\n            int64_t tmp_24961 = add64((int64_t) 1, tmp_24958);\n            int64_t mem_25920[(int64_t) 4];\n            \n            mem_25920[(int64_t) 0] = tmp_24958;\n            mem_25920[(int64_t) 1] = tmp_24958;\n            mem_25920[(int64_t) 2] = tmp_24961;\n            mem_25920[(int64_t) 3] = tmp_24961;\n            \n            int64_t mem_25921[(int64_t) 4];\n            \n            mem_25921[(int64_t) 0] = tmp_24959;\n            mem_25921[(int64_t) 1] = tmp_24960;\n            mem_25921[(int64_t) 2] = tmp_24959;\n            mem_25921[(int64_t) 3] = tmp_24960;\n            \n            float replicate_arg1_24964 = 0.9F * eta_p_24957;\n            \n            ((__global float *) mem_25924)[gtid_24953] = replicate_arg1_24964;\n            for (int64_t i_26348 = 0; i_26348 < (int64_t) 4; i_26348++) {\n                int64_t tmp_26349 = mem_25920[i_26348];\n                \n                ((__global int64_t *) mem_25927)[gtid_24953 + i_26348 * loop_dz2083Uz2086U_22380] = tmp_26349;\n            }\n            for (int64_t i_26350 = 0; i_26350 < (int64_t) 4; i_26350++) {\n                int64_t tmp_26351 = mem_25921[i_26350];\n                \n                ((__global int64_t *) mem_25930)[gtid_24953 + i_26350 * loop_dz2083Uz2086U_22380] = tmp_26351;\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segmap_group_sizze_24947\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_24681, 1, 1)))\n__kernel void renderzisegmap_24976(__global int *global_failure, int64_t loop_dz2083Uz2086U_22380, __global unsigned char *mem_25924, __global unsigned char *mem_25935)\n{\n    #define segmap_group_sizze_24971 (renderzisegmap_group_sizze_24681)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26354;\n    int64_t group_sizze_26357;\n    int32_t wave_si",
                                       "zze_26356;\n    int32_t group_tid_26355;\n    \n    local_tid_26354 = get_local_id(0);\n    group_sizze_26357 = get_local_size(0);\n    wave_sizze_26356 = LOCKSTEP_WIDTH;\n    group_tid_26355 = get_group_id(0);\n    \n    int32_t global_tid_26353 = group_tid_26355 * group_sizze_26357 + local_tid_26354;\n    int32_t phys_tid_24976 = global_tid_26353;\n    int64_t global_tid_26358 = sext_i32_i64(group_tid_26355) * segmap_group_sizze_24971 + sext_i32_i64(local_tid_26354);\n    int64_t slice_26359 = (int64_t) 4;\n    int64_t slice_26360 = loop_dz2083Uz2086U_22380 * slice_26359;\n    int64_t gtid_24974 = squot64(global_tid_26358, slice_26359);\n    int64_t remnant_26361 = global_tid_26358 - gtid_24974 * slice_26359;\n    int64_t gtid_24975 = remnant_26361;\n    int64_t remnant_26362 = remnant_26361 - gtid_24975;\n    \n    if (slt64(gtid_24974, loop_dz2083Uz2086U_22380) && slt64(gtid_24975, (int64_t) 4)) {\n        float replicate_arg1_24977 = ((__global float *) mem_25924)[gtid_24974];\n        \n        ((__global float *) mem_25935)[gtid_24974 * (int64_t) 4 + gtid_24975] = replicate_arg1_24977;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_24971\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_24527, 1, 1)))\n__kernel void renderzisegmap_24992(__global int *global_failure, int64_t loop_dz2083Uz2086U_22380, __global unsigned char *mem_25898, __global unsigned char *mem_25901, __global unsigned char *mem_25940, __global unsigned char *mem_25944)\n{\n    #define segmap_group_sizze_24986 (renderzisegmap_group_sizze_24527)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26365;\n    int64_t group_sizze_26368;\n    int32_t wave_sizze_26367;\n    int32_t group_tid_26366;\n    \n    local_tid_26365 = get_local_id(0);\n    group_sizze_26368 = get_local_size(0);\n    wave_sizze_26367 = LOCKSTEP_WIDTH;\n    group_tid_26366 = get_group_id(0);\n    \n    int3", "2_t global_tid_26364 = group_tid_26366 * group_sizze_26368 + local_tid_26365;\n    int32_t phys_tid_24992 = global_tid_26364;\n    int64_t global_tid_26369 = sext_i32_i64(group_tid_26366) * segmap_group_sizze_24986 + sext_i32_i64(local_tid_26365);\n    int64_t slice_26370 = (int64_t) 4;\n    int64_t slice_26371 = loop_dz2083Uz2086U_22380 * slice_26370;\n    int64_t gtid_24990 = squot64(global_tid_26369, slice_26370);\n    int64_t remnant_26372 = global_tid_26369 - gtid_24990 * slice_26370;\n    int64_t gtid_24991 = remnant_26372;\n    int64_t remnant_26373 = remnant_26372 - gtid_24991;\n    \n    if (slt64(gtid_24990, loop_dz2083Uz2086U_22380) && slt64(gtid_24991, (int64_t) 4)) {\n        int64_t new_y_24993 = ((__global int64_t *) mem_25898)[gtid_24990];\n        int64_t new_y_24994 = ((__global int64_t *) mem_25901)[gtid_24990];\n        int64_t i64_arg0_24996 = (int64_t) 4 ^ gtid_24991;\n        int32_t i64_res_24997 = sext_i64_i32(i64_arg0_24996);\n        int32_t zc_lhs_24998 = lshr32(i64_res_24997, 16);\n        int32_t zt_lhs_24999 = i64_res_24997 ^ zc_lhs_24998;\n        int32_t x_25000 = mul32(73244475, zt_lhs_24999);\n        int32_t zc_lhs_25001 = lshr32(x_25000, 16);\n        int32_t zt_lhs_25002 = x_25000 ^ zc_lhs_25001;\n        int32_t x_25003 = mul32(73244475, zt_lhs_25002);\n        int32_t zc_lhs_25004 = lshr32(x_25003, 16);\n        int32_t x_25005 = x_25003 ^ zc_lhs_25004;\n        int32_t zc_lhs_25006 = lshr32(x_25005, 16);\n        int32_t zt_lhs_25007 = x_25005 ^ zc_lhs_25006;\n        int32_t x_25008 = mul32(73244475, zt_lhs_25007);\n        int32_t zc_lhs_25009 = lshr32(x_25008, 16);\n        int32_t zt_lhs_25010 = x_25008 ^ zc_lhs_25009;\n        int32_t x_25011 = mul32(73244475, zt_lhs_25010);\n        int32_t zc_lhs_25012 = lshr32(x_25011, 16);\n        int32_t x_25013 = x_25011 ^ zc_lhs_25012;\n        int64_t unsign_arg0_25014 = zext_i32_i64(x_25013);\n        int64_t rand_arg0_25015 = (int64_t) 539527247 ^ unsign_arg0_25014;\n        int64_t zc_rhs_25016 = shl64(rand_", "arg0_25015, (int64_t) 23);\n        int64_t x_25017 = rand_arg0_25015 ^ zc_rhs_25016;\n        int64_t zc_lhs_25018 = (int64_t) 824515495 ^ x_25017;\n        int64_t zc_rhs_25019 = lshr64(x_25017, (int64_t) 17);\n        int64_t zc_lhs_25020 = zc_lhs_25018 ^ zc_rhs_25019;\n        int64_t new_y_25021 = (int64_t) 12 ^ zc_lhs_25020;\n        int64_t zc_lhs_25022 = (int64_t) 6916485073332985 ^ zc_lhs_25020;\n        int64_t zc_rhs_25023 = lshr64(new_y_25021, (int64_t) 26);\n        int64_t new_y_25024 = zc_lhs_25022 ^ zc_rhs_25023;\n        int64_t zc_rhs_25025 = shl64(new_y_25021, (int64_t) 23);\n        int64_t x_25026 = new_y_25021 ^ zc_rhs_25025;\n        int64_t zc_lhs_25027 = new_y_25024 ^ x_25026;\n        int64_t zc_rhs_25028 = lshr64(x_25026, (int64_t) 17);\n        int64_t zc_lhs_25029 = zc_lhs_25027 ^ zc_rhs_25028;\n        int64_t zc_rhs_25030 = lshr64(new_y_25024, (int64_t) 26);\n        int64_t new_y_25031 = zc_lhs_25029 ^ zc_rhs_25030;\n        int64_t zc_rhs_25032 = shl64(new_y_25024, (int64_t) 23);\n        int64_t x_25033 = new_y_25024 ^ zc_rhs_25032;\n        int64_t zc_lhs_25034 = new_y_25031 ^ x_25033;\n        int64_t zc_rhs_25035 = lshr64(x_25033, (int64_t) 17);\n        int64_t zc_lhs_25036 = zc_lhs_25034 ^ zc_rhs_25035;\n        int64_t zc_rhs_25037 = lshr64(new_y_25031, (int64_t) 26);\n        int64_t new_y_25038 = zc_lhs_25036 ^ zc_rhs_25037;\n        int64_t rand_arg0_25039 = new_y_24993 ^ new_y_25031;\n        int64_t rand_arg0_25040 = new_y_24994 ^ new_y_25038;\n        int64_t zc_rhs_25041 = shl64(rand_arg0_25039, (int64_t) 23);\n        int64_t x_25042 = rand_arg0_25039 ^ zc_rhs_25041;\n        int64_t zc_lhs_25043 = rand_arg0_25040 ^ x_25042;\n        int64_t zc_rhs_25044 = lshr64(x_25042, (int64_t) 17);\n        int64_t zc_lhs_25045 = zc_lhs_25043 ^ zc_rhs_25044;\n        int64_t zc_rhs_25046 = lshr64(rand_arg0_25040, (int64_t) 26);\n        int64_t new_y_25047 = zc_lhs_25045 ^ zc_rhs_25046;\n        int64_t zc_rhs_25048 = shl64(rand_arg0_25040, (int64_t) 23);\n      ",
                                       "  int64_t x_25049 = rand_arg0_25040 ^ zc_rhs_25048;\n        int64_t zc_lhs_25050 = new_y_25047 ^ x_25049;\n        int64_t zc_rhs_25051 = lshr64(x_25049, (int64_t) 17);\n        int64_t zc_lhs_25052 = zc_lhs_25050 ^ zc_rhs_25051;\n        int64_t zc_rhs_25053 = lshr64(new_y_25047, (int64_t) 26);\n        int64_t new_y_25054 = zc_lhs_25052 ^ zc_rhs_25053;\n        \n        ((__global int64_t *) mem_25940)[gtid_24990 * (int64_t) 4 + gtid_24991] = new_y_25047;\n        ((__global int64_t *) mem_25944)[gtid_24990 * (int64_t) 4 + gtid_24991] = new_y_25054;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_24986\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_25074, 1, 1)))\n__kernel void renderzisegmap_25072(__global int *global_failure, int64_t loop_dz2083Uz2086U_22380, int64_t dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, __global unsigned char *ext_mem_26000, __global unsigned char *ext_mem_26001, __global unsigned char *ext_mem_26002, __global unsigned char *ext_mem_26003, __global unsigned char *ext_mem_26004, __global unsigned char *ext_mem_26005, __global unsigned char *mem_26008, __global unsigned char *mem_26011, __global unsigned char *mem_26014, __global unsigned char *mem_26017, __global unsigned char *mem_26020, __global unsigned char *mem_26023, __global unsigned char *mem_26027, __global unsigned char *mem_26030)\n{\n    #define segmap_group_sizze_25075 (renderzisegmap_group_sizze_25074)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26438;\n    int64_t group_sizze_26441;\n    int32_t wave_sizze_26440;\n    int32_t group_tid_26439;\n    \n    local_tid_26438 = get_local_id(0);\n    group_sizze_26441 = get_local_size(0);\n    wave_sizze_26440 = LOCKSTEP_WIDTH;\n    group_tid_26439 = get_group_id(0);\n    \n    int32_t global_tid_26437 = group_tid_26439 * group_sizze_26441 + local_tid_26438;\n    int32_t phys_tid_25072 = globa", "l_tid_26437;\n    int64_t global_tid_26442 = sext_i32_i64(group_tid_26439) * segmap_group_sizze_25075 + sext_i32_i64(local_tid_26438);\n    int64_t slice_26443 = dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388;\n    int64_t write_i_25071 = global_tid_26442;\n    int64_t remnant_26444 = global_tid_26442 - write_i_25071;\n    \n    if (slt64(write_i_25071, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n        int64_t c_22522 = ((__global int64_t *) mem_26030)[write_i_25071];\n        int64_t offset_22523 = ((__global int64_t *) mem_26027)[write_i_25071];\n        int64_t new_index_25794 = squot64(write_i_25071, (int64_t) 4);\n        int64_t binop_y_25796 = (int64_t) 4 * new_index_25794;\n        int64_t new_index_25797 = write_i_25071 - binop_y_25796;\n        float v_22524 = ((__global float *) ext_mem_26005)[new_index_25794 * (int64_t) 4 + new_index_25797];\n        int64_t v_22525 = ((__global int64_t *) ext_mem_26004)[new_index_25797 * loop_dz2083Uz2086U_22380 + new_index_25794];\n        int64_t v_22526 = ((__global int64_t *) ext_mem_26003)[new_index_25797 * loop_dz2083Uz2086U_22380 + new_index_25794];\n        float v_22527 = ((__global float *) ext_mem_26002)[new_index_25794 * (int64_t) 4 + new_index_25797];\n        int64_t v_22528 = ((__global int64_t *) ext_mem_26001)[new_index_25794 * (int64_t) 4 + new_index_25797];\n        int64_t v_22529 = ((__global int64_t *) ext_mem_26000)[new_index_25794 * (int64_t) 4 + new_index_25797];\n        bool is_this_one_22530 = c_22522 == (int64_t) 0;\n        int64_t this_offset_22531 = (int64_t) -1 + offset_22523;\n        int64_t total_res_22532;\n        \n        if (is_this_one_22530 == 1) {\n            total_res_22532 = this_offset_22531;\n        } else {\n            total_res_22532 = (int64_t) -1;\n        }\n        if (sle64((int64_t) 0, total_res_22532) && slt64(total_res_22532, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n            ((__global float *) mem_26023)[total_res_22532] = v_22524;\n        }\n        if (sle64((int64_t) 0, total", "_res_22532) && slt64(total_res_22532, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n            ((__global int64_t *) mem_26020)[total_res_22532] = v_22525;\n        }\n        if (sle64((int64_t) 0, total_res_22532) && slt64(total_res_22532, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n            ((__global int64_t *) mem_26017)[total_res_22532] = v_22526;\n        }\n        if (sle64((int64_t) 0, total_res_22532) && slt64(total_res_22532, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n            ((__global float *) mem_26014)[total_res_22532] = v_22527;\n        }\n        if (sle64((int64_t) 0, total_res_22532) && slt64(total_res_22532, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n            ((__global int64_t *) mem_26011)[total_res_22532] = v_22528;\n        }\n        if (sle64((int64_t) 0, total_res_22532) && slt64(total_res_22532, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {\n            ((__global int64_t *) mem_26008)[total_res_22532] = v_22529;\n        }\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_25075\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_25080, 1, 1)))\n__kernel void renderzisegmap_25105(__global int *global_failure, float screen_calculations_20357, float screen_calculations_20358, float screen_calculations_20359, float screen_calculations_20360, float screen_calculations_20362, float screen_calculations_20363, int64_t r_22371, __global unsigned char *ext_mem_26059, __global unsigned char *ext_mem_26060, __global unsigned char *mem_26082, __global unsigned char *mem_26085)\n{\n    #define segmap_group_sizze_25100 (renderzisegmap_group_sizze_25080)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26447;\n    int64_t group_sizze_26450;\n    int32_t wave_sizze_26449;\n    int32_t group_tid_26448;\n    \n    local_tid_26447 = get_local_id(0);\n    group_sizze_26450 = get_local_size(0);\n    wave_sizze",
                                       "_26449 = LOCKSTEP_WIDTH;\n    group_tid_26448 = get_group_id(0);\n    \n    int32_t global_tid_26446 = group_tid_26448 * group_sizze_26450 + local_tid_26447;\n    int32_t phys_tid_25105 = global_tid_26446;\n    int64_t global_tid_26451 = sext_i32_i64(group_tid_26448) * segmap_group_sizze_25100 + sext_i32_i64(local_tid_26447);\n    int64_t slice_26452 = r_22371;\n    int64_t gtid_25104 = global_tid_26451;\n    int64_t remnant_26453 = global_tid_26451 - gtid_25104;\n    \n    if (slt64(gtid_25104, r_22371)) {\n        int64_t eta_p_25106 = ((__global int64_t *) ext_mem_26060)[gtid_25104];\n        int64_t eta_p_25107 = ((__global int64_t *) ext_mem_26059)[gtid_25104];\n        float i64_res_25108 = sitofp_i64_f32(eta_p_25106);\n        float i64_res_25109 = sitofp_i64_f32(eta_p_25107);\n        float zt_res_25110 = screen_calculations_20362 * i64_res_25109;\n        float zt_res_25111 = screen_calculations_20362 * i64_res_25108;\n        float zm_res_25112 = zt_res_25110 - screen_calculations_20357;\n        float zm_res_25113 = zt_res_25111 - screen_calculations_20358;\n        float zt_res_25114 = screen_calculations_20363 * zm_res_25112;\n        float zt_res_25115 = screen_calculations_20363 * zm_res_25113;\n        float zp_res_25116 = screen_calculations_20359 + zt_res_25114;\n        float zp_res_25117 = screen_calculations_20360 + zt_res_25115;\n        int64_t f32_res_25118 = fptosi_f32_i64(zp_res_25117);\n        int64_t f32_res_25119 = fptosi_f32_i64(zp_res_25116);\n        \n        ((__global int64_t *) mem_26082)[gtid_25104] = f32_res_25118;\n        ((__global int64_t *) mem_26085)[gtid_25104] = f32_res_25119;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_25100\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_25123, 1, 1)))\n__kernel void renderzisegmap_25121(__global int *global_failure, int64_t height_20354, int64_t width_20367, int64_t r_22371, __global unsigned char *ext_mem_26061, __global unsigned char *mem_26065, __global unsigned char *mem", "_26082, __global unsigned char *mem_26085)\n{\n    #define segmap_group_sizze_25124 (renderzisegmap_group_sizze_25123)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26456;\n    int64_t group_sizze_26459;\n    int32_t wave_sizze_26458;\n    int32_t group_tid_26457;\n    \n    local_tid_26456 = get_local_id(0);\n    group_sizze_26459 = get_local_size(0);\n    wave_sizze_26458 = LOCKSTEP_WIDTH;\n    group_tid_26457 = get_group_id(0);\n    \n    int32_t global_tid_26455 = group_tid_26457 * group_sizze_26459 + local_tid_26456;\n    int32_t phys_tid_25121 = global_tid_26455;\n    int64_t global_tid_26460 = sext_i32_i64(group_tid_26457) * segmap_group_sizze_25124 + sext_i32_i64(local_tid_26456);\n    int64_t slice_26461 = r_22371;\n    int64_t write_i_25120 = global_tid_26460;\n    int64_t remnant_26462 = global_tid_26460 - write_i_25120;\n    \n    if (slt64(write_i_25120, r_22371)) {\n        int64_t write_index_24039 = ((__global int64_t *) mem_26082)[write_i_25120];\n        int64_t write_index_24040 = ((__global int64_t *) mem_26085)[write_i_25120];\n        float write_value_24041 = ((__global float *) ext_mem_26061)[write_i_25120];\n        \n        if ((sle64((int64_t) 0, write_index_24039) && slt64(write_index_24039, height_20354)) && (sle64((int64_t) 0, write_index_24040) && slt64(write_index_24040, width_20367))) {\n            ((__global float *) mem_26065)[write_index_24039 * width_20367 + write_index_24040] = write_value_24041;\n        }\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_25124\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_25139, 1, 1)))\n__kernel void renderzisegmap_25300(__global int *global_failure, int64_t height_20354, int64_t width_20367, __global unsigned char *mem_26065, __global unsigned char *mem_26091)\n{\n    #define segmap_group_sizze_25295 (renderzisegmap_group_sizze_25139)\n    \n    const int block_d", "im0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26465;\n    int64_t group_sizze_26468;\n    int32_t wave_sizze_26467;\n    int32_t group_tid_26466;\n    \n    local_tid_26465 = get_local_id(0);\n    group_sizze_26468 = get_local_size(0);\n    wave_sizze_26467 = LOCKSTEP_WIDTH;\n    group_tid_26466 = get_group_id(0);\n    \n    int32_t global_tid_26464 = group_tid_26466 * group_sizze_26468 + local_tid_26465;\n    int32_t phys_tid_25300 = global_tid_26464;\n    int64_t global_tid_26469 = sext_i32_i64(group_tid_26466) * segmap_group_sizze_25295 + sext_i32_i64(local_tid_26465);\n    int64_t slice_26470 = width_20367;\n    int64_t slice_26471 = height_20354 * slice_26470;\n    int64_t gtid_25298 = squot64(global_tid_26469, slice_26470);\n    int64_t remnant_26472 = global_tid_26469 - gtid_25298 * slice_26470;\n    int64_t gtid_25299 = remnant_26472;\n    int64_t remnant_26473 = remnant_26472 - gtid_25299;\n    \n    if (slt64(gtid_25298, height_20354) && slt64(gtid_25299, width_20367)) {\n        float eta_p_25301 = ((__global float *) mem_26065)[gtid_25298 * width_20367 + gtid_25299];\n        float hsv_to_rgb_arg0_25302 = 360.0F * eta_p_25301;\n        float hzq_25303 = hsv_to_rgb_arg0_25302 / 60.0F;\n        float t32_arg0_25304 = hzq_25303 / 2.0F;\n        int32_t f32_res_25305 = fptosi_f32_i32(t32_arg0_25304);\n        float i32_res_25306 = sitofp_i32_f32(f32_res_25305);\n        float zm_rhs_25307 = 2.0F * i32_res_25306;\n        float fmod_res_25308 = hzq_25303 - zm_rhs_25307;\n        float abs_arg0_25309 = fmod_res_25308 - 1.0F;\n        float abs_res_25310 = (float) fabs(abs_arg0_25309);\n        float zt_rhs_25311 = 1.0F - abs_res_25310;\n        bool cond_25312 = 0.0F <= hzq_25303;\n        bool cond_t_res_25313 = hzq_25303 < 1.0F;\n        bool x_25314 = cond_25312 && cond_t_res_25313;\n        float hsv_to_rgb_res_25315;\n        float hsv_to_rgb_res_25316;\n        float hsv_to_rgb_res_25317;\n  ",
                                       "      \n        if (x_25314 == 1) {\n            hsv_to_rgb_res_25315 = 1.0F;\n            hsv_to_rgb_res_25316 = zt_rhs_25311;\n            hsv_to_rgb_res_25317 = 0.0F;\n        } else {\n            bool cond_25318 = 1.0F <= hzq_25303;\n            bool cond_t_res_25319 = hzq_25303 < 2.0F;\n            bool x_25320 = cond_25318 && cond_t_res_25319;\n            float hsv_to_rgb_res_f_res_25321;\n            float hsv_to_rgb_res_f_res_25322;\n            float hsv_to_rgb_res_f_res_25323;\n            \n            if (x_25320 == 1) {\n                hsv_to_rgb_res_f_res_25321 = zt_rhs_25311;\n                hsv_to_rgb_res_f_res_25322 = 1.0F;\n                hsv_to_rgb_res_f_res_25323 = 0.0F;\n            } else {\n                bool cond_25324 = 2.0F <= hzq_25303;\n                bool cond_t_res_25325 = hzq_25303 < 3.0F;\n                bool x_25326 = cond_25324 && cond_t_res_25325;\n                float hsv_to_rgb_res_f_res_f_res_25327;\n                float hsv_to_rgb_res_f_res_f_res_25328;\n                float hsv_to_rgb_res_f_res_f_res_25329;\n                \n                if (x_25326 == 1) {\n                    hsv_to_rgb_res_f_res_f_res_25327 = 0.0F;\n                    hsv_to_rgb_res_f_res_f_res_25328 = 1.0F;\n                    hsv_to_rgb_res_f_res_f_res_25329 = zt_rhs_25311;\n                } else {\n                    bool cond_25330 = 3.0F <= hzq_25303;\n                    bool cond_t_res_25331 = hzq_25303 < 4.0F;\n                    bool x_25332 = cond_25330 && cond_t_res_25331;\n                    float hsv_to_rgb_res_f_res_f_res_f_res_25333;\n                    \n                    if (x_25332 == 1) {\n                        hsv_to_rgb_res_f_res_f_res_f_res_25333 = zt_rhs_25311;\n                    } else {\n                        hsv_to_rgb_res_f_res_f_res_f_res_25333 = 0.0F;\n                    }\n                    \n                    float hsv_to_rgb_res_f_res_f_res_f_res_25334;\n                    float hsv_to_rgb_res_f_res_f_res_f_res_25335;\n            ", "        \n                    if (x_25332 == 1) {\n                        hsv_to_rgb_res_f_res_f_res_f_res_25334 = 0.0F;\n                        hsv_to_rgb_res_f_res_f_res_f_res_25335 = 1.0F;\n                    } else {\n                        bool cond_25336 = 4.0F <= hzq_25303;\n                        bool cond_t_res_25337 = hzq_25303 < 5.0F;\n                        bool x_25338 = cond_25336 && cond_t_res_25337;\n                        float hsv_to_rgb_res_f_res_f_res_f_res_f_res_25339;\n                        float hsv_to_rgb_res_f_res_f_res_f_res_f_res_25340;\n                        \n                        if (x_25338 == 1) {\n                            hsv_to_rgb_res_f_res_f_res_f_res_f_res_25339 = zt_rhs_25311;\n                            hsv_to_rgb_res_f_res_f_res_f_res_f_res_25340 = 1.0F;\n                        } else {\n                            bool cond_25341 = 5.0F <= hzq_25303;\n                            bool cond_t_res_25342 = hzq_25303 < 6.0F;\n                            bool x_25343 = cond_25341 && cond_t_res_25342;\n                            float hsv_to_rgb_res_f_res_f_res_f_res_f_res_f_res_25344;\n                            \n                            if (x_25343 == 1) {\n                                hsv_to_rgb_res_f_res_f_res_f_res_f_res_f_res_25344 = 1.0F;\n                            } else {\n                                hsv_to_rgb_res_f_res_f_res_f_res_f_res_f_res_25344 = 0.0F;\n                            }\n                            \n                            float hsv_to_rgb_res_f_res_f_res_f_res_f_res_f_res_25345;\n                            \n                            if (x_25343 == 1) {\n                                hsv_to_rgb_res_f_res_f_res_f_res_f_res_f_res_25345 = zt_rhs_25311;\n                            } else {\n                                hsv_to_rgb_res_f_res_f_res_f_res_f_res_f_res_25345 = 0.0F;\n                            }\n                            hsv_to_rgb_res_f_res_f_res_f_res_f_res_25339 = hsv_to_rgb_r", "es_f_res_f_res_f_res_f_res_f_res_25344;\n                            hsv_to_rgb_res_f_res_f_res_f_res_f_res_25340 = hsv_to_rgb_res_f_res_f_res_f_res_f_res_f_res_25345;\n                        }\n                        hsv_to_rgb_res_f_res_f_res_f_res_25334 = hsv_to_rgb_res_f_res_f_res_f_res_f_res_25339;\n                        hsv_to_rgb_res_f_res_f_res_f_res_25335 = hsv_to_rgb_res_f_res_f_res_f_res_f_res_25340;\n                    }\n                    hsv_to_rgb_res_f_res_f_res_25327 = hsv_to_rgb_res_f_res_f_res_f_res_25334;\n                    hsv_to_rgb_res_f_res_f_res_25328 = hsv_to_rgb_res_f_res_f_res_f_res_25333;\n                    hsv_to_rgb_res_f_res_f_res_25329 = hsv_to_rgb_res_f_res_f_res_f_res_25335;\n                }\n                hsv_to_rgb_res_f_res_25321 = hsv_to_rgb_res_f_res_f_res_25327;\n                hsv_to_rgb_res_f_res_25322 = hsv_to_rgb_res_f_res_f_res_25328;\n                hsv_to_rgb_res_f_res_25323 = hsv_to_rgb_res_f_res_f_res_25329;\n            }\n            hsv_to_rgb_res_25315 = hsv_to_rgb_res_f_res_25321;\n            hsv_to_rgb_res_25316 = hsv_to_rgb_res_f_res_25322;\n            hsv_to_rgb_res_25317 = hsv_to_rgb_res_f_res_25323;\n        }\n        \n        bool cond_25346 = hsv_to_rgb_res_25315 < 0.0F;\n        float clamp_channel_res_25347;\n        \n        if (cond_25346 == 1) {\n            clamp_channel_res_25347 = 0.0F;\n        } else {\n            bool cond_25348 = 1.0F < hsv_to_rgb_res_25315;\n            float clamp_channel_res_f_res_25349;\n            \n            if (cond_25348 == 1) {\n                clamp_channel_res_f_res_25349 = 1.0F;\n            } else {\n                clamp_channel_res_f_res_25349 = hsv_to_rgb_res_25315;\n            }\n            clamp_channel_res_25347 = clamp_channel_res_f_res_25349;\n        }\n        \n        float f32_arg0_25350 = 255.0F * clamp_channel_res_25347;\n        int32_t unsign_arg0_25351 = fptoui_f32_i32(f32_arg0_25350);\n        int32_t zb_rhs_25352 = shl32(unsign_arg0_25351, 16);\n        i",
                                       "nt32_t zb_lhs_25353 = -16777216 | zb_rhs_25352;\n        bool cond_25354 = hsv_to_rgb_res_25316 < 0.0F;\n        float clamp_channel_res_25355;\n        \n        if (cond_25354 == 1) {\n            clamp_channel_res_25355 = 0.0F;\n        } else {\n            bool cond_25356 = 1.0F < hsv_to_rgb_res_25316;\n            float clamp_channel_res_f_res_25357;\n            \n            if (cond_25356 == 1) {\n                clamp_channel_res_f_res_25357 = 1.0F;\n            } else {\n                clamp_channel_res_f_res_25357 = hsv_to_rgb_res_25316;\n            }\n            clamp_channel_res_25355 = clamp_channel_res_f_res_25357;\n        }\n        \n        float f32_arg0_25358 = 255.0F * clamp_channel_res_25355;\n        int32_t unsign_arg0_25359 = fptoui_f32_i32(f32_arg0_25358);\n        int32_t zb_rhs_25360 = shl32(unsign_arg0_25359, 8);\n        int32_t zb_lhs_25361 = zb_lhs_25353 | zb_rhs_25360;\n        bool cond_25362 = hsv_to_rgb_res_25317 < 0.0F;\n        float clamp_channel_res_25363;\n        \n        if (cond_25362 == 1) {\n            clamp_channel_res_25363 = 0.0F;\n        } else {\n            bool cond_25364 = 1.0F < hsv_to_rgb_res_25317;\n            float clamp_channel_res_f_res_25365;\n            \n            if (cond_25364 == 1) {\n                clamp_channel_res_f_res_25365 = 1.0F;\n            } else {\n                clamp_channel_res_f_res_25365 = hsv_to_rgb_res_25317;\n            }\n            clamp_channel_res_25363 = clamp_channel_res_f_res_25365;\n        }\n        \n        float f32_arg0_25366 = 255.0F * clamp_channel_res_25363;\n        int32_t unsign_arg0_25367 = fptoui_f32_i32(f32_arg0_25366);\n        int32_t from_rgba_res_25368 = zb_lhs_25361 | unsign_arg0_25367;\n        \n        ((__global int32_t *) mem_26091)[gtid_25298 * width_20367 + gtid_25299] = from_rgba_res_25368;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_25295\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_25373, 1, 1)))\n__kernel void renderzisegmap_25398(_", "_global int *global_failure, float screen_calculations_20357, float screen_calculations_20358, float screen_calculations_20359, float screen_calculations_20360, float screen_calculations_20362, float screen_calculations_20363, int64_t r_22371, __global unsigned char *ext_mem_26059, __global unsigned char *ext_mem_26060, __global unsigned char *mem_26095, __global unsigned char *mem_26098)\n{\n    #define segmap_group_sizze_25393 (renderzisegmap_group_sizze_25373)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26476;\n    int64_t group_sizze_26479;\n    int32_t wave_sizze_26478;\n    int32_t group_tid_26477;\n    \n    local_tid_26476 = get_local_id(0);\n    group_sizze_26479 = get_local_size(0);\n    wave_sizze_26478 = LOCKSTEP_WIDTH;\n    group_tid_26477 = get_group_id(0);\n    \n    int32_t global_tid_26475 = group_tid_26477 * group_sizze_26479 + local_tid_26476;\n    int32_t phys_tid_25398 = global_tid_26475;\n    int64_t global_tid_26480 = sext_i32_i64(group_tid_26477) * segmap_group_sizze_25393 + sext_i32_i64(local_tid_26476);\n    int64_t slice_26481 = r_22371;\n    int64_t gtid_25397 = global_tid_26480;\n    int64_t remnant_26482 = global_tid_26480 - gtid_25397;\n    \n    if (slt64(gtid_25397, r_22371)) {\n        int64_t eta_p_25399 = ((__global int64_t *) ext_mem_26060)[gtid_25397];\n        int64_t eta_p_25400 = ((__global int64_t *) ext_mem_26059)[gtid_25397];\n        float i64_res_25401 = sitofp_i64_f32(eta_p_25399);\n        float i64_res_25402 = sitofp_i64_f32(eta_p_25400);\n        float zt_res_25403 = screen_calculations_20362 * i64_res_25402;\n        float zt_res_25404 = screen_calculations_20362 * i64_res_25401;\n        float zm_res_25405 = zt_res_25403 - screen_calculations_20357;\n        float zm_res_25406 = zt_res_25404 - screen_calculations_20358;\n        float zt_res_25407 = screen_calculations_20363 * zm_res_25405;\n        float zt_res_2540", "8 = screen_calculations_20363 * zm_res_25406;\n        float zp_res_25409 = screen_calculations_20359 + zt_res_25407;\n        float zp_res_25410 = screen_calculations_20360 + zt_res_25408;\n        int64_t f32_res_25411 = fptosi_f32_i64(zp_res_25410);\n        int64_t f32_res_25412 = fptosi_f32_i64(zp_res_25409);\n        \n        ((__global int64_t *) mem_26095)[gtid_25397] = f32_res_25411;\n        ((__global int64_t *) mem_26098)[gtid_25397] = f32_res_25412;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_25393\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_25416, 1, 1)))\n__kernel void renderzisegmap_25414(__global int *global_failure, int64_t height_20354, int64_t width_20367, int64_t r_22371, __global unsigned char *ext_mem_26061, __global unsigned char *mem_26065, __global unsigned char *mem_26095, __global unsigned char *mem_26098)\n{\n    #define segmap_group_sizze_25417 (renderzisegmap_group_sizze_25416)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26485;\n    int64_t group_sizze_26488;\n    int32_t wave_sizze_26487;\n    int32_t group_tid_26486;\n    \n    local_tid_26485 = get_local_id(0);\n    group_sizze_26488 = get_local_size(0);\n    wave_sizze_26487 = LOCKSTEP_WIDTH;\n    group_tid_26486 = get_group_id(0);\n    \n    int32_t global_tid_26484 = group_tid_26486 * group_sizze_26488 + local_tid_26485;\n    int32_t phys_tid_25414 = global_tid_26484;\n    int64_t global_tid_26489 = sext_i32_i64(group_tid_26486) * segmap_group_sizze_25417 + sext_i32_i64(local_tid_26485);\n    int64_t slice_26490 = r_22371;\n    int64_t write_i_25413 = global_tid_26489;\n    int64_t remnant_26491 = global_tid_26489 - write_i_25413;\n    \n    if (slt64(write_i_25413, r_22371)) {\n        int64_t write_index_24147 = ((__global int64_t *) mem_26095)[write_i_25413];\n        int64_t write_index_24148 = ((__global int64_t *) mem_26098)[write_i_2",
                                       "5413];\n        float write_value_24149 = ((__global float *) ext_mem_26061)[write_i_25413];\n        \n        if ((sle64((int64_t) 0, write_index_24147) && slt64(write_index_24147, height_20354)) && (sle64((int64_t) 0, write_index_24148) && slt64(write_index_24148, width_20367))) {\n            ((__global float *) mem_26065)[write_index_24147 * width_20367 + write_index_24148] = write_value_24149;\n        }\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_25417\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_25432, 1, 1)))\n__kernel void renderzisegmap_25577(__global int *global_failure, int64_t height_20354, int64_t width_20367, __global unsigned char *mem_26065, __global unsigned char *mem_26104)\n{\n    #define segmap_group_sizze_25572 (renderzisegmap_group_sizze_25432)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26494;\n    int64_t group_sizze_26497;\n    int32_t wave_sizze_26496;\n    int32_t group_tid_26495;\n    \n    local_tid_26494 = get_local_id(0);\n    group_sizze_26497 = get_local_size(0);\n    wave_sizze_26496 = LOCKSTEP_WIDTH;\n    group_tid_26495 = get_group_id(0);\n    \n    int32_t global_tid_26493 = group_tid_26495 * group_sizze_26497 + local_tid_26494;\n    int32_t phys_tid_25577 = global_tid_26493;\n    int64_t global_tid_26498 = sext_i32_i64(group_tid_26495) * segmap_group_sizze_25572 + sext_i32_i64(local_tid_26494);\n    int64_t slice_26499 = width_20367;\n    int64_t slice_26500 = height_20354 * slice_26499;\n    int64_t gtid_25575 = squot64(global_tid_26498, slice_26499);\n    int64_t remnant_26501 = global_tid_26498 - gtid_25575 * slice_26499;\n    int64_t gtid_25576 = remnant_26501;\n    int64_t remnant_26502 = remnant_26501 - gtid_25576;\n    \n    if (slt64(gtid_25575, height_20354) && slt64(gtid_25576, width_20367)) {\n        float eta_p_25578 = ((__global float *) mem_26065)[gtid_25575 * width_20367 + ", "gtid_25576];\n        float from_LCh_arg0_25579 = 6.2831855F * eta_p_25578;\n        float cos_res_25580 = futrts_cos32(from_LCh_arg0_25579);\n        float sin_res_25581 = futrts_sin32(from_LCh_arg0_25579);\n        float zp_rhs_25582 = 0.39633778F * cos_res_25580;\n        float zp_lhs_25583 = 1.0F + zp_rhs_25582;\n        float zp_rhs_25584 = 0.21580376F * sin_res_25581;\n        float l__25585 = zp_lhs_25583 + zp_rhs_25584;\n        float zm_rhs_25586 = 0.105561346F * cos_res_25580;\n        float zm_lhs_25587 = 1.0F - zm_rhs_25586;\n        float zm_rhs_25588 = 6.385417e-2F * sin_res_25581;\n        float m__25589 = zm_lhs_25587 - zm_rhs_25588;\n        float zm_rhs_25590 = 8.948418e-2F * cos_res_25580;\n        float zm_lhs_25591 = 1.0F - zm_rhs_25590;\n        float zm_rhs_25592 = 1.2914855F * sin_res_25581;\n        float s__25593 = zm_lhs_25591 - zm_rhs_25592;\n        float zt_lhs_25594 = l__25585 * l__25585;\n        float l_25595 = l__25585 * zt_lhs_25594;\n        float zt_lhs_25596 = m__25589 * m__25589;\n        float m_25597 = m__25589 * zt_lhs_25596;\n        float zt_lhs_25598 = s__25593 * s__25593;\n        float s_25599 = s__25593 * zt_lhs_25598;\n        float zm_lhs_25600 = 4.0767417F * l_25595;\n        float zm_rhs_25601 = 3.3077116F * m_25597;\n        float zp_lhs_25602 = zm_lhs_25600 - zm_rhs_25601;\n        float zp_rhs_25603 = 0.23096994F * s_25599;\n        float tmp_25604 = zp_lhs_25602 + zp_rhs_25603;\n        float zp_lhs_25605 = -1.268438F * l_25595;\n        float zp_rhs_25606 = 2.6097574F * m_25597;\n        float zm_lhs_25607 = zp_lhs_25605 + zp_rhs_25606;\n        float zm_rhs_25608 = 0.34131938F * s_25599;\n        float tmp_25609 = zm_lhs_25607 - zm_rhs_25608;\n        float zm_lhs_25610 = -4.1960864e-3F * l_25595;\n        float zm_rhs_25611 = 0.7034186F * m_25597;\n        float zp_lhs_25612 = zm_lhs_25610 - zm_rhs_25611;\n        float zp_rhs_25613 = 1.7076147F * s_25599;\n        float tmp_25614 = zp_lhs_25612 + zp_rhs_25613;\n        bool cond_25615 = tmp_25", "604 < 0.0F;\n        float clamp_channel_res_25616;\n        \n        if (cond_25615 == 1) {\n            clamp_channel_res_25616 = 0.0F;\n        } else {\n            bool cond_25617 = 1.0F < tmp_25604;\n            float clamp_channel_res_f_res_25618;\n            \n            if (cond_25617 == 1) {\n                clamp_channel_res_f_res_25618 = 1.0F;\n            } else {\n                clamp_channel_res_f_res_25618 = tmp_25604;\n            }\n            clamp_channel_res_25616 = clamp_channel_res_f_res_25618;\n        }\n        \n        float f32_arg0_25619 = 255.0F * clamp_channel_res_25616;\n        int32_t unsign_arg0_25620 = fptoui_f32_i32(f32_arg0_25619);\n        int32_t zb_rhs_25621 = shl32(unsign_arg0_25620, 16);\n        int32_t zb_lhs_25622 = -16777216 | zb_rhs_25621;\n        bool cond_25623 = tmp_25609 < 0.0F;\n        float clamp_channel_res_25624;\n        \n        if (cond_25623 == 1) {\n            clamp_channel_res_25624 = 0.0F;\n        } else {\n            bool cond_25625 = 1.0F < tmp_25609;\n            float clamp_channel_res_f_res_25626;\n            \n            if (cond_25625 == 1) {\n                clamp_channel_res_f_res_25626 = 1.0F;\n            } else {\n                clamp_channel_res_f_res_25626 = tmp_25609;\n            }\n            clamp_channel_res_25624 = clamp_channel_res_f_res_25626;\n        }\n        \n        float f32_arg0_25627 = 255.0F * clamp_channel_res_25624;\n        int32_t unsign_arg0_25628 = fptoui_f32_i32(f32_arg0_25627);\n        int32_t zb_rhs_25629 = shl32(unsign_arg0_25628, 8);\n        int32_t zb_lhs_25630 = zb_lhs_25622 | zb_rhs_25629;\n        bool cond_25631 = tmp_25614 < 0.0F;\n        float clamp_channel_res_25632;\n        \n        if (cond_25631 == 1) {\n            clamp_channel_res_25632 = 0.0F;\n        } else {\n            bool cond_25633 = 1.0F < tmp_25614;\n            float clamp_channel_res_f_res_25634;\n            \n            if (cond_25633 == 1) {\n                clamp_channel_res_f_res_25634 = 1.0F;\n            } e",
                                       "lse {\n                clamp_channel_res_f_res_25634 = tmp_25614;\n            }\n            clamp_channel_res_25632 = clamp_channel_res_f_res_25634;\n        }\n        \n        float f32_arg0_25635 = 255.0F * clamp_channel_res_25632;\n        int32_t unsign_arg0_25636 = fptoui_f32_i32(f32_arg0_25635);\n        int32_t from_rgba_res_25637 = zb_lhs_25630 | unsign_arg0_25636;\n        \n        ((__global int32_t *) mem_26104)[gtid_25575 * width_20367 + gtid_25576] = from_rgba_res_25637;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_25572\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_25642, 1, 1)))\n__kernel void renderzisegmap_25667(__global int *global_failure, float screen_calculations_20357, float screen_calculations_20358, float screen_calculations_20359, float screen_calculations_20360, float screen_calculations_20362, float screen_calculations_20363, int64_t r_22371, __global unsigned char *ext_mem_26059, __global unsigned char *ext_mem_26060, __global unsigned char *mem_26069, __global unsigned char *mem_26072)\n{\n    #define segmap_group_sizze_25662 (renderzisegmap_group_sizze_25642)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26505;\n    int64_t group_sizze_26508;\n    int32_t wave_sizze_26507;\n    int32_t group_tid_26506;\n    \n    local_tid_26505 = get_local_id(0);\n    group_sizze_26508 = get_local_size(0);\n    wave_sizze_26507 = LOCKSTEP_WIDTH;\n    group_tid_26506 = get_group_id(0);\n    \n    int32_t global_tid_26504 = group_tid_26506 * group_sizze_26508 + local_tid_26505;\n    int32_t phys_tid_25667 = global_tid_26504;\n    int64_t global_tid_26509 = sext_i32_i64(group_tid_26506) * segmap_group_sizze_25662 + sext_i32_i64(local_tid_26505);\n    int64_t slice_26510 = r_22371;\n    int64_t gtid_25666 = global_tid_26509;\n    int64_t remnant_26511 = global_tid_26509 - gtid_25666;\n    \n    if (slt64(gtid_25666, r_", "22371)) {\n        int64_t eta_p_25668 = ((__global int64_t *) ext_mem_26060)[gtid_25666];\n        int64_t eta_p_25669 = ((__global int64_t *) ext_mem_26059)[gtid_25666];\n        float i64_res_25670 = sitofp_i64_f32(eta_p_25668);\n        float i64_res_25671 = sitofp_i64_f32(eta_p_25669);\n        float zt_res_25672 = screen_calculations_20362 * i64_res_25671;\n        float zt_res_25673 = screen_calculations_20362 * i64_res_25670;\n        float zm_res_25674 = zt_res_25672 - screen_calculations_20357;\n        float zm_res_25675 = zt_res_25673 - screen_calculations_20358;\n        float zt_res_25676 = screen_calculations_20363 * zm_res_25674;\n        float zt_res_25677 = screen_calculations_20363 * zm_res_25675;\n        float zp_res_25678 = screen_calculations_20359 + zt_res_25676;\n        float zp_res_25679 = screen_calculations_20360 + zt_res_25677;\n        int64_t f32_res_25680 = fptosi_f32_i64(zp_res_25679);\n        int64_t f32_res_25681 = fptosi_f32_i64(zp_res_25678);\n        \n        ((__global int64_t *) mem_26069)[gtid_25666] = f32_res_25680;\n        ((__global int64_t *) mem_26072)[gtid_25666] = f32_res_25681;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_25662\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_25685, 1, 1)))\n__kernel void renderzisegmap_25683(__global int *global_failure, int64_t height_20354, int64_t width_20367, int64_t r_22371, __global unsigned char *ext_mem_26061, __global unsigned char *mem_26065, __global unsigned char *mem_26069, __global unsigned char *mem_26072)\n{\n    #define segmap_group_sizze_25686 (renderzisegmap_group_sizze_25685)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26514;\n    int64_t group_sizze_26517;\n    int32_t wave_sizze_26516;\n    int32_t group_tid_26515;\n    \n    local_tid_26514 = get_local_id(0);\n    group_sizze_26517 = get_local_size(0);\n    wave_sizze_2651", "6 = LOCKSTEP_WIDTH;\n    group_tid_26515 = get_group_id(0);\n    \n    int32_t global_tid_26513 = group_tid_26515 * group_sizze_26517 + local_tid_26514;\n    int32_t phys_tid_25683 = global_tid_26513;\n    int64_t global_tid_26518 = sext_i32_i64(group_tid_26515) * segmap_group_sizze_25686 + sext_i32_i64(local_tid_26514);\n    int64_t slice_26519 = r_22371;\n    int64_t write_i_25682 = global_tid_26518;\n    int64_t remnant_26520 = global_tid_26518 - write_i_25682;\n    \n    if (slt64(write_i_25682, r_22371)) {\n        int64_t write_index_22559 = ((__global int64_t *) mem_26069)[write_i_25682];\n        int64_t write_index_22560 = ((__global int64_t *) mem_26072)[write_i_25682];\n        float write_value_22561 = ((__global float *) ext_mem_26061)[write_i_25682];\n        \n        if ((sle64((int64_t) 0, write_index_22559) && slt64(write_index_22559, height_20354)) && (sle64((int64_t) 0, write_index_22560) && slt64(write_index_22560, width_20367))) {\n            ((__global float *) mem_26065)[write_index_22559 * width_20367 + write_index_22560] = write_value_22561;\n        }\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_25686\n}\n__attribute__((reqd_work_group_size(renderzisegmap_group_sizze_25701, 1, 1)))\n__kernel void renderzisegmap_25770(__global int *global_failure, int64_t height_20354, int64_t width_20367, __global unsigned char *mem_26065, __global unsigned char *mem_26078)\n{\n    #define segmap_group_sizze_25765 (renderzisegmap_group_sizze_25701)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26523;\n    int64_t group_sizze_26526;\n    int32_t wave_sizze_26525;\n    int32_t group_tid_26524;\n    \n    local_tid_26523 = get_local_id(0);\n    group_sizze_26526 = get_local_size(0);\n    wave_sizze_26525 = LOCKSTEP_WIDTH;\n    group_tid_26524 = get_group_id(0);\n    \n    int32_t global_tid_26522 = group_tid_26524 * group_sizze_26526 + local_tid_",
                                       "26523;\n    int32_t phys_tid_25770 = global_tid_26522;\n    int64_t global_tid_26527 = sext_i32_i64(group_tid_26524) * segmap_group_sizze_25765 + sext_i32_i64(local_tid_26523);\n    int64_t slice_26528 = width_20367;\n    int64_t slice_26529 = height_20354 * slice_26528;\n    int64_t gtid_25768 = squot64(global_tid_26527, slice_26528);\n    int64_t remnant_26530 = global_tid_26527 - gtid_25768 * slice_26528;\n    int64_t gtid_25769 = remnant_26530;\n    int64_t remnant_26531 = remnant_26530 - gtid_25769;\n    \n    if (slt64(gtid_25768, height_20354) && slt64(gtid_25769, width_20367)) {\n        float eta_p_25771 = ((__global float *) mem_26065)[gtid_25768 * width_20367 + gtid_25769];\n        bool cond_25772 = eta_p_25771 < 0.0F;\n        float clamp_channel_res_25773;\n        \n        if (cond_25772 == 1) {\n            clamp_channel_res_25773 = 0.0F;\n        } else {\n            bool cond_25774 = 1.0F < eta_p_25771;\n            float clamp_channel_res_f_res_25775;\n            \n            if (cond_25774 == 1) {\n                clamp_channel_res_f_res_25775 = 1.0F;\n            } else {\n                clamp_channel_res_f_res_25775 = eta_p_25771;\n            }\n            clamp_channel_res_25773 = clamp_channel_res_f_res_25775;\n        }\n        \n        float f32_arg0_25776 = 255.0F * clamp_channel_res_25773;\n        int32_t unsign_arg0_25777 = fptoui_f32_i32(f32_arg0_25776);\n        int32_t zb_rhs_25778 = shl32(unsign_arg0_25777, 16);\n        int32_t zb_lhs_25779 = -16777216 | zb_rhs_25778;\n        float clamp_channel_res_25780;\n        \n        if (cond_25772 == 1) {\n            clamp_channel_res_25780 = 0.0F;\n        } else {\n            bool cond_25781 = 1.0F < eta_p_25771;\n            float clamp_channel_res_f_res_25782;\n            \n            if (cond_25781 == 1) {\n                clamp_channel_res_f_res_25782 = 1.0F;\n            } else {\n                clamp_channel_res_f_res_25782 = eta_p_25771;\n            }\n            clamp_channel_res_25780 = clamp_channel_res_f_", "res_25782;\n        }\n        \n        float f32_arg0_25783 = 255.0F * clamp_channel_res_25780;\n        int32_t unsign_arg0_25784 = fptoui_f32_i32(f32_arg0_25783);\n        int32_t zb_rhs_25785 = shl32(unsign_arg0_25784, 8);\n        int32_t zb_lhs_25786 = zb_lhs_25779 | zb_rhs_25785;\n        float clamp_channel_res_25787;\n        \n        if (cond_25772 == 1) {\n            clamp_channel_res_25787 = 0.0F;\n        } else {\n            bool cond_25788 = 1.0F < eta_p_25771;\n            float clamp_channel_res_f_res_25789;\n            \n            if (cond_25788 == 1) {\n                clamp_channel_res_f_res_25789 = 1.0F;\n            } else {\n                clamp_channel_res_f_res_25789 = eta_p_25771;\n            }\n            clamp_channel_res_25787 = clamp_channel_res_f_res_25789;\n        }\n        \n        float f32_arg0_25790 = 255.0F * clamp_channel_res_25787;\n        int32_t unsign_arg0_25791 = fptoui_f32_i32(f32_arg0_25790);\n        int32_t from_rgba_res_25792 = zb_lhs_25786 | unsign_arg0_25791;\n        \n        ((__global int32_t *) mem_26078)[gtid_25768 * width_20367 + gtid_25769] = from_rgba_res_25792;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_25765\n}\n__attribute__((reqd_work_group_size(renderzisegred_group_sizze_24772, 1, 1)))\n__kernel void renderzisegred_large_24912(__global int *global_failure, __local volatile int64_t *sync_arr_mem_26289_backing_aligned_0, __local volatile int64_t *red_arr_mem_26287_backing_aligned_1, int64_t loop_dz2083Uz2086U_22380, int64_t num_groups_24906, int64_t groups_per_segment_26253, int64_t elements_per_thread_26254, int64_t virt_num_groups_26255, int64_t threads_per_segment_26257, __global unsigned char *mem_25892, __global unsigned char *mem_25895, __global unsigned char *mem_25905, __global unsigned char *mem_25909, __global unsigned char *segred_tmp_mem_26258, __global unsigned char *counters_mem_26260)\n{\n    #define segred_group_sizze_24905 (renderzisegred_group_sizze_24772)\n    \n    const int block_dim", "0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict sync_arr_mem_26289_backing_1 = (__local volatile unsigned char *) sync_arr_mem_26289_backing_aligned_0;\n    __local volatile unsigned char *restrict red_arr_mem_26287_backing_0 = (__local volatile unsigned char *) red_arr_mem_26287_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26283;\n    int64_t group_sizze_26286;\n    int32_t wave_sizze_26285;\n    int32_t group_tid_26284;\n    \n    local_tid_26283 = get_local_id(0);\n    group_sizze_26286 = get_local_size(0);\n    wave_sizze_26285 = LOCKSTEP_WIDTH;\n    group_tid_26284 = get_group_id(0);\n    \n    int32_t global_tid_26282 = group_tid_26284 * group_sizze_26286 + local_tid_26283;\n    int32_t phys_tid_24912 = global_tid_26282;\n    __local unsigned char *red_arr_mem_26287;\n    \n    red_arr_mem_26287 = (__local unsigned char *) red_arr_mem_26287_backing_0;\n    \n    __local unsigned char *sync_arr_mem_26289;\n    \n    sync_arr_mem_26289 = (__local unsigned char *) sync_arr_mem_26289_backing_1;\n    \n    int32_t phys_group_id_26291;\n    \n    phys_group_id_26291 = get_group_id(0);\n    \n    int32_t iterations_26292 = sdiv_up32(sext_i64_i32(virt_num_groups_26255) - phys_group_id_26291, sext_i64_i32(num_groups_24906));\n    \n    for (int32_t i_26293 = 0; i_26293 < iterations_26292; i_26293++) {\n        int32_t virt_group_id_26294 = phys_group_id_26291 + i_26293 * sext_i64_i32(num_groups_24906);\n        int32_t flat_segment_id_26295 = squot32(virt_group_id_26294, sext_i64_i32(groups_per_segment_26253));\n        int64_t global_tid_26296 = srem64(sext_i32_i64(virt_group_id_26294) * segred_group_sizze_24905 + sext_i32_i64(local_tid_26283), segred_group_sizze_24905 * groups_per_segment_26253);\n        int64_t slice_26297 = loop_dz2083Uz2086U_22380;\n        int64_t gtid_24910 = sext_i32_i64(flat_segment_id_26295);\n        int64_t remnant_26298 = sext_i32_i64(flat_segment_id_26295)",
                                       " - gtid_24910;\n        int64_t gtid_24911;\n        float eta_p_acc_26299;\n        int64_t chunk_sizze_26300 = smin64(elements_per_thread_26254, sdiv_up64((int64_t) 4 - global_tid_26296, threads_per_segment_26257));\n        float eta_p_24913;\n        float eta_p_24914;\n        \n        // neutral-initialise the accumulators\n        {\n            eta_p_acc_26299 = 0.0F;\n        }\n        for (int64_t i_26304 = 0; i_26304 < chunk_sizze_26300; i_26304++) {\n            gtid_24911 = global_tid_26296 + threads_per_segment_26257 * i_26304;\n            // apply map function\n            {\n                float tzq_24916 = ((__global float *) mem_25892)[gtid_24910];\n                float eta_p_24918 = ((__global float *) mem_25895)[gtid_24911 * loop_dz2083Uz2086U_22380 + gtid_24910];\n                float lifted_lambda_res_24919 = tzq_24916 + eta_p_24918;\n                \n                // save map-out results\n                {\n                    ((__global float *) mem_25909)[gtid_24910 * (int64_t) 4 + gtid_24911] = lifted_lambda_res_24919;\n                }\n                // load accumulator\n                {\n                    eta_p_24913 = eta_p_acc_26299;\n                }\n                // load new values\n                {\n                    eta_p_24914 = lifted_lambda_res_24919;\n                }\n                // apply reduction operator\n                {\n                    float defunc_0_op_res_24915 = eta_p_24913 + eta_p_24914;\n                    \n                    // store in accumulator\n                    {\n                        eta_p_acc_26299 = defunc_0_op_res_24915;\n                    }\n                }\n            }\n        }\n        // to reduce current chunk, first store our result in memory\n        {\n            eta_p_24913 = eta_p_acc_26299;\n            ((__local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283)] = eta_p_24913;\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        int32_t offset_26305;\n        int32_t skip", "_waves_26306 = 1;\n        float eta_p_26301;\n        float eta_p_26302;\n        \n        offset_26305 = 0;\n        // participating threads read initial accumulator\n        {\n            if (slt32(local_tid_26283, sext_i64_i32(segred_group_sizze_24905))) {\n                eta_p_26301 = ((__local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283 + offset_26305)];\n            }\n        }\n        offset_26305 = 1;\n        while (slt32(offset_26305, wave_sizze_26285)) {\n            if (slt32(local_tid_26283 + offset_26305, sext_i64_i32(segred_group_sizze_24905)) && ((local_tid_26283 - squot32(local_tid_26283, wave_sizze_26285) * wave_sizze_26285) & (2 * offset_26305 - 1)) == 0) {\n                // read array element\n                {\n                    eta_p_26302 = ((volatile __local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283 + offset_26305)];\n                }\n                // apply reduction operation\n                {\n                    float defunc_0_op_res_26303 = eta_p_26301 + eta_p_26302;\n                    \n                    eta_p_26301 = defunc_0_op_res_26303;\n                }\n                // write result of operation\n                {\n                    ((volatile __local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283)] = eta_p_26301;\n                }\n            }\n            offset_26305 *= 2;\n        }\n        while (slt32(skip_waves_26306, squot32(sext_i64_i32(segred_group_sizze_24905) + wave_sizze_26285 - 1, wave_sizze_26285))) {\n            barrier(CLK_LOCAL_MEM_FENCE);\n            offset_26305 = skip_waves_26306 * wave_sizze_26285;\n            if (slt32(local_tid_26283 + offset_26305, sext_i64_i32(segred_group_sizze_24905)) && ((local_tid_26283 - squot32(local_tid_26283, wave_sizze_26285) * wave_sizze_26285) == 0 && (squot32(local_tid_26283, wave_sizze_26285) & (2 * skip_waves_26306 - 1)) == 0)) {\n                // read array element\n                {\n                    eta_p_26302 = ((__local float *) red", "_arr_mem_26287)[sext_i32_i64(local_tid_26283 + offset_26305)];\n                }\n                // apply reduction operation\n                {\n                    float defunc_0_op_res_26303 = eta_p_26301 + eta_p_26302;\n                    \n                    eta_p_26301 = defunc_0_op_res_26303;\n                }\n                // write result of operation\n                {\n                    ((__local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283)] = eta_p_26301;\n                }\n            }\n            skip_waves_26306 *= 2;\n        }\n        // Copy array-typed operands to result array\n        {\n            barrier(CLK_LOCAL_MEM_FENCE);\n            if (local_tid_26283 == 0) { }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // first thread saves the result in accumulator\n        {\n            if (sext_i32_i64(local_tid_26283) == (int64_t) 0) {\n                eta_p_acc_26299 = eta_p_26301;\n            }\n        }\n        if (groups_per_segment_26253 == (int64_t) 1) {\n            // first thread in group saves final result to memory\n            {\n                if (local_tid_26283 == 0) {\n                    ((__global float *) mem_25905)[gtid_24910] = eta_p_acc_26299;\n                }\n            }\n        } else {\n            int32_t old_counter_26307;\n            \n            // first thread in group saves group result to global memory\n            {\n                if (local_tid_26283 == 0) {\n                    ((__global float *) segred_tmp_mem_26258)[sext_i32_i64(virt_group_id_26294)] = eta_p_acc_26299;\n                    mem_fence_global();\n                    old_counter_26307 = atomic_add_i32_global(&((volatile __global int *) counters_mem_26260)[sext_i32_i64(srem32(flat_segment_id_26295, 10240))], (int) 1);\n                    ((__local bool *) sync_arr_mem_26289)[(int64_t) 0] = old_counter_26307 == groups_per_segment_26253 - (int64_t) 1;\n                }\n            }\n            barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_ME",
                                       "M_FENCE);\n            \n            bool is_last_group_26308 = ((__local bool *) sync_arr_mem_26289)[(int64_t) 0];\n            \n            if (is_last_group_26308) {\n                if (local_tid_26283 == 0) {\n                    old_counter_26307 = atomic_add_i32_global(&((volatile __global int *) counters_mem_26260)[sext_i32_i64(srem32(flat_segment_id_26295, 10240))], (int) ((int64_t) 0 - groups_per_segment_26253));\n                }\n                // read in the per-group-results\n                {\n                    int64_t read_per_thread_26309 = sdiv_up64(groups_per_segment_26253, segred_group_sizze_24905);\n                    \n                    eta_p_24913 = 0.0F;\n                    for (int64_t i_26310 = 0; i_26310 < read_per_thread_26309; i_26310++) {\n                        int64_t group_res_id_26311 = sext_i32_i64(local_tid_26283) * read_per_thread_26309 + i_26310;\n                        int64_t index_of_group_res_26312 = sext_i32_i64(flat_segment_id_26295) * groups_per_segment_26253 + group_res_id_26311;\n                        \n                        if (slt64(group_res_id_26311, groups_per_segment_26253)) {\n                            eta_p_24914 = ((__global float *) segred_tmp_mem_26258)[index_of_group_res_26312];\n                            \n                            float defunc_0_op_res_24915 = eta_p_24913 + eta_p_24914;\n                            \n                            eta_p_24913 = defunc_0_op_res_24915;\n                        }\n                    }\n                }\n                ((__local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283)] = eta_p_24913;\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // reduce the per-group results\n                {\n                    int32_t offset_26313;\n                    int32_t skip_waves_26314 = 1;\n                    float eta_p_26301;\n                    float eta_p_26302;\n                    \n                    offset_26313 = 0;\n                    // partic", "ipating threads read initial accumulator\n                    {\n                        if (slt32(local_tid_26283, sext_i64_i32(segred_group_sizze_24905))) {\n                            eta_p_26301 = ((__local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283 + offset_26313)];\n                        }\n                    }\n                    offset_26313 = 1;\n                    while (slt32(offset_26313, wave_sizze_26285)) {\n                        if (slt32(local_tid_26283 + offset_26313, sext_i64_i32(segred_group_sizze_24905)) && ((local_tid_26283 - squot32(local_tid_26283, wave_sizze_26285) * wave_sizze_26285) & (2 * offset_26313 - 1)) == 0) {\n                            // read array element\n                            {\n                                eta_p_26302 = ((volatile __local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283 + offset_26313)];\n                            }\n                            // apply reduction operation\n                            {\n                                float defunc_0_op_res_26303 = eta_p_26301 + eta_p_26302;\n                                \n                                eta_p_26301 = defunc_0_op_res_26303;\n                            }\n                            // write result of operation\n                            {\n                                ((volatile __local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283)] = eta_p_26301;\n                            }\n                        }\n                        offset_26313 *= 2;\n                    }\n                    while (slt32(skip_waves_26314, squot32(sext_i64_i32(segred_group_sizze_24905) + wave_sizze_26285 - 1, wave_sizze_26285))) {\n                        barrier(CLK_LOCAL_MEM_FENCE);\n                        offset_26313 = skip_waves_26314 * wave_sizze_26285;\n                        if (slt32(local_tid_26283 + offset_26313, sext_i64_i32(segred_group_sizze_24905)) && ((local_tid_26283 - squot32(local_tid_26283, wave_sizze_26285)", " * wave_sizze_26285) == 0 && (squot32(local_tid_26283, wave_sizze_26285) & (2 * skip_waves_26314 - 1)) == 0)) {\n                            // read array element\n                            {\n                                eta_p_26302 = ((__local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283 + offset_26313)];\n                            }\n                            // apply reduction operation\n                            {\n                                float defunc_0_op_res_26303 = eta_p_26301 + eta_p_26302;\n                                \n                                eta_p_26301 = defunc_0_op_res_26303;\n                            }\n                            // write result of operation\n                            {\n                                ((__local float *) red_arr_mem_26287)[sext_i32_i64(local_tid_26283)] = eta_p_26301;\n                            }\n                        }\n                        skip_waves_26314 *= 2;\n                    }\n                    // Copy array-typed operands to result array\n                    {\n                        barrier(CLK_LOCAL_MEM_FENCE);\n                        if (local_tid_26283 == 0) { }\n                    }\n                    // and back to memory with the final result\n                    {\n                        if (local_tid_26283 == 0) {\n                            ((__global float *) mem_25905)[gtid_24910] = eta_p_26301;\n                        }\n                    }\n                }\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_2:\n    return;\n    #undef segred_group_sizze_24905\n}\n__attribute__((reqd_work_group_size(renderzisegred_group_sizze_24772, 1, 1)))\n__kernel void renderzisegred_small_24912(__global int *global_failure, __local volatile int64_t *red_arr_mem_26232_backing_aligned_0, int64_t loop_dz2083Uz2086U_22380, int64_t num_groups_24906, int64_t segment_sizze_nonzzero_26225, __global unsigned char *mem_25892, __",
                                       "global unsigned char *mem_25895, __global unsigned char *mem_25905, __global unsigned char *mem_25909)\n{\n    #define segred_group_sizze_24905 (renderzisegred_group_sizze_24772)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict red_arr_mem_26232_backing_0 = (__local volatile unsigned char *) red_arr_mem_26232_backing_aligned_0;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t local_tid_26228;\n    int64_t group_sizze_26231;\n    int32_t wave_sizze_26230;\n    int32_t group_tid_26229;\n    \n    local_tid_26228 = get_local_id(0);\n    group_sizze_26231 = get_local_size(0);\n    wave_sizze_26230 = LOCKSTEP_WIDTH;\n    group_tid_26229 = get_group_id(0);\n    \n    int32_t global_tid_26227 = group_tid_26229 * group_sizze_26231 + local_tid_26228;\n    int32_t phys_tid_24912 = global_tid_26227;\n    __local unsigned char *red_arr_mem_26232;\n    \n    red_arr_mem_26232 = (__local unsigned char *) red_arr_mem_26232_backing_0;\n    \n    int32_t phys_group_id_26234;\n    \n    phys_group_id_26234 = get_group_id(0);\n    \n    int32_t iterations_26235 = sdiv_up32(sext_i64_i32(sdiv_up64(loop_dz2083Uz2086U_22380, squot64(segred_group_sizze_24905, segment_sizze_nonzzero_26225))) - phys_group_id_26234, sext_i64_i32(num_groups_24906));\n    \n    for (int32_t i_26236 = 0; i_26236 < iterations_26235; i_26236++) {\n        int32_t virt_group_id_26237 = phys_group_id_26234 + i_26236 * sext_i64_i32(num_groups_24906);\n        int64_t slice_26238 = loop_dz2083Uz2086U_22380;\n        int64_t gtid_24910 = squot64(sext_i32_i64(local_tid_26228), segment_sizze_nonzzero_26225) + sext_i32_i64(virt_group_id_26237) * squot64(segred_group_sizze_24905, segment_sizze_nonzzero_26225);\n        int64_t remnant_26239 = squot64(sext_i32_i64(local_tid_26228), segment_sizze_nonzzero_26225) + sext_i32_i64(virt_group_id_26237) * squot64(segred_group_sizze_24905, segment_sizze_nonzzero_26225) - gtid_24910;\n        int64_t gt", "id_24911 = srem64(sext_i32_i64(local_tid_26228), (int64_t) 4);\n        \n        // apply map function if in bounds\n        {\n            if (slt64((int64_t) 0, (int64_t) 4) && (slt64(gtid_24910, loop_dz2083Uz2086U_22380) && slt64(sext_i32_i64(local_tid_26228), (int64_t) 4 * squot64(segred_group_sizze_24905, segment_sizze_nonzzero_26225)))) {\n                float tzq_24916 = ((__global float *) mem_25892)[gtid_24910];\n                float eta_p_24918 = ((__global float *) mem_25895)[gtid_24911 * loop_dz2083Uz2086U_22380 + gtid_24910];\n                float lifted_lambda_res_24919 = tzq_24916 + eta_p_24918;\n                \n                // save map-out results\n                {\n                    ((__global float *) mem_25909)[gtid_24910 * (int64_t) 4 + gtid_24911] = lifted_lambda_res_24919;\n                }\n                // save results to be reduced\n                {\n                    ((__local float *) red_arr_mem_26232)[sext_i32_i64(local_tid_26228)] = lifted_lambda_res_24919;\n                }\n            } else {\n                ((__local float *) red_arr_mem_26232)[sext_i32_i64(local_tid_26228)] = 0.0F;\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        if (slt64((int64_t) 0, (int64_t) 4)) {\n            // perform segmented scan to imitate reduction\n            {\n                float eta_p_24913;\n                float eta_p_24914;\n                float eta_p_26240;\n                float eta_p_26241;\n                bool ltid_in_bounds_26243 = slt64(sext_i32_i64(local_tid_26228), (int64_t) 4 * squot64(segred_group_sizze_24905, segment_sizze_nonzzero_26225));\n                int32_t skip_threads_26244;\n                \n                // read input for in-block scan\n                {\n                    if (ltid_in_bounds_26243) {\n                        eta_p_24914 = ((volatile __local float *) red_arr_mem_26232)[sext_i32_i64(local_tid_26228)];\n                        if ((local_tid_26228 - squot32(local_tid_26228, 32) * 32) == 0) ", "{\n                            eta_p_24913 = eta_p_24914;\n                        }\n                    }\n                }\n                // in-block scan (hopefully no barriers needed)\n                {\n                    skip_threads_26244 = 1;\n                    while (slt32(skip_threads_26244, 32)) {\n                        bool thread_active_26245 = sle32(skip_threads_26244, local_tid_26228 - squot32(local_tid_26228, 32) * 32) && ltid_in_bounds_26243;\n                        \n                        if (thread_active_26245) {\n                            // read operands\n                            {\n                                eta_p_24913 = ((volatile __local float *) red_arr_mem_26232)[sext_i32_i64(local_tid_26228) - sext_i32_i64(skip_threads_26244)];\n                            }\n                        }\n                        // perform operation\n                        {\n                            bool inactive_26246 = slt64(srem64(sext_i32_i64(local_tid_26228), (int64_t) 4), sext_i32_i64(local_tid_26228) - sext_i32_i64(local_tid_26228 - skip_threads_26244));\n                            \n                            if (thread_active_26245 && inactive_26246) {\n                                eta_p_24913 = eta_p_24914;\n                            }\n                            if (thread_active_26245) {\n                                if (!inactive_26246) {\n                                    float defunc_0_op_res_24915 = eta_p_24913 + eta_p_24914;\n                                    \n                                    eta_p_24913 = defunc_0_op_res_24915;\n                                }\n                            }\n                        }\n                        if (sle32(wave_sizze_26230, skip_threads_26244)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        if (thread_active_26245) {\n                            // write result\n                            {\n                           ",
                                       "     ((volatile __local float *) red_arr_mem_26232)[sext_i32_i64(local_tid_26228)] = eta_p_24913;\n                                eta_p_24914 = eta_p_24913;\n                            }\n                        }\n                        if (sle32(wave_sizze_26230, skip_threads_26244)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        skip_threads_26244 *= 2;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // last thread of block 'i' writes its result to offset 'i'\n                {\n                    if ((local_tid_26228 - squot32(local_tid_26228, 32) * 32) == 31 && ltid_in_bounds_26243) {\n                        ((volatile __local float *) red_arr_mem_26232)[sext_i32_i64(squot32(local_tid_26228, 32))] = eta_p_24913;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // scan the first block, after which offset 'i' contains carry-in for block 'i+1'\n                {\n                    int32_t skip_threads_26247;\n                    \n                    // read input for in-block scan\n                    {\n                        if (squot32(local_tid_26228, 32) == 0 && ltid_in_bounds_26243) {\n                            eta_p_26241 = ((volatile __local float *) red_arr_mem_26232)[sext_i32_i64(local_tid_26228)];\n                            if ((local_tid_26228 - squot32(local_tid_26228, 32) * 32) == 0) {\n                                eta_p_26240 = eta_p_26241;\n                            }\n                        }\n                    }\n                    // in-block scan (hopefully no barriers needed)\n                    {\n                        skip_threads_26247 = 1;\n                        while (slt32(skip_threads_26247, 32)) {\n                            bool thread_active_26248 = sle32(skip_threads_26247, local_tid_26228 - squot32(local_tid_26228, 32) * 32) && (squot32(local_tid_26228, 32) == ", "0 && ltid_in_bounds_26243);\n                            \n                            if (thread_active_26248) {\n                                // read operands\n                                {\n                                    eta_p_26240 = ((volatile __local float *) red_arr_mem_26232)[sext_i32_i64(local_tid_26228) - sext_i32_i64(skip_threads_26247)];\n                                }\n                            }\n                            // perform operation\n                            {\n                                bool inactive_26249 = slt64(srem64(sext_i32_i64(local_tid_26228 * 32 + 32 - 1), (int64_t) 4), sext_i32_i64(local_tid_26228 * 32 + 32 - 1) - sext_i32_i64((local_tid_26228 - skip_threads_26247) * 32 + 32 - 1));\n                                \n                                if (thread_active_26248 && inactive_26249) {\n                                    eta_p_26240 = eta_p_26241;\n                                }\n                                if (thread_active_26248) {\n                                    if (!inactive_26249) {\n                                        float defunc_0_op_res_26242 = eta_p_26240 + eta_p_26241;\n                                        \n                                        eta_p_26240 = defunc_0_op_res_26242;\n                                    }\n                                }\n                            }\n                            if (sle32(wave_sizze_26230, skip_threads_26247)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            if (thread_active_26248) {\n                                // write result\n                                {\n                                    ((volatile __local float *) red_arr_mem_26232)[sext_i32_i64(local_tid_26228)] = eta_p_26240;\n                                    eta_p_26241 = eta_p_26240;\n                                }\n                            }\n                            if (sle32(wave_sizze_26", "230, skip_threads_26247)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            skip_threads_26247 *= 2;\n                        }\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                \n                bool no_carry_in_26250 = squot32(local_tid_26228, 32) == 0 || !ltid_in_bounds_26243;\n                \n                // carry-in for every block except the first\n                {\n                    // read operands\n                    {\n                        if (!no_carry_in_26250) {\n                            eta_p_24914 = eta_p_24913;\n                            eta_p_24913 = ((__local float *) red_arr_mem_26232)[sext_i32_i64(squot32(local_tid_26228, 32)) - (int64_t) 1];\n                        }\n                    }\n                    // perform operation\n                    {\n                        bool inactive_26251 = slt64(srem64(sext_i32_i64(local_tid_26228), (int64_t) 4), sext_i32_i64(local_tid_26228) - sext_i32_i64(squot32(local_tid_26228, 32) * 32 - 1));\n                        \n                        if (!no_carry_in_26250) {\n                            if (inactive_26251) {\n                                eta_p_24913 = eta_p_24914;\n                            }\n                        }\n                        if (!no_carry_in_26250) {\n                            if (!inactive_26251) {\n                                float defunc_0_op_res_24915 = eta_p_24913 + eta_p_24914;\n                                \n                                eta_p_24913 = defunc_0_op_res_24915;\n                            }\n                        }\n                    }\n                    // write final result\n                    {\n                        if (!no_carry_in_26250) {\n                            ((__local float *) red_arr_mem_26232)[sext_i32_i64(local_tid_26228)] = eta_p_24913;\n                        }\n                    }\n             ", "   }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // restore correct values for first block\n                {\n                    if (squot32(local_tid_26228, 32) == 0 && ltid_in_bounds_26243) {\n                        ((__local float *) red_arr_mem_26232)[sext_i32_i64(local_tid_26228)] = eta_p_24914;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // save final values of segments\n        {\n            if (slt64(sext_i32_i64(virt_group_id_26237) * squot64(segred_group_sizze_24905, segment_sizze_nonzzero_26225) + sext_i32_i64(local_tid_26228), loop_dz2083Uz2086U_22380) && slt64(sext_i32_i64(local_tid_26228), squot64(segred_group_sizze_24905, segment_sizze_nonzzero_26225))) {\n                float tmp_26252 = ((__local float *) red_arr_mem_26232)[(sext_i32_i64(local_tid_26228) + (int64_t) 1) * segment_sizze_nonzzero_26225 - (int64_t) 1];\n                \n                ((__global float *) mem_25905)[sext_i32_i64(virt_group_id_26237) * squot64(segred_group_sizze_24905, segment_sizze_nonzzero_26225) + sext_i32_i64(local_tid_26228)] = tmp_26252;\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_2:\n    return;\n    #undef segred_group_sizze_24905\n}\n", NULL};
// Start of backends/opencl.h

// Forward declarations.
struct opencl_device_option;
// Invoked by setup_opencl() after the platform and device has been
// found, but before the program is loaded.  Its intended use is to
// tune constants based on the selected platform and device.
static void post_opencl_setup(struct futhark_context*, struct opencl_device_option*);
static void set_tuning_params(struct futhark_context* ctx);
static char* get_failure_msg(int failure_idx, int64_t args[]);

#define OPENCL_SUCCEED_FATAL(e) opencl_succeed_fatal(e, #e, __FILE__, __LINE__)
#define OPENCL_SUCCEED_NONFATAL(e) opencl_succeed_nonfatal(e, #e, __FILE__, __LINE__)
// Take care not to override an existing error.
#define OPENCL_SUCCEED_OR_RETURN(e) {           \
    char *serror = OPENCL_SUCCEED_NONFATAL(e);  \
    if (serror) {                               \
      if (!ctx->error) {                        \
        ctx->error = serror;                    \
        return bad;                             \
      } else {                                  \
        free(serror);                           \
      }                                         \
    }                                           \
  }

// OPENCL_SUCCEED_OR_RETURN returns the value of the variable 'bad' in
// scope.  By default, it will be this one.  Create a local variable
// of some other type if needed.  This is a bit of a hack, but it
// saves effort in the code generator.
static const int bad = 1;

static const char* opencl_error_string(cl_int err) {
  switch (err) {
  case CL_SUCCESS:                            return "Success!";
  case CL_DEVICE_NOT_FOUND:                   return "Device not found.";
  case CL_DEVICE_NOT_AVAILABLE:               return "Device not available";
  case CL_COMPILER_NOT_AVAILABLE:             return "Compiler not available";
  case CL_MEM_OBJECT_ALLOCATION_FAILURE:      return "Memory object allocation failure";
  case CL_OUT_OF_RESOURCES:                   return "Out of resources";
  case CL_OUT_OF_HOST_MEMORY:                 return "Out of host memory";
  case CL_PROFILING_INFO_NOT_AVAILABLE:       return "Profiling information not available";
  case CL_MEM_COPY_OVERLAP:                   return "Memory copy overlap";
  case CL_IMAGE_FORMAT_MISMATCH:              return "Image format mismatch";
  case CL_IMAGE_FORMAT_NOT_SUPPORTED:         return "Image format not supported";
  case CL_BUILD_PROGRAM_FAILURE:              return "Program build failure";
  case CL_MAP_FAILURE:                        return "Map failure";
  case CL_INVALID_VALUE:                      return "Invalid value";
  case CL_INVALID_DEVICE_TYPE:                return "Invalid device type";
  case CL_INVALID_PLATFORM:                   return "Invalid platform";
  case CL_INVALID_DEVICE:                     return "Invalid device";
  case CL_INVALID_CONTEXT:                    return "Invalid context";
  case CL_INVALID_QUEUE_PROPERTIES:           return "Invalid queue properties";
  case CL_INVALID_COMMAND_QUEUE:              return "Invalid command queue";
  case CL_INVALID_HOST_PTR:                   return "Invalid host pointer";
  case CL_INVALID_MEM_OBJECT:                 return "Invalid memory object";
  case CL_INVALID_IMAGE_FORMAT_DESCRIPTOR:    return "Invalid image format descriptor";
  case CL_INVALID_IMAGE_SIZE:                 return "Invalid image size";
  case CL_INVALID_SAMPLER:                    return "Invalid sampler";
  case CL_INVALID_BINARY:                     return "Invalid binary";
  case CL_INVALID_BUILD_OPTIONS:              return "Invalid build options";
  case CL_INVALID_PROGRAM:                    return "Invalid program";
  case CL_INVALID_PROGRAM_EXECUTABLE:         return "Invalid program executable";
  case CL_INVALID_KERNEL_NAME:                return "Invalid kernel name";
  case CL_INVALID_KERNEL_DEFINITION:          return "Invalid kernel definition";
  case CL_INVALID_KERNEL:                     return "Invalid kernel";
  case CL_INVALID_ARG_INDEX:                  return "Invalid argument index";
  case CL_INVALID_ARG_VALUE:                  return "Invalid argument value";
  case CL_INVALID_ARG_SIZE:                   return "Invalid argument size";
  case CL_INVALID_KERNEL_ARGS:                return "Invalid kernel arguments";
  case CL_INVALID_WORK_DIMENSION:             return "Invalid work dimension";
  case CL_INVALID_WORK_GROUP_SIZE:            return "Invalid work group size";
  case CL_INVALID_WORK_ITEM_SIZE:             return "Invalid work item size";
  case CL_INVALID_GLOBAL_OFFSET:              return "Invalid global offset";
  case CL_INVALID_EVENT_WAIT_LIST:            return "Invalid event wait list";
  case CL_INVALID_EVENT:                      return "Invalid event";
  case CL_INVALID_OPERATION:                  return "Invalid operation";
  case CL_INVALID_GL_OBJECT:                  return "Invalid OpenGL object";
  case CL_INVALID_BUFFER_SIZE:                return "Invalid buffer size";
  case CL_INVALID_MIP_LEVEL:                  return "Invalid mip-map level";
  default:                                    return "Unknown";
  }
}

static void opencl_succeed_fatal(cl_int ret,
                                 const char *call,
                                 const char *file,
                                 int line) {
  if (ret != CL_SUCCESS) {
    futhark_panic(-1, "%s:%d: OpenCL call\n  %s\nfailed with error code %d (%s)\n",
                  file, line, call, ret, opencl_error_string(ret));
  }
}

static char* opencl_succeed_nonfatal(cl_int ret,
                                     const char *call,
                                     const char *file,
                                     int line) {
  if (ret != CL_SUCCESS) {
    return msgprintf("%s:%d: OpenCL call\n  %s\nfailed with error code %d (%s)\n",
                     file, line, call, ret, opencl_error_string(ret));
  } else {
    return NULL;
  }
}

struct futhark_context_config {
  int in_use;
  int debugging;
  int profiling;
  int logging;
  const char *cache_fname;
  int num_tuning_params;
  int64_t *tuning_params;
  const char** tuning_param_names;
  const char** tuning_param_vars;
  const char** tuning_param_classes;
  // Uniform fields above.

  int preferred_device_num;
  const char *preferred_platform;
  const char *preferred_device;
  int ignore_blacklist;

  const char* dump_program_to;
  const char* load_program_from;
  const char* dump_binary_to;
  const char* load_binary_from;

  size_t default_group_size;
  size_t default_num_groups;
  size_t default_tile_size;
  size_t default_reg_tile_size;
  size_t default_threshold;

  int default_group_size_changed;
  int default_tile_size_changed;
  int num_build_opts;
  const char **build_opts;

  cl_command_queue queue;
  int queue_set;
};

static void backend_context_config_setup(struct futhark_context_config* cfg) {
  cfg->num_build_opts = 0;
  cfg->build_opts = (const char**) malloc(sizeof(const char*));
  cfg->build_opts[0] = NULL;
  cfg->preferred_device_num = 0;
  cfg->preferred_platform = "";
  cfg->preferred_device = "";
  cfg->ignore_blacklist = 0;
  cfg->dump_program_to = NULL;
  cfg->load_program_from = NULL;
  cfg->dump_binary_to = NULL;
  cfg->load_binary_from = NULL;

  // The following are dummy sizes that mean the concrete defaults
  // will be set during initialisation via hardware-inspection-based
  // heuristics.
  cfg->default_group_size = 0;
  cfg->default_num_groups = 0;
  cfg->default_tile_size = 0;
  cfg->default_reg_tile_size = 0;
  cfg->default_threshold = 0;

  cfg->default_group_size_changed = 0;
  cfg->default_tile_size_changed = 0;

  cfg->queue_set = 0;
}

static void backend_context_config_teardown(struct futhark_context_config* cfg) {
  free(cfg->build_opts);
}

void futhark_context_config_add_build_option(struct futhark_context_config* cfg, const char *opt) {
  cfg->build_opts[cfg->num_build_opts] = opt;
  cfg->num_build_opts++;
  cfg->build_opts = (const char**) realloc(cfg->build_opts, (cfg->num_build_opts+1) * sizeof(const char*));
  cfg->build_opts[cfg->num_build_opts] = NULL;
}

void futhark_context_config_set_device(struct futhark_context_config *cfg, const char* s) {
  int x = 0;
  if (*s == '#') {
    s++;
    while (isdigit(*s)) {
      x = x * 10 + (*s++)-'0';
    }
    // Skip trailing spaces.
    while (isspace(*s)) {
      s++;
    }
  }
  cfg->preferred_device = s;
  cfg->preferred_device_num = x;
  cfg->ignore_blacklist = 1;
}

void futhark_context_config_set_platform(struct futhark_context_config *cfg, const char *s) {
  cfg->preferred_platform = s;
  cfg->ignore_blacklist = 1;
}

void futhark_context_config_set_command_queue(struct futhark_context_config *cfg, cl_command_queue q) {
  cfg->queue = q;
  cfg->queue_set = 1;
}

struct opencl_device_option {
  cl_platform_id platform;
  cl_device_id device;
  cl_device_type device_type;
  char *platform_name;
  char *device_name;
};

static char* opencl_platform_info(cl_platform_id platform,
                                  cl_platform_info param) {
  size_t req_bytes;
  char *info;

  OPENCL_SUCCEED_FATAL(clGetPlatformInfo(platform, param, 0, NULL, &req_bytes));

  info = (char*) malloc(req_bytes);

  OPENCL_SUCCEED_FATAL(clGetPlatformInfo(platform, param, req_bytes, info, NULL));

  return info;
}

static char* opencl_device_info(cl_device_id device,
                                cl_device_info param) {
  size_t req_bytes;
  char *info;

  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device, param, 0, NULL, &req_bytes));

  info = (char*) malloc(req_bytes);

  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device, param, req_bytes, info, NULL));

  return info;
}

static int is_blacklisted(const char *platform_name, const char *device_name,
                          const struct futhark_context_config *cfg) {
  if (strcmp(cfg->preferred_platform, "") != 0 ||
      strcmp(cfg->preferred_device, "") != 0) {
    return 0;
  } else if (strstr(platform_name, "Apple") != NULL &&
             strstr(device_name, "Intel(R) Core(TM)") != NULL) {
    return 1;
  } else {
    return 0;
  }
}

static void opencl_all_device_options(struct opencl_device_option **devices_out,
                                      size_t *num_devices_out) {
  size_t num_devices = 0, num_devices_added = 0;

  cl_platform_id *all_platforms;
  cl_uint *platform_num_devices;

  cl_uint num_platforms;

  // Find the number of platforms.
  OPENCL_SUCCEED_FATAL(clGetPlatformIDs(0, NULL, &num_platforms));

  // Make room for them.
  all_platforms = calloc(num_platforms, sizeof(cl_platform_id));
  platform_num_devices = calloc(num_platforms, sizeof(cl_uint));

  // Fetch all the platforms.
  OPENCL_SUCCEED_FATAL(clGetPlatformIDs(num_platforms, all_platforms, NULL));

  // Count the number of devices for each platform, as well as the
  // total number of devices.
  for (cl_uint i = 0; i < num_platforms; i++) {
    if (clGetDeviceIDs(all_platforms[i], CL_DEVICE_TYPE_ALL,
                       0, NULL, &platform_num_devices[i]) == CL_SUCCESS) {
      num_devices += platform_num_devices[i];
    } else {
      platform_num_devices[i] = 0;
    }
  }

  // Make room for all the device options.
  struct opencl_device_option *devices =
    calloc(num_devices, sizeof(struct opencl_device_option));

  // Loop through the platforms, getting information about their devices.
  for (cl_uint i = 0; i < num_platforms; i++) {
    cl_platform_id platform = all_platforms[i];
    cl_uint num_platform_devices = platform_num_devices[i];

    if (num_platform_devices == 0) {
      continue;
    }

    char *platform_name = opencl_platform_info(platform, CL_PLATFORM_NAME);
    cl_device_id *platform_devices =
      calloc(num_platform_devices, sizeof(cl_device_id));

    // Fetch all the devices.
    OPENCL_SUCCEED_FATAL(clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL,
                                        num_platform_devices, platform_devices, NULL));

    // Loop through the devices, adding them to the devices array.
    for (cl_uint i = 0; i < num_platform_devices; i++) {
      char *device_name = opencl_device_info(platform_devices[i], CL_DEVICE_NAME);
      devices[num_devices_added].platform = platform;
      devices[num_devices_added].device = platform_devices[i];
      OPENCL_SUCCEED_FATAL(clGetDeviceInfo(platform_devices[i], CL_DEVICE_TYPE,
                                           sizeof(cl_device_type),
                                           &devices[num_devices_added].device_type,
                                           NULL));
      // We don't want the structs to share memory, so copy the platform name.
      // Each device name is already unique.
      devices[num_devices_added].platform_name = strclone(platform_name);
      devices[num_devices_added].device_name = device_name;
      num_devices_added++;
    }
    free(platform_devices);
    free(platform_name);
  }
  free(all_platforms);
  free(platform_num_devices);

  *devices_out = devices;
  *num_devices_out = num_devices;
}

void futhark_context_config_select_device_interactively(struct futhark_context_config *cfg) {
  struct opencl_device_option *devices;
  size_t num_devices;

  opencl_all_device_options(&devices, &num_devices);

  printf("Choose OpenCL device:\n");
  const char *cur_platform = "";
  for (size_t i = 0; i < num_devices; i++) {
    struct opencl_device_option device = devices[i];
    if (strcmp(cur_platform, device.platform_name) != 0) {
      printf("Platform: %s\n", device.platform_name);
      cur_platform = device.platform_name;
    }
    printf("[%d] %s\n", (int)i, device.device_name);
  }

  int selection;
  printf("Choice: ");
  if (scanf("%d", &selection) == 1) {
    cfg->preferred_platform = "";
    cfg->preferred_device = "";
    cfg->preferred_device_num = selection;
    cfg->ignore_blacklist = 1;
  }

  // Free all the platform and device names.
  for (size_t j = 0; j < num_devices; j++) {
    free(devices[j].platform_name);
    free(devices[j].device_name);
  }
  free(devices);
}

void futhark_context_config_list_devices(struct futhark_context_config *cfg) {
  (void)cfg;
  struct opencl_device_option *devices;
  size_t num_devices;

  opencl_all_device_options(&devices, &num_devices);

  const char *cur_platform = "";
  for (size_t i = 0; i < num_devices; i++) {
    struct opencl_device_option device = devices[i];
    if (strcmp(cur_platform, device.platform_name) != 0) {
      printf("Platform: %s\n", device.platform_name);
      cur_platform = device.platform_name;
    }
    printf("[%d]: %s\n", (int)i, device.device_name);
  }

  // Free all the platform and device names.
  for (size_t j = 0; j < num_devices; j++) {
    free(devices[j].platform_name);
    free(devices[j].device_name);
  }
  free(devices);
}

void futhark_context_config_dump_program_to(struct futhark_context_config *cfg, const char *path) {
  cfg->dump_program_to = path;
}

void futhark_context_config_load_program_from(struct futhark_context_config *cfg, const char *path) {
  cfg->load_program_from = path;
}

void futhark_context_config_dump_binary_to(struct futhark_context_config *cfg, const char *path) {
  cfg->dump_binary_to = path;
}

void futhark_context_config_load_binary_from(struct futhark_context_config *cfg, const char *path) {
  cfg->load_binary_from = path;
}

void futhark_context_config_set_default_group_size(struct futhark_context_config *cfg, int size) {
  cfg->default_group_size = size;
  cfg->default_group_size_changed = 1;
}

void futhark_context_config_set_default_num_groups(struct futhark_context_config *cfg, int num) {
  cfg->default_num_groups = num;
}

void futhark_context_config_set_default_tile_size(struct futhark_context_config *cfg, int size) {
  cfg->default_tile_size = size;
  cfg->default_tile_size_changed = 1;
}

void futhark_context_config_set_default_reg_tile_size(struct futhark_context_config *cfg, int size) {
  cfg->default_reg_tile_size = size;
}

void futhark_context_config_set_default_threshold(struct futhark_context_config *cfg, int size) {
  cfg->default_threshold = size;
}

int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg,
                                            const char *param_name,
                                            size_t new_value) {
  for (int i = 0; i < cfg->num_tuning_params; i++) {
    if (strcmp(param_name, cfg->tuning_param_names[i]) == 0) {
      cfg->tuning_params[i] = new_value;
      return 0;
    }
  }
  if (strcmp(param_name, "default_group_size") == 0) {
    cfg->default_group_size = new_value;
    return 0;
  }
  if (strcmp(param_name, "default_num_groups") == 0) {
    cfg->default_num_groups = new_value;
    return 0;
  }
  if (strcmp(param_name, "default_threshold") == 0) {
    cfg->default_threshold = new_value;
    return 0;
  }
  if (strcmp(param_name, "default_tile_size") == 0) {
    cfg->default_tile_size = new_value;
    return 0;
  }
  if (strcmp(param_name, "default_reg_tile_size") == 0) {
    cfg->default_reg_tile_size = new_value;
    return 0;
  }
  return 1;
}

// A record of something that happened.
struct profiling_record {
  cl_event *event;
  const char* name;
};

struct futhark_context {
  struct futhark_context_config* cfg;
  int detail_memory;
  int debugging;
  int profiling;
  int profiling_paused;
  int logging;
  lock_t lock;
  char *error;
  lock_t error_lock;
  FILE *log;
  struct constants *constants;
  struct free_list free_list;
  int64_t peak_mem_usage_default;
  int64_t cur_mem_usage_default;
  struct program* program;

  // Common fields above.

  cl_mem global_failure;
  cl_mem global_failure_args;
  struct tuning_params tuning_params;
  // True if a potentially failing kernel has been enqueued.
  cl_int failure_is_an_option;
  int total_runs;
  long int total_runtime;
  int64_t peak_mem_usage_device;
  int64_t cur_mem_usage_device;

  cl_device_id device;
  cl_context ctx;
  cl_command_queue queue;
  cl_program clprogram;

  struct free_list cl_free_list;

  size_t max_group_size;
  size_t max_num_groups;
  size_t max_tile_size;
  size_t max_threshold;
  size_t max_local_memory;

  size_t lockstep_width;

  struct profiling_record *profiling_records;
  int profiling_records_capacity;
  int profiling_records_used;

};

static cl_build_status build_opencl_program(cl_program program, cl_device_id device, const char* options) {
  cl_int clBuildProgram_error = clBuildProgram(program, 1, &device, options, NULL, NULL);

  // Avoid termination due to CL_BUILD_PROGRAM_FAILURE
  if (clBuildProgram_error != CL_SUCCESS &&
      clBuildProgram_error != CL_BUILD_PROGRAM_FAILURE) {
    OPENCL_SUCCEED_FATAL(clBuildProgram_error);
  }

  cl_build_status build_status;
  OPENCL_SUCCEED_FATAL(clGetProgramBuildInfo(program,
                                             device,
                                             CL_PROGRAM_BUILD_STATUS,
                                             sizeof(cl_build_status),
                                             &build_status,
                                             NULL));

  if (build_status != CL_SUCCESS) {
    char *build_log;
    size_t ret_val_size;
    OPENCL_SUCCEED_FATAL(clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &ret_val_size));

    build_log = (char*) malloc(ret_val_size+1);
    OPENCL_SUCCEED_FATAL(clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, ret_val_size, build_log, NULL));

    // The spec technically does not say whether the build log is zero-terminated, so let's be careful.
    build_log[ret_val_size] = '\0';

    fprintf(stderr, "Build log:\n%s\n", build_log);

    free(build_log);
  }

  return build_status;
}

static char* mk_compile_opts(struct futhark_context *ctx,
                             const char *extra_build_opts[],
                             struct opencl_device_option device_option) {
  int compile_opts_size = 1024;

  for (int i = 0; i < ctx->cfg->num_tuning_params; i++) {
    compile_opts_size += strlen(ctx->cfg->tuning_param_names[i]) + 20;
  }

  for (int i = 0; extra_build_opts[i] != NULL; i++) {
    compile_opts_size += strlen(extra_build_opts[i] + 1);
  }

  char *compile_opts = (char*) malloc(compile_opts_size);

  int w = snprintf(compile_opts, compile_opts_size,
                   "-DLOCKSTEP_WIDTH=%d ",
                   (int)ctx->lockstep_width);

  w += snprintf(compile_opts+w, compile_opts_size-w,
                "-D%s=%d ",
                "max_group_size",
                (int)ctx->max_group_size);

  for (int i = 0; i < ctx->cfg->num_tuning_params; i++) {
    w += snprintf(compile_opts+w, compile_opts_size-w,
                  "-D%s=%d ",
                  ctx->cfg->tuning_param_vars[i],
                  (int)ctx->cfg->tuning_params[i]);
  }

  for (int i = 0; extra_build_opts[i] != NULL; i++) {
    w += snprintf(compile_opts+w, compile_opts_size-w,
                  "%s ", extra_build_opts[i]);
  }

  // Oclgrind claims to support cl_khr_fp16, but this is not actually
  // the case.
  if (strcmp(device_option.platform_name, "Oclgrind") == 0) {
    w += snprintf(compile_opts+w, compile_opts_size-w, "-DEMULATE_F16 ");
  }

  return compile_opts;
}


// Count up the runtime all the profiling_records that occured during execution.
// Also clears the buffer of profiling_records.
static void opencl_tally_profiling_records(struct futhark_context *ctx,
                                           struct cost_centres* ccs) {
  cl_int err;
  for (int i = 0; i < ctx->profiling_records_used; i++) {
    struct profiling_record record = ctx->profiling_records[i];

    cl_ulong start_t, end_t;

    OPENCL_SUCCEED_FATAL(clGetEventProfilingInfo(*record.event,
                                                 CL_PROFILING_COMMAND_START,
                                                 sizeof(start_t),
                                                 &start_t,
                                                 NULL));

    OPENCL_SUCCEED_FATAL(clGetEventProfilingInfo(*record.event,
                                                 CL_PROFILING_COMMAND_END,
                                                 sizeof(end_t),
                                                 &end_t,
                                                 NULL));

    if (ccs) {
      // Note that OpenCL provides nanosecond resolution, but we want
      // microseconds.
      struct cost_centre c = {
        .name = record.name,
        .runs = 1,
        .runtime = (end_t - start_t)/1000
      };
      cost_centres_add(ccs, c);
    }

    OPENCL_SUCCEED_FATAL(clReleaseEvent(*record.event));
    free(record.event);
  }

  ctx->profiling_records_used = 0;
}

// If profiling, produce an event associated with a profiling record.
static cl_event* opencl_get_event(struct futhark_context *ctx, const char *name) {
  if (ctx->profiling_records_used == ctx->profiling_records_capacity) {
    ctx->profiling_records_capacity *= 2;
    ctx->profiling_records =
      realloc(ctx->profiling_records,
              ctx->profiling_records_capacity *
              sizeof(struct profiling_record));
  }
  cl_event *event = malloc(sizeof(cl_event));
  ctx->profiling_records[ctx->profiling_records_used].event = event;
  ctx->profiling_records[ctx->profiling_records_used].name = name;
  ctx->profiling_records_used++;
  return event;
}

// Allocate memory from driver. The problem is that OpenCL may perform
// lazy allocation, so we cannot know whether an allocation succeeded
// until the first time we try to use it.  Hence we immediately
// perform a write to see if the allocation succeeded.  This is slow,
// but the assumption is that this operation will be rare (most things
// will go through the free list).
static int opencl_alloc_actual(struct futhark_context *ctx, size_t size, cl_mem *mem_out) {
  int error;
  *mem_out = clCreateBuffer(ctx->ctx, CL_MEM_READ_WRITE, size, NULL, &error);

  if (error != CL_SUCCESS) {
    return error;
  }

  int x = 2;
  error = clEnqueueWriteBuffer(ctx->queue, *mem_out,
                               CL_TRUE,
                               0, sizeof(x), &x,
                               0, NULL, NULL);

  // No need to wait for completion here. clWaitForEvents() cannot
  // return mem object allocation failures. This implies that the
  // buffer is faulted onto the device on enqueue. (Observation by
  // Andreas Kloeckner.)

  return error;
}

static int opencl_alloc(struct futhark_context *ctx, FILE *log,
                        size_t min_size, const char *tag,
                        cl_mem *mem_out, size_t *size_out) {
  (void)tag;
  if (min_size < sizeof(int)) {
    min_size = sizeof(int);
  }

  cl_mem* memptr;
  if (free_list_find(&ctx->cl_free_list, min_size, tag, size_out, (fl_mem*)&memptr) == 0) {
    // Successfully found a free block.  Is it big enough?
    if (*size_out >= min_size) {
      if (ctx->cfg->debugging) {
        fprintf(log, "No need to allocate: Found a block in the free list.\n");
      }
      *mem_out = *memptr;
      free(memptr);
      return CL_SUCCESS;
    } else {
      if (ctx->cfg->debugging) {
        fprintf(log, "Found a free block, but it was too small.\n");
      }
      int error = clReleaseMemObject(*memptr);
      free(*memptr);
      if (error != CL_SUCCESS) {
        return error;
      }
    }
  }

  *size_out = min_size;

  // We have to allocate a new block from the driver.  If the
  // allocation does not succeed, then we might be in an out-of-memory
  // situation.  We now start freeing things from the free list until
  // we think we have freed enough that the allocation will succeed.
  // Since we don't know how far the allocation is from fitting, we
  // have to check after every deallocation.  This might be pretty
  // expensive.  Let's hope that this case is hit rarely.

  if (ctx->cfg->debugging) {
    fprintf(log, "Actually allocating the desired block.\n");
  }

  int error = opencl_alloc_actual(ctx, min_size, mem_out);

  while (error == CL_MEM_OBJECT_ALLOCATION_FAILURE) {
    if (ctx->cfg->debugging) {
      fprintf(log, "Out of OpenCL memory: releasing entry from the free list...\n");
    }
    cl_mem* memptr;
    if (free_list_first(&ctx->cl_free_list, (fl_mem*)&memptr) == 0) {
      cl_mem mem = *memptr;
      free(memptr);
      error = clReleaseMemObject(mem);
      if (error != CL_SUCCESS) {
        return error;
      }
    } else {
      break;
    }
    error = opencl_alloc_actual(ctx, min_size, mem_out);
  }

  return error;
}

static int opencl_free(struct futhark_context *ctx,
                       cl_mem mem, size_t size, const char *tag) {
  cl_mem* memptr = malloc(sizeof(cl_mem));
  *memptr = mem;
  free_list_insert(&ctx->cl_free_list, size, (fl_mem)memptr, tag);
  return CL_SUCCESS;
}

static int opencl_free_all(struct futhark_context *ctx) {
  free_list_pack(&ctx->cl_free_list);
  cl_mem* memptr;
  while (free_list_first(&ctx->cl_free_list, (fl_mem*)&memptr) == 0) {
    cl_mem mem = *memptr;
    free(memptr);
    int error = clReleaseMemObject(mem);
    if (error != CL_SUCCESS) {
      return error;
    }
  }

  return CL_SUCCESS;
}

int futhark_context_sync(struct futhark_context* ctx) {
  // Check for any delayed error.
  cl_int failure_idx = -1;
  if (ctx->failure_is_an_option) {
    OPENCL_SUCCEED_OR_RETURN(
                             clEnqueueReadBuffer(ctx->queue,
                                                 ctx->global_failure,
                                                 CL_FALSE,
                                                 0, sizeof(cl_int), &failure_idx,
                                                 0, NULL, NULL));
    ctx->failure_is_an_option = 0;
  }

  OPENCL_SUCCEED_OR_RETURN(clFinish(ctx->queue));

  if (failure_idx >= 0) {
    // We have to clear global_failure so that the next entry point
    // is not considered a failure from the start.
    cl_int no_failure = -1;
    OPENCL_SUCCEED_OR_RETURN(
                             clEnqueueWriteBuffer(ctx->queue, ctx->global_failure, CL_TRUE,
                                                  0, sizeof(cl_int), &no_failure,
                                                  0, NULL, NULL));

    int64_t args[max_failure_args+1];
    OPENCL_SUCCEED_OR_RETURN(
                             clEnqueueReadBuffer(ctx->queue,
                                                 ctx->global_failure_args,
                                                 CL_TRUE,
                                                 0, sizeof(args), &args,
                                                 0, NULL, NULL));

    ctx->error = get_failure_msg(failure_idx, args);

    return FUTHARK_PROGRAM_ERROR;
  }
  return 0;
}


// We take as input several strings representing the program, because
// C does not guarantee that the compiler supports particularly large
// literals.  Notably, Visual C has a limit of 2048 characters.  The
// array must be NULL-terminated.
static void setup_opencl_with_command_queue(struct futhark_context *ctx,
                                            cl_command_queue queue,
                                            const char *srcs[],
                                            const char *extra_build_opts[],
                                            const char* cache_fname) {
  int error;

  free_list_init(&ctx->cl_free_list);
  ctx->queue = queue;

  OPENCL_SUCCEED_FATAL(clGetCommandQueueInfo(ctx->queue, CL_QUEUE_CONTEXT, sizeof(cl_context), &ctx->ctx, NULL));

  // Fill out the device info.  This is redundant work if we are
  // called from setup_opencl() (which is the common case), but I
  // doubt it matters much.
  struct opencl_device_option device_option;
  OPENCL_SUCCEED_FATAL(clGetCommandQueueInfo(ctx->queue, CL_QUEUE_DEVICE,
                                             sizeof(cl_device_id),
                                             &device_option.device,
                                             NULL));
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_PLATFORM,
                                       sizeof(cl_platform_id),
                                       &device_option.platform,
                                       NULL));
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_TYPE,
                                       sizeof(cl_device_type),
                                       &device_option.device_type,
                                       NULL));
  device_option.platform_name = opencl_platform_info(device_option.platform, CL_PLATFORM_NAME);
  device_option.device_name = opencl_device_info(device_option.device, CL_DEVICE_NAME);

  ctx->device = device_option.device;

  if (f64_required) {
    cl_uint supported;
    OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE,
                                         sizeof(cl_uint), &supported, NULL));
    if (!supported) {
      futhark_panic(1, "Program uses double-precision floats, but this is not supported on the chosen device: %s\n",
                    device_option.device_name);
    }
  }

  size_t max_group_size;
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_MAX_WORK_GROUP_SIZE,
                                       sizeof(size_t), &max_group_size, NULL));

  size_t max_tile_size = sqrt(max_group_size);

  cl_ulong max_local_memory;
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_LOCAL_MEM_SIZE,
                                       sizeof(size_t), &max_local_memory, NULL));

  // Futhark reserves 4 bytes for bookkeeping information.
  max_local_memory -= 4;

  // The OpenCL implementation may reserve some local memory bytes for
  // various purposes.  In principle, we should use
  // clGetKernelWorkGroupInfo() to figure out for each kernel how much
  // is actually available, but our current code generator design
  // makes this infeasible.  Instead, we have this nasty hack where we
  // arbitrarily subtract some bytes, based on empirical measurements
  // (but which might be arbitrarily wrong).  Fortunately, we rarely
  // try to really push the local memory usage.
  if (strstr(device_option.platform_name, "NVIDIA CUDA") != NULL) {
    max_local_memory -= 12;
  } else if (strstr(device_option.platform_name, "AMD") != NULL) {
    max_local_memory -= 16;
  }

  // Make sure this function is defined.
  post_opencl_setup(ctx, &device_option);

  if (max_group_size < ctx->cfg->default_group_size) {
    if (ctx->cfg->default_group_size_changed) {
      fprintf(stderr, "Note: Device limits default group size to %zu (down from %zu).\n",
              max_group_size, ctx->cfg->default_group_size);
    }
    ctx->cfg->default_group_size = max_group_size;
  }

  if (max_tile_size < ctx->cfg->default_tile_size) {
    if (ctx->cfg->default_tile_size_changed) {
      fprintf(stderr, "Note: Device limits default tile size to %zu (down from %zu).\n",
              max_tile_size, ctx->cfg->default_tile_size);
    }
    ctx->cfg->default_tile_size = max_tile_size;
  }

  ctx->max_group_size = max_group_size;
  ctx->max_tile_size = max_tile_size; // No limit.
  ctx->max_threshold = ctx->max_num_groups = 0; // No limit.
  ctx->max_local_memory = max_local_memory;

  // Now we go through all the sizes, clamp them to the valid range,
  // or set them to the default.
  for (int i = 0; i < ctx->cfg->num_tuning_params; i++) {
    const char *size_class = ctx->cfg->tuning_param_classes[i];
    int64_t *size_value = &ctx->cfg->tuning_params[i];
    const char* size_name = ctx->cfg->tuning_param_names[i];
    int64_t max_value = 0, default_value = 0;

    if (strstr(size_class, "group_size") == size_class) {
      max_value = max_group_size;
      default_value = ctx->cfg->default_group_size;
    } else if (strstr(size_class, "num_groups") == size_class) {
      max_value = max_group_size; // Futhark assumes this constraint.
      default_value = ctx->cfg->default_num_groups;
      // XXX: as a quick and dirty hack, use twice as many threads for
      // histograms by default.  We really should just be smarter
      // about sizes somehow.
      if (strstr(size_name, ".seghist_") != NULL) {
        default_value *= 2;
      }
    } else if (strstr(size_class, "tile_size") == size_class) {
      max_value = sqrt(max_group_size);
      default_value = ctx->cfg->default_tile_size;
    } else if (strstr(size_class, "reg_tile_size") == size_class) {
      max_value = 0; // No limit.
      default_value = ctx->cfg->default_reg_tile_size;
    } else if (strstr(size_class, "threshold") == size_class) {
      // Threshold can be as large as it takes.
      default_value = ctx->cfg->default_threshold;
    } else {
      // Bespoke sizes have no limit or default.
    }
    if (*size_value == 0) {
      *size_value = default_value;
    } else if (max_value > 0 && *size_value > max_value) {
      fprintf(stderr, "Note: Device limits %s to %d (down from %d)\n",
              size_name, (int)max_value, (int)*size_value);
      *size_value = max_value;
    }
  }

  if (ctx->lockstep_width == 0) {
    ctx->lockstep_width = 1;
  }

  if (ctx->cfg->logging) {
    fprintf(stderr, "Lockstep width: %d\n", (int)ctx->lockstep_width);
    fprintf(stderr, "Default group size: %d\n", (int)ctx->cfg->default_group_size);
    fprintf(stderr, "Default number of groups: %d\n", (int)ctx->cfg->default_num_groups);
  }

  char *compile_opts = mk_compile_opts(ctx, extra_build_opts, device_option);

  if (ctx->cfg->logging) {
    fprintf(stderr, "OpenCL compiler options: %s\n", compile_opts);
  }

  char *fut_opencl_src = NULL;
  cl_program prog;
  error = CL_SUCCESS;

  struct cache_hash h;

  int loaded_from_cache = 0;
  if (ctx->cfg->load_binary_from == NULL) {
    size_t src_size = 0;

    // Maybe we have to read OpenCL source from somewhere else (used for debugging).
    if (ctx->cfg->load_program_from != NULL) {
      fut_opencl_src = slurp_file(ctx->cfg->load_program_from, NULL);
      assert(fut_opencl_src != NULL);
    } else {
      // Construct the OpenCL source concatenating all the fragments.
      for (const char **src = srcs; src && *src; src++) {
        src_size += strlen(*src);
      }

      fut_opencl_src = (char*) malloc(src_size + 1);

      size_t n, i;
      for (i = 0, n = 0; srcs && srcs[i]; i++) {
        strncpy(fut_opencl_src+n, srcs[i], src_size-n);
        n += strlen(srcs[i]);
      }
      fut_opencl_src[src_size] = 0;
    }

    if (ctx->cfg->dump_program_to != NULL) {
      if (ctx->cfg->logging) {
        fprintf(stderr, "Dumping OpenCL source to %s...\n", ctx->cfg->dump_program_to);
      }

      dump_file(ctx->cfg->dump_program_to, fut_opencl_src, strlen(fut_opencl_src));
    }

    if (cache_fname != NULL) {
      if (ctx->cfg->logging) {
        fprintf(stderr, "Restoring cache from from %s...\n", cache_fname);
      }
      cache_hash_init(&h);
      cache_hash(&h, fut_opencl_src, strlen(fut_opencl_src));
      cache_hash(&h, compile_opts, strlen(compile_opts));

      unsigned char *buf;
      size_t bufsize;
      errno = 0;
      if (cache_restore(cache_fname, &h, &buf, &bufsize) != 0) {
        if (ctx->cfg->logging) {
          fprintf(stderr, "Failed to restore cache (errno: %s)\n", strerror(errno));
        }
      } else {
        if (ctx->cfg->logging) {
          fprintf(stderr, "Cache restored; loading OpenCL binary...\n");
        }

        cl_int status = 0;
        prog = clCreateProgramWithBinary(ctx->ctx, 1, &device_option.device,
                                         &bufsize, (const unsigned char**)&buf,
                                         &status, &error);
        if (status == CL_SUCCESS) {
          loaded_from_cache = 1;
          if (ctx->cfg->logging) {
            fprintf(stderr, "Loading succeeded.\n");
          }
        } else {
          if (ctx->cfg->logging) {
            fprintf(stderr, "Loading failed.\n");
          }
        }
      }
    }

    if (!loaded_from_cache) {
      if (ctx->cfg->logging) {
        fprintf(stderr, "Creating OpenCL program...\n");
      }

      const char* src_ptr[] = {fut_opencl_src};
      prog = clCreateProgramWithSource(ctx->ctx, 1, src_ptr, &src_size, &error);
      OPENCL_SUCCEED_FATAL(error);
    }
  } else {
    if (ctx->cfg->logging) {
      fprintf(stderr, "Loading OpenCL binary from %s...\n", ctx->cfg->load_binary_from);
    }
    size_t binary_size;
    unsigned char *fut_opencl_bin =
      (unsigned char*) slurp_file(ctx->cfg->load_binary_from, &binary_size);
    assert(fut_opencl_bin != NULL);
    const unsigned char *binaries[1] = { fut_opencl_bin };
    cl_int status = 0;

    prog = clCreateProgramWithBinary(ctx->ctx, 1, &device_option.device,
                                     &binary_size, binaries,
                                     &status, &error);

    OPENCL_SUCCEED_FATAL(status);
    OPENCL_SUCCEED_FATAL(error);
  }

  if (ctx->cfg->logging) {
    fprintf(stderr, "Building OpenCL program...\n");
  }
  OPENCL_SUCCEED_FATAL(build_opencl_program(prog, device_option.device, compile_opts));

  free(compile_opts);
  free(fut_opencl_src);

  size_t binary_size = 0;
  unsigned char *binary = NULL;
  int store_in_cache = cache_fname != NULL && !loaded_from_cache;
  if (store_in_cache || ctx->cfg->dump_binary_to != NULL) {
    OPENCL_SUCCEED_FATAL(clGetProgramInfo(prog, CL_PROGRAM_BINARY_SIZES,
                                          sizeof(size_t), &binary_size, NULL));
    binary = (unsigned char*) malloc(binary_size);
    OPENCL_SUCCEED_FATAL(clGetProgramInfo(prog, CL_PROGRAM_BINARIES,
                                          sizeof(unsigned char*), &binary, NULL));
  }

  if (store_in_cache) {
    if (ctx->cfg->logging) {
      fprintf(stderr, "Caching OpenCL binary in %s...\n", cache_fname);
    }
    if (cache_store(cache_fname, &h, binary, binary_size) != 0) {
      printf("Failed to cache binary: %s\n", strerror(errno));
    }
  }

  if (ctx->cfg->dump_binary_to != NULL) {
    if (ctx->cfg->logging) {
      fprintf(stderr, "Dumping OpenCL binary to %s...\n", ctx->cfg->dump_binary_to);
    }
    dump_file(ctx->cfg->dump_binary_to, binary, binary_size);
  }

  ctx->clprogram = prog;
}

static struct opencl_device_option get_preferred_device(const struct futhark_context_config *cfg) {
  struct opencl_device_option *devices;
  size_t num_devices;

  opencl_all_device_options(&devices, &num_devices);

  int num_device_matches = 0;

  for (size_t i = 0; i < num_devices; i++) {
    struct opencl_device_option device = devices[i];
    if (strstr(device.platform_name, cfg->preferred_platform) != NULL &&
        strstr(device.device_name, cfg->preferred_device) != NULL &&
        (cfg->ignore_blacklist ||
         !is_blacklisted(device.platform_name, device.device_name, cfg)) &&
        num_device_matches++ == cfg->preferred_device_num) {
      // Free all the platform and device names, except the ones we have chosen.
      for (size_t j = 0; j < num_devices; j++) {
        if (j != i) {
          free(devices[j].platform_name);
          free(devices[j].device_name);
        }
      }
      free(devices);
      return device;
    }
  }

  futhark_panic(1, "Could not find acceptable OpenCL device.\n");
  exit(1); // Never reached
}

static void setup_opencl(struct futhark_context *ctx,
                         const char *srcs[],
                         const char *extra_build_opts[],
                         const char* cache_fname) {
  struct opencl_device_option device_option = get_preferred_device(ctx->cfg);

  if (ctx->cfg->logging) {
    fprintf(stderr, "Using platform: %s\n", device_option.platform_name);
    fprintf(stderr, "Using device: %s\n", device_option.device_name);
  }

  // Note that NVIDIA's OpenCL requires the platform property
  cl_context_properties properties[] = {
    CL_CONTEXT_PLATFORM,
    (cl_context_properties)device_option.platform,
    0
  };

  cl_int clCreateContext_error;
  ctx->ctx = clCreateContext(properties, 1, &device_option.device, NULL, NULL, &clCreateContext_error);
  OPENCL_SUCCEED_FATAL(clCreateContext_error);

  cl_int clCreateCommandQueue_error;
  cl_command_queue queue =
    clCreateCommandQueue(ctx->ctx,
                         device_option.device,
                         ctx->cfg->profiling ? CL_QUEUE_PROFILING_ENABLE : 0,
                         &clCreateCommandQueue_error);
  OPENCL_SUCCEED_FATAL(clCreateCommandQueue_error);

  setup_opencl_with_command_queue(ctx, queue, srcs, extra_build_opts, cache_fname);
}

int backend_context_setup(struct futhark_context* ctx) {
  ctx->lockstep_width = 0; // Real value set later.
  ctx->profiling_records_capacity = 200;
  ctx->profiling_records_used = 0;
  ctx->profiling_records =
    malloc(ctx->profiling_records_capacity *
           sizeof(struct profiling_record));
  ctx->failure_is_an_option = 0;
  ctx->total_runs = 0;
  ctx->total_runtime = 0;
  ctx->peak_mem_usage_device = 0;
  ctx->cur_mem_usage_device = 0;

  if (ctx->cfg->queue_set) {
    setup_opencl_with_command_queue(ctx, ctx->cfg->queue, opencl_program, ctx->cfg->build_opts, ctx->cfg->cache_fname);
  } else {
    setup_opencl(ctx, opencl_program, ctx->cfg->build_opts, ctx->cfg->cache_fname);
  }

  cl_int error;
  cl_int no_error = -1;
  ctx->global_failure =
    clCreateBuffer(ctx->ctx,
                   CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
                   sizeof(cl_int), &no_error, &error);
  OPENCL_SUCCEED_OR_RETURN(error);

  // The +1 is to avoid zero-byte allocations.
  ctx->global_failure_args =
    clCreateBuffer(ctx->ctx,
                   CL_MEM_READ_WRITE,
                   sizeof(int64_t)*(max_failure_args+1), NULL, &error);
  OPENCL_SUCCEED_OR_RETURN(error);
  return 0;
}

void backend_context_teardown(struct futhark_context* ctx) {
  OPENCL_SUCCEED_FATAL(clReleaseMemObject(ctx->global_failure));
  OPENCL_SUCCEED_FATAL(clReleaseMemObject(ctx->global_failure_args));
  (void)opencl_tally_profiling_records(ctx, NULL);
  free(ctx->profiling_records);
  (void)opencl_free_all(ctx);
  (void)clReleaseProgram(ctx->clprogram);
  (void)clReleaseCommandQueue(ctx->queue);
  (void)clReleaseContext(ctx->ctx);
}

cl_command_queue futhark_context_get_command_queue(struct futhark_context* ctx) {
  return ctx->queue;
}

// End of backends/opencl.h

static char *get_failure_msg(int failure_idx, int64_t args[])
{
    switch (failure_idx) { }
    return strdup("Unknown error.  This is a compiler bug.");
}
void post_opencl_setup(struct futhark_context *ctx, struct opencl_device_option *option)
{
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name, "NVIDIA CUDA") != NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->lockstep_width = 32;
    }
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name, "AMD Accelerated Parallel Processing") != NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->lockstep_width = 32;
    }
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->lockstep_width = 1;
    }
    if ((ctx->cfg->default_num_groups == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        size_t MAX_COMPUTE_UNITS_val = 0;
        
        clGetDeviceInfo(ctx->device, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(MAX_COMPUTE_UNITS_val), &MAX_COMPUTE_UNITS_val, NULL);
        ctx->cfg->default_num_groups = 4 * MAX_COMPUTE_UNITS_val;
    }
    if ((ctx->cfg->default_group_size == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->cfg->default_group_size = 256;
    }
    if ((ctx->cfg->default_tile_size == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->cfg->default_tile_size = 16;
    }
    if ((ctx->cfg->default_reg_tile_size == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->cfg->default_reg_tile_size = 4;
    }
    if ((ctx->cfg->default_threshold == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->cfg->default_threshold = 32768;
    }
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        ctx->lockstep_width = 1;
    }
    if ((ctx->cfg->default_num_groups == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        size_t MAX_COMPUTE_UNITS_val = 0;
        
        clGetDeviceInfo(ctx->device, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(MAX_COMPUTE_UNITS_val), &MAX_COMPUTE_UNITS_val, NULL);
        ctx->cfg->default_num_groups = MAX_COMPUTE_UNITS_val;
    }
    if ((ctx->cfg->default_group_size == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        ctx->cfg->default_group_size = 32;
    }
    if ((ctx->cfg->default_tile_size == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        ctx->cfg->default_tile_size = 4;
    }
    if ((ctx->cfg->default_reg_tile_size == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        ctx->cfg->default_reg_tile_size = 1;
    }
    if ((ctx->cfg->default_threshold == 0 && strstr(option->platform_name, "") != NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        size_t MAX_COMPUTE_UNITS_val = 0;
        
        clGetDeviceInfo(ctx->device, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(MAX_COMPUTE_UNITS_val), &MAX_COMPUTE_UNITS_val, NULL);
        ctx->cfg->default_threshold = MAX_COMPUTE_UNITS_val;
    }
}
struct program {
    cl_kernel builtinzhreplicate_f32zireplicate_26114;
    cl_kernel builtinzhreplicate_i32zireplicate_26267;
    cl_kernel builtinzhreplicate_i64zireplicate_26134;
    cl_kernel copy_1d_i8;
    cl_kernel copy_2d_f32;
    cl_kernel copy_2d_i64;
    cl_kernel gpu_map_transpose_f32_i32;
    cl_kernel gpu_map_transpose_f32_i64;
    cl_kernel gpu_map_transpose_f32_low_height_i32;
    cl_kernel gpu_map_transpose_f32_low_height_i64;
    cl_kernel gpu_map_transpose_f32_low_width_i32;
    cl_kernel gpu_map_transpose_f32_low_width_i64;
    cl_kernel gpu_map_transpose_f32_small_i32;
    cl_kernel gpu_map_transpose_f32_small_i64;
    cl_kernel gpu_map_transpose_i64_i32;
    cl_kernel gpu_map_transpose_i64_i64;
    cl_kernel gpu_map_transpose_i64_low_height_i32;
    cl_kernel gpu_map_transpose_i64_low_height_i64;
    cl_kernel gpu_map_transpose_i64_low_width_i32;
    cl_kernel gpu_map_transpose_i64_low_width_i64;
    cl_kernel gpu_map_transpose_i64_small_i32;
    cl_kernel gpu_map_transpose_i64_small_i64;
    cl_kernel renderziscan_stage1_25070;
    cl_kernel renderziscan_stage2_25070;
    cl_kernel renderziscan_stage3_25070;
    cl_kernel renderzisegmap_24379;
    cl_kernel renderzisegmap_24855;
    cl_kernel renderzisegmap_24925;
    cl_kernel renderzisegmap_24941;
    cl_kernel renderzisegmap_24954;
    cl_kernel renderzisegmap_24976;
    cl_kernel renderzisegmap_24992;
    cl_kernel renderzisegmap_25072;
    cl_kernel renderzisegmap_25105;
    cl_kernel renderzisegmap_25121;
    cl_kernel renderzisegmap_25300;
    cl_kernel renderzisegmap_25398;
    cl_kernel renderzisegmap_25414;
    cl_kernel renderzisegmap_25577;
    cl_kernel renderzisegmap_25667;
    cl_kernel renderzisegmap_25683;
    cl_kernel renderzisegmap_25770;
    cl_kernel renderzisegred_large_24912;
    cl_kernel renderzisegred_small_24912;
};
static void setup_program(struct futhark_context *ctx)
{
    (void) ctx;
    
    int error = 0;
    
    (void) error;
    ctx->program = malloc(sizeof(struct program));
    {
        ctx->program->builtinzhreplicate_f32zireplicate_26114 = clCreateKernel(ctx->clprogram, "builtinzhreplicate_f32zireplicate_26114", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "builtin#replicate_f32.replicate_26114");
    }
    {
        ctx->program->builtinzhreplicate_i32zireplicate_26267 = clCreateKernel(ctx->clprogram, "builtinzhreplicate_i32zireplicate_26267", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "builtin#replicate_i32.replicate_26267");
    }
    {
        ctx->program->builtinzhreplicate_i64zireplicate_26134 = clCreateKernel(ctx->clprogram, "builtinzhreplicate_i64zireplicate_26134", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "builtin#replicate_i64.replicate_26134");
    }
    {
        ctx->program->copy_1d_i8 = clCreateKernel(ctx->clprogram, "copy_1d_i8", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "copy_1d_i8");
    }
    {
        ctx->program->copy_2d_f32 = clCreateKernel(ctx->clprogram, "copy_2d_f32", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "copy_2d_f32");
    }
    {
        ctx->program->copy_2d_i64 = clCreateKernel(ctx->clprogram, "copy_2d_i64", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "copy_2d_i64");
    }
    {
        ctx->program->gpu_map_transpose_f32_i32 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_f32_i32", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_f32_i32");
    }
    {
        ctx->program->gpu_map_transpose_f32_i64 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_f32_i64", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_f32_i64");
    }
    {
        ctx->program->gpu_map_transpose_f32_low_height_i32 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_f32_low_height_i32", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_f32_low_height_i32");
    }
    {
        ctx->program->gpu_map_transpose_f32_low_height_i64 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_f32_low_height_i64", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_f32_low_height_i64");
    }
    {
        ctx->program->gpu_map_transpose_f32_low_width_i32 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_f32_low_width_i32", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_f32_low_width_i32");
    }
    {
        ctx->program->gpu_map_transpose_f32_low_width_i64 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_f32_low_width_i64", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_f32_low_width_i64");
    }
    {
        ctx->program->gpu_map_transpose_f32_small_i32 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_f32_small_i32", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_f32_small_i32");
    }
    {
        ctx->program->gpu_map_transpose_f32_small_i64 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_f32_small_i64", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_f32_small_i64");
    }
    {
        ctx->program->gpu_map_transpose_i64_i32 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_i64_i32", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_i64_i32");
    }
    {
        ctx->program->gpu_map_transpose_i64_i64 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_i64_i64", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_i64_i64");
    }
    {
        ctx->program->gpu_map_transpose_i64_low_height_i32 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_i64_low_height_i32", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_i64_low_height_i32");
    }
    {
        ctx->program->gpu_map_transpose_i64_low_height_i64 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_i64_low_height_i64", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_i64_low_height_i64");
    }
    {
        ctx->program->gpu_map_transpose_i64_low_width_i32 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_i64_low_width_i32", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_i64_low_width_i32");
    }
    {
        ctx->program->gpu_map_transpose_i64_low_width_i64 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_i64_low_width_i64", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_i64_low_width_i64");
    }
    {
        ctx->program->gpu_map_transpose_i64_small_i32 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_i64_small_i32", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_i64_small_i32");
    }
    {
        ctx->program->gpu_map_transpose_i64_small_i64 = clCreateKernel(ctx->clprogram, "gpu_map_transpose_i64_small_i64", &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_i64_small_i64");
    }
    {
        ctx->program->renderziscan_stage1_25070 = clCreateKernel(ctx->clprogram, "renderziscan_stage1_25070", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.scan_stage1_25070");
    }
    {
        ctx->program->renderziscan_stage2_25070 = clCreateKernel(ctx->clprogram, "renderziscan_stage2_25070", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderziscan_stage2_25070, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.scan_stage2_25070");
    }
    {
        ctx->program->renderziscan_stage3_25070 = clCreateKernel(ctx->clprogram, "renderziscan_stage3_25070", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderziscan_stage3_25070, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.scan_stage3_25070");
    }
    {
        ctx->program->renderzisegmap_24379 = clCreateKernel(ctx->clprogram, "renderzisegmap_24379", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_24379, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_24379");
    }
    {
        ctx->program->renderzisegmap_24855 = clCreateKernel(ctx->clprogram, "renderzisegmap_24855", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_24855, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_24855");
    }
    {
        ctx->program->renderzisegmap_24925 = clCreateKernel(ctx->clprogram, "renderzisegmap_24925", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_24925, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_24925");
    }
    {
        ctx->program->renderzisegmap_24941 = clCreateKernel(ctx->clprogram, "renderzisegmap_24941", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_24941, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_24941");
    }
    {
        ctx->program->renderzisegmap_24954 = clCreateKernel(ctx->clprogram, "renderzisegmap_24954", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_24954, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_24954");
    }
    {
        ctx->program->renderzisegmap_24976 = clCreateKernel(ctx->clprogram, "renderzisegmap_24976", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_24976, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_24976");
    }
    {
        ctx->program->renderzisegmap_24992 = clCreateKernel(ctx->clprogram, "renderzisegmap_24992", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_24992, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_24992");
    }
    {
        ctx->program->renderzisegmap_25072 = clCreateKernel(ctx->clprogram, "renderzisegmap_25072", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_25072, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_25072");
    }
    {
        ctx->program->renderzisegmap_25105 = clCreateKernel(ctx->clprogram, "renderzisegmap_25105", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_25105, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_25105");
    }
    {
        ctx->program->renderzisegmap_25121 = clCreateKernel(ctx->clprogram, "renderzisegmap_25121", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_25121, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_25121");
    }
    {
        ctx->program->renderzisegmap_25300 = clCreateKernel(ctx->clprogram, "renderzisegmap_25300", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_25300, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_25300");
    }
    {
        ctx->program->renderzisegmap_25398 = clCreateKernel(ctx->clprogram, "renderzisegmap_25398", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_25398, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_25398");
    }
    {
        ctx->program->renderzisegmap_25414 = clCreateKernel(ctx->clprogram, "renderzisegmap_25414", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_25414, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_25414");
    }
    {
        ctx->program->renderzisegmap_25577 = clCreateKernel(ctx->clprogram, "renderzisegmap_25577", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_25577, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_25577");
    }
    {
        ctx->program->renderzisegmap_25667 = clCreateKernel(ctx->clprogram, "renderzisegmap_25667", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_25667, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_25667");
    }
    {
        ctx->program->renderzisegmap_25683 = clCreateKernel(ctx->clprogram, "renderzisegmap_25683", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_25683, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_25683");
    }
    {
        ctx->program->renderzisegmap_25770 = clCreateKernel(ctx->clprogram, "renderzisegmap_25770", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegmap_25770, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segmap_25770");
    }
    {
        ctx->program->renderzisegred_large_24912 = clCreateKernel(ctx->clprogram, "renderzisegred_large_24912", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegred_large_24912, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segred_large_24912");
    }
    {
        ctx->program->renderzisegred_small_24912 = clCreateKernel(ctx->clprogram, "renderzisegred_small_24912", &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->program->renderzisegred_small_24912, 0, sizeof(cl_mem), &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "render.segred_small_24912");
    }
}
static void teardown_program(struct futhark_context *ctx)
{
    (void) ctx;
    
    int error = 0;
    
    (void) error;
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->builtinzhreplicate_f32zireplicate_26114));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->builtinzhreplicate_i32zireplicate_26267));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->builtinzhreplicate_i64zireplicate_26134));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->copy_1d_i8));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->copy_2d_f32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->copy_2d_i64));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_f32_i32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_f32_i64));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_f32_low_height_i32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_f32_low_height_i64));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_f32_low_width_i32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_f32_low_width_i64));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_f32_small_i32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_f32_small_i64));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_i64_i32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_i64_i64));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_i64_low_height_i32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_i64_low_height_i64));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_i64_low_width_i32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_i64_low_width_i64));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_i64_small_i32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->gpu_map_transpose_i64_small_i64));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderziscan_stage1_25070));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderziscan_stage2_25070));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderziscan_stage3_25070));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_24379));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_24855));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_24925));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_24941));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_24954));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_24976));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_24992));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_25072));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_25105));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_25121));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_25300));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_25398));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_25414));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_25577));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_25667));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_25683));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegmap_25770));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegred_large_24912));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->program->renderzisegred_small_24912));
    free(ctx->program);
}
static void set_tuning_params(struct futhark_context *ctx)
{
    (void) ctx;
    ctx->tuning_params.builtinzhreplicate_f32zigroup_sizze_26118 = &ctx->cfg->tuning_params[0];
    ctx->tuning_params.builtinzhreplicate_i32zigroup_sizze_26271 = &ctx->cfg->tuning_params[1];
    ctx->tuning_params.builtinzhreplicate_i64zigroup_sizze_26138 = &ctx->cfg->tuning_params[2];
    ctx->tuning_params.copy_group_sizze = &ctx->cfg->tuning_params[3];
    ctx->tuning_params.copy_num_groups = &ctx->cfg->tuning_params[4];
    ctx->tuning_params.renderzisegmap_group_sizze_24229 = &ctx->cfg->tuning_params[5];
    ctx->tuning_params.renderzisegmap_group_sizze_24527 = &ctx->cfg->tuning_params[6];
    ctx->tuning_params.renderzisegmap_group_sizze_24681 = &ctx->cfg->tuning_params[7];
    ctx->tuning_params.renderzisegmap_group_sizze_24702 = &ctx->cfg->tuning_params[8];
    ctx->tuning_params.renderzisegmap_group_sizze_24734 = &ctx->cfg->tuning_params[9];
    ctx->tuning_params.renderzisegmap_group_sizze_24758 = &ctx->cfg->tuning_params[10];
    ctx->tuning_params.renderzisegmap_group_sizze_24792 = &ctx->cfg->tuning_params[11];
    ctx->tuning_params.renderzisegmap_group_sizze_25074 = &ctx->cfg->tuning_params[12];
    ctx->tuning_params.renderzisegmap_group_sizze_25080 = &ctx->cfg->tuning_params[13];
    ctx->tuning_params.renderzisegmap_group_sizze_25123 = &ctx->cfg->tuning_params[14];
    ctx->tuning_params.renderzisegmap_group_sizze_25139 = &ctx->cfg->tuning_params[15];
    ctx->tuning_params.renderzisegmap_group_sizze_25373 = &ctx->cfg->tuning_params[16];
    ctx->tuning_params.renderzisegmap_group_sizze_25416 = &ctx->cfg->tuning_params[17];
    ctx->tuning_params.renderzisegmap_group_sizze_25432 = &ctx->cfg->tuning_params[18];
    ctx->tuning_params.renderzisegmap_group_sizze_25642 = &ctx->cfg->tuning_params[19];
    ctx->tuning_params.renderzisegmap_group_sizze_25685 = &ctx->cfg->tuning_params[20];
    ctx->tuning_params.renderzisegmap_group_sizze_25701 = &ctx->cfg->tuning_params[21];
    ctx->tuning_params.renderzisegmap_num_groups_24231 = &ctx->cfg->tuning_params[22];
    ctx->tuning_params.renderzisegmap_num_groups_24704 = &ctx->cfg->tuning_params[23];
    ctx->tuning_params.renderzisegmap_num_groups_24794 = &ctx->cfg->tuning_params[24];
    ctx->tuning_params.renderzisegred_group_sizze_24772 = &ctx->cfg->tuning_params[25];
    ctx->tuning_params.renderzisegred_num_groups_24774 = &ctx->cfg->tuning_params[26];
    ctx->tuning_params.renderzisegscan_group_sizze_25064 = &ctx->cfg->tuning_params[27];
    ctx->tuning_params.renderzisegscan_num_groups_25066 = &ctx->cfg->tuning_params[28];
    ctx->tuning_params.renderzisuff_outer_par_0 = &ctx->cfg->tuning_params[29];
}
int memblock_unref_device(struct futhark_context *ctx, struct memblock_device *block, const char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(ctx->log, "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n", desc, block->desc, "space 'device'", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_device -= block->size;
            OPENCL_SUCCEED_OR_RETURN(opencl_free(ctx, block->mem, block->size, desc));
            free(block->references);
            if (ctx->detail_memory)
                fprintf(ctx->log, "%lld bytes freed (now allocated: %lld bytes)\n", (long long) block->size, (long long) ctx->cur_mem_usage_device);
        }
        block->references = NULL;
    }
    return 0;
}
int memblock_alloc_device(struct futhark_context *ctx, struct memblock_device *block, int64_t size, const char *desc)
{
    if (size < 0)
        futhark_panic(1, "Negative allocation of %lld bytes attempted for %s in %s.\n", (long long) size, desc, "space 'device'", ctx->cur_mem_usage_device);
    
    int ret = memblock_unref_device(ctx, block, desc);
    
    if (ret != FUTHARK_SUCCESS)
        return ret;
    
    long long new_usage = ctx->cur_mem_usage_device + size;
    
    if (ctx->detail_memory)
        fprintf(ctx->log, "Allocating %lld bytes for %s in %s (then allocated: %lld bytes)", (long long) size, desc, "space 'device'", new_usage);
    if (new_usage > ctx->peak_mem_usage_device) {
        ctx->peak_mem_usage_device = new_usage;
        if (ctx->detail_memory)
            fprintf(ctx->log, " (new peak).\n");
    } else if (ctx->detail_memory)
        fprintf(ctx->log, ".\n");
    ctx->error = OPENCL_SUCCEED_NONFATAL(opencl_alloc(ctx, ctx->log, (size_t) size, desc, &block->mem, (size_t *) &size));
    if (ctx->error == NULL) {
        block->references = (int *) malloc(sizeof(int));
        *block->references = 1;
        block->size = size;
        block->desc = desc;
        ctx->cur_mem_usage_device = new_usage;
        return FUTHARK_SUCCESS;
    } else {
        // We are naively assuming that any memory allocation error is due to OOM.
        lock_lock(&ctx->error_lock);
        
        char *old_error = ctx->error;
        
        ctx->error = msgprintf("Failed to allocate memory in %s.\nAttempted allocation: %12lld bytes\nCurrently allocated:  %12lld bytes\n%s", "space 'device'", (long long) size, (long long) ctx->cur_mem_usage_device, old_error);
        free(old_error);
        lock_unlock(&ctx->error_lock);
        return FUTHARK_OUT_OF_MEMORY;
    }
}
int memblock_set_device(struct futhark_context *ctx, struct memblock_device *lhs, struct memblock_device *rhs, const char *lhs_desc)
{
    int ret = memblock_unref_device(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
int memblock_unref(struct futhark_context *ctx, struct memblock *block, const char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(ctx->log, "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n", desc, block->desc, "default space", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_default -= block->size;
            host_free(ctx, (size_t) block->size, desc, (void *) block->mem);
            free(block->references);
            if (ctx->detail_memory)
                fprintf(ctx->log, "%lld bytes freed (now allocated: %lld bytes)\n", (long long) block->size, (long long) ctx->cur_mem_usage_default);
        }
        block->references = NULL;
    }
    return 0;
}
int memblock_alloc(struct futhark_context *ctx, struct memblock *block, int64_t size, const char *desc)
{
    if (size < 0)
        futhark_panic(1, "Negative allocation of %lld bytes attempted for %s in %s.\n", (long long) size, desc, "default space", ctx->cur_mem_usage_default);
    
    int ret = memblock_unref(ctx, block, desc);
    
    if (ret != FUTHARK_SUCCESS)
        return ret;
    
    long long new_usage = ctx->cur_mem_usage_default + size;
    
    if (ctx->detail_memory)
        fprintf(ctx->log, "Allocating %lld bytes for %s in %s (then allocated: %lld bytes)", (long long) size, desc, "default space", new_usage);
    if (new_usage > ctx->peak_mem_usage_default) {
        ctx->peak_mem_usage_default = new_usage;
        if (ctx->detail_memory)
            fprintf(ctx->log, " (new peak).\n");
    } else if (ctx->detail_memory)
        fprintf(ctx->log, ".\n");
    host_alloc(ctx, (size_t) size, desc, (size_t *) &size, (void *) &block->mem);
    if (ctx->error == NULL) {
        block->references = (int *) malloc(sizeof(int));
        *block->references = 1;
        block->size = size;
        block->desc = desc;
        ctx->cur_mem_usage_default = new_usage;
        return FUTHARK_SUCCESS;
    } else {
        // We are naively assuming that any memory allocation error is due to OOM.
        lock_lock(&ctx->error_lock);
        
        char *old_error = ctx->error;
        
        ctx->error = msgprintf("Failed to allocate memory in %s.\nAttempted allocation: %12lld bytes\nCurrently allocated:  %12lld bytes\n%s", "default space", (long long) size, (long long) ctx->cur_mem_usage_default, old_error);
        free(old_error);
        lock_unlock(&ctx->error_lock);
        return FUTHARK_OUT_OF_MEMORY;
    }
}
int memblock_set(struct futhark_context *ctx, struct memblock *lhs, struct memblock *rhs, const char *lhs_desc)
{
    int ret = memblock_unref(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
void futhark_context_config_set_debugging(struct futhark_context_config *cfg, int flag)
{
    cfg->profiling = cfg->logging = cfg->debugging = flag;
}
void futhark_context_config_set_profiling(struct futhark_context_config *cfg, int flag)
{
    cfg->profiling = flag;
}
void futhark_context_config_set_logging(struct futhark_context_config *cfg, int flag)
{
    cfg->logging = flag;
}
void futhark_context_config_set_cache_file(struct futhark_context_config *cfg, const char *f)
{
    cfg->cache_fname = f;
}
int futhark_get_tuning_param_count(void)
{
    return num_tuning_params;
}
const char *futhark_get_tuning_param_name(int i)
{
    return tuning_param_names[i];
}
const char *futhark_get_tuning_param_class(int i)
{
    return tuning_param_classes[i];
}
char *futhark_context_report(struct futhark_context *ctx)
{
    if (futhark_context_sync(ctx) != 0)
        return NULL;
    
    struct str_builder builder;
    
    str_builder_init(&builder);
    str_builder(&builder, "Peak memory usage for space 'device': %lld bytes.\n", (long long) ctx->peak_mem_usage_device);
    { }
    if (ctx->profiling) {
        {
            struct cost_centres *ccs = cost_centres_new(sizeof(struct cost_centres));
            
            cost_centres_init(ccs, "copy_dev_to_dev");
            cost_centres_init(ccs, "copy_dev_to_host");
            cost_centres_init(ccs, "copy_host_to_dev");
            cost_centres_init(ccs, "copy_scalar_to_dev");
            cost_centres_init(ccs, "copy_scalar_from_dev");
            cost_centres_init(ccs, "builtin#replicate_f32.replicate_26114");
            cost_centres_init(ccs, "builtin#replicate_i32.replicate_26267");
            cost_centres_init(ccs, "builtin#replicate_i64.replicate_26134");
            cost_centres_init(ccs, "copy_1d_i8");
            cost_centres_init(ccs, "copy_2d_f32");
            cost_centres_init(ccs, "copy_2d_i64");
            cost_centres_init(ccs, "gpu_map_transpose_f32_i32");
            cost_centres_init(ccs, "gpu_map_transpose_f32_i64");
            cost_centres_init(ccs, "gpu_map_transpose_f32_low_height_i32");
            cost_centres_init(ccs, "gpu_map_transpose_f32_low_height_i64");
            cost_centres_init(ccs, "gpu_map_transpose_f32_low_width_i32");
            cost_centres_init(ccs, "gpu_map_transpose_f32_low_width_i64");
            cost_centres_init(ccs, "gpu_map_transpose_f32_small_i32");
            cost_centres_init(ccs, "gpu_map_transpose_f32_small_i64");
            cost_centres_init(ccs, "gpu_map_transpose_i64_i32");
            cost_centres_init(ccs, "gpu_map_transpose_i64_i64");
            cost_centres_init(ccs, "gpu_map_transpose_i64_low_height_i32");
            cost_centres_init(ccs, "gpu_map_transpose_i64_low_height_i64");
            cost_centres_init(ccs, "gpu_map_transpose_i64_low_width_i32");
            cost_centres_init(ccs, "gpu_map_transpose_i64_low_width_i64");
            cost_centres_init(ccs, "gpu_map_transpose_i64_small_i32");
            cost_centres_init(ccs, "gpu_map_transpose_i64_small_i64");
            cost_centres_init(ccs, "render.scan_stage1_25070");
            cost_centres_init(ccs, "render.scan_stage2_25070");
            cost_centres_init(ccs, "render.scan_stage3_25070");
            cost_centres_init(ccs, "render.segmap_24379");
            cost_centres_init(ccs, "render.segmap_24855");
            cost_centres_init(ccs, "render.segmap_24925");
            cost_centres_init(ccs, "render.segmap_24941");
            cost_centres_init(ccs, "render.segmap_24954");
            cost_centres_init(ccs, "render.segmap_24976");
            cost_centres_init(ccs, "render.segmap_24992");
            cost_centres_init(ccs, "render.segmap_25072");
            cost_centres_init(ccs, "render.segmap_25105");
            cost_centres_init(ccs, "render.segmap_25121");
            cost_centres_init(ccs, "render.segmap_25300");
            cost_centres_init(ccs, "render.segmap_25398");
            cost_centres_init(ccs, "render.segmap_25414");
            cost_centres_init(ccs, "render.segmap_25577");
            cost_centres_init(ccs, "render.segmap_25667");
            cost_centres_init(ccs, "render.segmap_25683");
            cost_centres_init(ccs, "render.segmap_25770");
            cost_centres_init(ccs, "render.segred_large_24912");
            cost_centres_init(ccs, "render.segred_small_24912");
            opencl_tally_profiling_records(ctx, ccs);
            cost_centre_report(ccs, &builder);
            cost_centres_free(ccs);
        }
    }
    return builder.str;
}
char *futhark_context_get_error(struct futhark_context *ctx)
{
    char *error = ctx->error;
    
    ctx->error = NULL;
    return error;
}
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f)
{
    ctx->log = f;
}
void futhark_context_pause_profiling(struct futhark_context *ctx)
{
    ctx->profiling_paused = 1;
}
void futhark_context_unpause_profiling(struct futhark_context *ctx)
{
    ctx->profiling_paused = 0;
}
int futhark_context_clear_caches(struct futhark_context *ctx)
{
    lock_lock(&ctx->lock);
    ctx->peak_mem_usage_device = 0;
    ctx->peak_mem_usage_default = 0;
    if (ctx->error == NULL)
        ctx->error = OPENCL_SUCCEED_NONFATAL(opencl_free_all(ctx));
    lock_unlock(&ctx->lock);
    return ctx->error != NULL;
}

// Start of context.h

// Eventually it would be nice to move the context definition in here
// instead of generating it in the compiler.  For now it defines
// various helper functions that must be available.

// Internal functions.

static void set_error(struct futhark_context* ctx, char *error) {
  lock_lock(&ctx->error_lock);
  if (ctx->error == NULL) {
    ctx->error = error;
  } else {
    free(error);
  }
  lock_unlock(&ctx->error_lock);
}

// XXX: should be static, but used in ispc_util.h
void lexical_realloc_error(struct futhark_context* ctx, size_t new_size) {
  set_error(ctx,
            msgprintf("Failed to allocate memory.\nAttempted allocation: %12lld bytes\n",
                      (long long) new_size));
}

static int lexical_realloc(struct futhark_context *ctx,
                           unsigned char **ptr,
                           int64_t *old_size,
                           int64_t new_size) {
  unsigned char *new = realloc(*ptr, (size_t)new_size);
  if (new == NULL) {
    lexical_realloc_error(ctx, new_size);
    return FUTHARK_OUT_OF_MEMORY;
  } else {
    *ptr = new;
    *old_size = new_size;
    return FUTHARK_SUCCESS;
  }
}

static void free_all_in_free_list(struct futhark_context* ctx) {
  fl_mem mem;
  free_list_pack(&ctx->free_list);
  while (free_list_first(&ctx->free_list, (fl_mem*)&mem) == 0) {
    free((void*)mem);
  }
}

static int is_small_alloc(size_t size) {
  return size < 1024*1024;
}

static void host_alloc(struct futhark_context* ctx,
                       size_t size, const char* tag, size_t* size_out, void** mem_out) {
  if (is_small_alloc(size) || free_list_find(&ctx->free_list, size, tag, size_out, (fl_mem*)mem_out) != 0) {
    *size_out = size;
    *mem_out = malloc(size);
  }
}

static void host_free(struct futhark_context* ctx,
                      size_t size, const char* tag, void* mem) {
  // Small allocations are handled by malloc()s own free list.  The
  // threshold here is kind of arbitrary, but seems to work OK.
  // Larger allocations are mmap()ed/munmapped() every time, which is
  // very slow, and Futhark programs tend to use a few very large
  // allocations.
  if (is_small_alloc(size)) {
    free(mem);
  } else {
    free_list_insert(&ctx->free_list, size, (fl_mem)mem, tag);
  }
}

struct futhark_context_config* futhark_context_config_new(void) {
  struct futhark_context_config* cfg = malloc(sizeof(struct futhark_context_config));
  if (cfg == NULL) {
    return NULL;
  }
  cfg->in_use = 0;
  cfg->debugging = 0;
  cfg->profiling = 0;
  cfg->logging = 0;
  cfg->cache_fname = NULL;
  cfg->num_tuning_params = num_tuning_params;
  cfg->tuning_params = malloc(cfg->num_tuning_params * sizeof(int64_t));
  memcpy(cfg->tuning_params, tuning_param_defaults,
         cfg->num_tuning_params * sizeof(int64_t));
  cfg->tuning_param_names = tuning_param_names;
  cfg->tuning_param_vars = tuning_param_vars;
  cfg->tuning_param_classes = tuning_param_classes;
  backend_context_config_setup(cfg);
  return cfg;
}

void futhark_context_config_free(struct futhark_context_config* cfg) {
  assert(!cfg->in_use);
  backend_context_config_teardown(cfg);
  free(cfg->tuning_params);
  free(cfg);
}

struct futhark_context* futhark_context_new(struct futhark_context_config* cfg) {
  struct futhark_context* ctx = malloc(sizeof(struct futhark_context));
  if (ctx == NULL) {
    return NULL;
  }
  assert(!cfg->in_use);
  ctx->cfg = cfg;
  ctx->cfg->in_use = 1;
  create_lock(&ctx->error_lock);
  create_lock(&ctx->lock);
  free_list_init(&ctx->free_list);
  ctx->peak_mem_usage_default = 0;
  ctx->cur_mem_usage_default = 0;
  ctx->constants = malloc(sizeof(struct constants));
  ctx->detail_memory = cfg->debugging;
  ctx->debugging = cfg->debugging;
  ctx->logging = cfg->logging;
  ctx->profiling = cfg->profiling;
  ctx->profiling_paused = 0;
  ctx->error = NULL;
  ctx->log = stderr;
  if (backend_context_setup(ctx) == 0) {
    set_tuning_params(ctx);
    setup_program(ctx);
    init_constants(ctx);
    (void)futhark_context_clear_caches(ctx);
    (void)futhark_context_sync(ctx);
  }
  return ctx;
}

void futhark_context_free(struct futhark_context* ctx) {
  free_constants(ctx);
  teardown_program(ctx);
  backend_context_teardown(ctx);
  free_all_in_free_list(ctx);
  free_list_destroy(&ctx->free_list);
  free(ctx->constants);
  free_lock(&ctx->lock);
  free_lock(&ctx->error_lock);
  ctx->cfg->in_use = 0;
  free(ctx);
}

// End of context.h

static int futrts_builtinzhgpu_copy_1d_i8(struct futhark_context *ctx, struct memblock_device destmem_0, int64_t dest_offset_1, int64_t dest_stride_2, int64_t dest_shape_3, struct memblock_device srcmem_4, int64_t src_offset_5, int64_t src_stride_6, int64_t src_shape_7);
static int futrts_builtinzhgpu_copy_2d_f32(struct futhark_context *ctx, struct memblock_device destmem_0, int64_t dest_offset_1, int64_t dest_stride_2, int64_t dest_shape_3, int64_t dest_stride_4, int64_t dest_shape_5, struct memblock_device srcmem_6, int64_t src_offset_7, int64_t src_stride_8, int64_t src_shape_9, int64_t src_stride_10, int64_t src_shape_11);
static int futrts_builtinzhgpu_copy_2d_i64(struct futhark_context *ctx, struct memblock_device destmem_0, int64_t dest_offset_1, int64_t dest_stride_2, int64_t dest_shape_3, int64_t dest_stride_4, int64_t dest_shape_5, struct memblock_device srcmem_6, int64_t src_offset_7, int64_t src_stride_8, int64_t src_shape_9, int64_t src_stride_10, int64_t src_shape_11);
static int futrts_builtinzhgpu_map_transpose_f32(struct futhark_context *ctx, struct memblock_device destmem_0, int64_t destoffset_1, struct memblock_device srcmem_2, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6);
static int futrts_builtinzhgpu_map_transpose_i64(struct futhark_context *ctx, struct memblock_device destmem_0, int64_t destoffset_1, struct memblock_device srcmem_2, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6);
static int futrts_builtinzhreplicate_f32(struct futhark_context *ctx, struct memblock_device mem_26109, int64_t num_elems_26110, float val_26111);
static int futrts_builtinzhreplicate_i32(struct futhark_context *ctx, struct memblock_device mem_26262, int64_t num_elems_26263, int32_t val_26264);
static int futrts_builtinzhreplicate_i64(struct futhark_context *ctx, struct memblock_device mem_26129, int64_t num_elems_26130, int64_t val_26131);
static int futrts_entry_grab_mouse(struct futhark_context *ctx, bool *out_prim_out_26534);
static int futrts_entry_init(struct futhark_context *ctx, bool *out_prim_out_26535, float *out_prim_out_26536, int8_t *out_prim_out_26537, int64_t *out_prim_out_26538, int64_t *out_prim_out_26539, float *out_prim_out_26540, int64_t *out_prim_out_26541, int32_t *out_prim_out_26542, int32_t *out_prim_out_26543, float *out_prim_out_26544, float *out_prim_out_26545, float *out_prim_out_26546, float *out_prim_out_26547, int64_t *out_prim_out_26548, float *out_prim_out_26549, float *out_prim_out_26550, float *out_prim_out_26551, float *out_prim_out_26552, float *out_prim_out_26553, int64_t *out_prim_out_26554, int32_t seed_16471, int32_t h_16472, int32_t w_16473);
static int futrts_entry_key(struct futhark_context *ctx, bool *out_prim_out_26555, float *out_prim_out_26556, int8_t *out_prim_out_26557, int64_t *out_prim_out_26558, int64_t *out_prim_out_26559, float *out_prim_out_26560, int64_t *out_prim_out_26561, int32_t *out_prim_out_26562, int32_t *out_prim_out_26563, float *out_prim_out_26564, float *out_prim_out_26565, float *out_prim_out_26566, float *out_prim_out_26567, int64_t *out_prim_out_26568, float *out_prim_out_26569, float *out_prim_out_26570, float *out_prim_out_26571, float *out_prim_out_26572, float *out_prim_out_26573, int64_t *out_prim_out_26574, int32_t e_17618, int32_t key_17619, bool auto_zzoom_17620, float auto_zzoom_17621, int8_t base_17622, int64_t base_17623, int64_t base_17624, float base_17625, int64_t height_17626, int32_t mouse_17627, int32_t mouse_17628, float screen_calculations_17629, float screen_calculations_17630, float screen_calculations_17631, float screen_calculations_17632, int64_t screen_calculations_17633, float screen_calculations_17634, float screen_calculations_17635, float viewport_17636, float viewport_17637, float viewport_17638, int64_t width_17639);
static int futrts_entry_mouse(struct futhark_context *ctx, bool *out_prim_out_26575, float *out_prim_out_26576, int8_t *out_prim_out_26577, int64_t *out_prim_out_26578, int64_t *out_prim_out_26579, float *out_prim_out_26580, int64_t *out_prim_out_26581, int32_t *out_prim_out_26582, int32_t *out_prim_out_26583, float *out_prim_out_26584, float *out_prim_out_26585, float *out_prim_out_26586, float *out_prim_out_26587, int64_t *out_prim_out_26588, float *out_prim_out_26589, float *out_prim_out_26590, float *out_prim_out_26591, float *out_prim_out_26592, float *out_prim_out_26593, int64_t *out_prim_out_26594, int32_t buttons_17708, int32_t x_17709, int32_t y_17710, bool auto_zzoom_17711, float auto_zzoom_17712, int8_t base_17713, int64_t base_17714, int64_t base_17715, float base_17716, int64_t height_17717, int32_t mouse_17718, int32_t mouse_17719, float screen_calculations_17720, float screen_calculations_17721, float screen_calculations_17722, float screen_calculations_17723, int64_t screen_calculations_17724, float screen_calculations_17725, float screen_calculations_17726, float viewport_17727, float viewport_17728, float viewport_17729, int64_t width_17730);
static int futrts_entry_render(struct futhark_context *ctx, struct memblock_device *mem_out_p_26595, int64_t *out_prim_out_26596, int64_t *out_prim_out_26597, bool auto_zzoom_20348, float auto_zzoom_20349, int8_t base_20350, int64_t base_20351, int64_t base_20352, float base_20353, int64_t height_20354, int32_t mouse_20355, int32_t mouse_20356, float screen_calculations_20357, float screen_calculations_20358, float screen_calculations_20359, float screen_calculations_20360, int64_t screen_calculations_20361, float screen_calculations_20362, float screen_calculations_20363, float viewport_20364, float viewport_20365, float viewport_20366, int64_t width_20367);
static int futrts_entry_resizze(struct futhark_context *ctx, bool *out_prim_out_26599, float *out_prim_out_26600, int8_t *out_prim_out_26601, int64_t *out_prim_out_26602, int64_t *out_prim_out_26603, float *out_prim_out_26604, int64_t *out_prim_out_26605, int32_t *out_prim_out_26606, int32_t *out_prim_out_26607, float *out_prim_out_26608, float *out_prim_out_26609, float *out_prim_out_26610, float *out_prim_out_26611, int64_t *out_prim_out_26612, float *out_prim_out_26613, float *out_prim_out_26614, float *out_prim_out_26615, float *out_prim_out_26616, float *out_prim_out_26617, int64_t *out_prim_out_26618, int32_t h_16698, int32_t w_16699, bool auto_zzoom_16700, float auto_zzoom_16701, int8_t base_16702, int64_t base_16703, int64_t base_16704, float base_16705, int64_t height_16706, int32_t mouse_16707, int32_t mouse_16708, float screen_calculations_16709, float screen_calculations_16710, float screen_calculations_16711, float screen_calculations_16712, int64_t screen_calculations_16713, float screen_calculations_16714, float screen_calculations_16715, float viewport_16716, float viewport_16717, float viewport_16718, int64_t width_16719);
static int futrts_entry_step(struct futhark_context *ctx, bool *out_prim_out_26619, float *out_prim_out_26620, int8_t *out_prim_out_26621, int64_t *out_prim_out_26622, int64_t *out_prim_out_26623, float *out_prim_out_26624, int64_t *out_prim_out_26625, int32_t *out_prim_out_26626, int32_t *out_prim_out_26627, float *out_prim_out_26628, float *out_prim_out_26629, float *out_prim_out_26630, float *out_prim_out_26631, int64_t *out_prim_out_26632, float *out_prim_out_26633, float *out_prim_out_26634, float *out_prim_out_26635, float *out_prim_out_26636, float *out_prim_out_26637, int64_t *out_prim_out_26638, float td_17886, bool auto_zzoom_17887, float auto_zzoom_17888, int8_t base_17889, int64_t base_17890, int64_t base_17891, float base_17892, int64_t height_17893, int32_t mouse_17894, int32_t mouse_17895, float screen_calculations_17896, float screen_calculations_17897, float screen_calculations_17898, float screen_calculations_17899, int64_t screen_calculations_17900, float screen_calculations_17901, float screen_calculations_17902, float viewport_17903, float viewport_17904, float viewport_17905, int64_t width_17906);
static int futrts_entry_text_colour(struct futhark_context *ctx, int32_t *out_prim_out_26639, bool auto_zzoom_20413, float auto_zzoom_20414, int8_t base_20415, int64_t base_20416, int64_t base_20417, float base_20418, int64_t height_20419, int32_t mouse_20420, int32_t mouse_20421, float screen_calculations_20422, float screen_calculations_20423, float screen_calculations_20424, float screen_calculations_20425, int64_t screen_calculations_20426, float screen_calculations_20427, float screen_calculations_20428, float viewport_20429, float viewport_20430, float viewport_20431, int64_t width_20432);
static int futrts_entry_text_content(struct futhark_context *ctx, int32_t *out_prim_out_26640, int32_t *out_prim_out_26641, float *out_prim_out_26642, float *out_prim_out_26643, float *out_prim_out_26644, int32_t *out_prim_out_26645, float render_duration_20548, bool auto_zzoom_20549, float auto_zzoom_20550, int8_t base_20551, int64_t base_20552, int64_t base_20553, float base_20554, int64_t height_20555, int32_t mouse_20556, int32_t mouse_20557, float screen_calculations_20558, float screen_calculations_20559, float screen_calculations_20560, float screen_calculations_20561, int64_t screen_calculations_20562, float screen_calculations_20563, float screen_calculations_20564, float viewport_20565, float viewport_20566, float viewport_20567, int64_t width_20568);
static int futrts_entry_text_format(struct futhark_context *ctx, struct memblock_device *mem_out_p_26646, int64_t *out_prim_out_26647);
static int futrts_entry_wheel(struct futhark_context *ctx, bool *out_prim_out_26648, float *out_prim_out_26649, int8_t *out_prim_out_26650, int64_t *out_prim_out_26651, int64_t *out_prim_out_26652, float *out_prim_out_26653, int64_t *out_prim_out_26654, int32_t *out_prim_out_26655, int32_t *out_prim_out_26656, float *out_prim_out_26657, float *out_prim_out_26658, float *out_prim_out_26659, float *out_prim_out_26660, int64_t *out_prim_out_26661, float *out_prim_out_26662, float *out_prim_out_26663, float *out_prim_out_26664, float *out_prim_out_26665, float *out_prim_out_26666, int64_t *out_prim_out_26667, int32_t dx_17798, int32_t dy_17799, bool auto_zzoom_17800, float auto_zzoom_17801, int8_t base_17802, int64_t base_17803, int64_t base_17804, float base_17805, int64_t height_17806, int32_t mouse_17807, int32_t mouse_17808, float screen_calculations_17809, float screen_calculations_17810, float screen_calculations_17811, float screen_calculations_17812, int64_t screen_calculations_17813, float screen_calculations_17814, float screen_calculations_17815, float viewport_17816, float viewport_17817, float viewport_17818, int64_t width_17819);

static int init_constants(struct futhark_context *ctx)
{
    (void) ctx;
    
    int err = 0;
    
    #define counters_mem_26260 (ctx->constants->counters_mem_26260)
    #define mem_25847 (ctx->constants->mem_25847)
    counters_mem_26260.references = NULL;
    mem_25847.references = NULL;
    if (memblock_alloc_device(ctx, &mem_25847, (int64_t) 119, "mem_25847")) {
        err = 1;
        goto cleanup;
    }
    
    struct memblock static_array_26532 = (struct memblock) {NULL, (unsigned char *) static_array_realtype_26533, 0, "static_array_26532"};
    
    if ((int64_t) 119 > 0)
        OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->queue, mem_25847.mem, CL_TRUE, (size_t) (int64_t) 0, (size_t) (int64_t) 119, static_array_26532.mem + (int64_t) 0, 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_dev_to_host")));
    if (memblock_alloc_device(ctx, &counters_mem_26260, (int64_t) 40960, "counters_mem_26260")) {
        err = 1;
        goto cleanup;
    }
    if (futrts_builtinzhreplicate_i32(ctx, counters_mem_26260, (int64_t) 10240, 0) != 0) {
        err = 1;
        goto cleanup;
    }
    #undef counters_mem_26260
    #undef mem_25847
    
  cleanup:
    return err;
}
static int free_constants(struct futhark_context *ctx)
{
    (void) ctx;
    if (memblock_unref_device(ctx, &ctx->constants->counters_mem_26260, "ctx->constants->counters_mem_26260") != 0)
        return 1;
    if (memblock_unref_device(ctx, &ctx->constants->mem_25847, "ctx->constants->mem_25847") != 0)
        return 1;
    return 0;
}
static int gpu_kernel_copy_1d_i8(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, cl_mem arg7, cl_mem arg8)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_1d_i8, 0, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_1d_i8, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_1d_i8, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_1d_i8, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_1d_i8, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_1d_i8, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_1d_i8, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_1d_i8, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_1d_i8, 8, sizeof(arg8), &arg8));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "copy_1d_i8", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_1d_i8");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->copy_1d_i8, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "copy_1d_i8", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_copy_2d_f32(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, cl_mem arg11, cl_mem arg12)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 0, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 9, sizeof(arg9), &arg9));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 10, sizeof(arg10), &arg10));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 11, sizeof(arg11), &arg11));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_f32, 12, sizeof(arg12), &arg12));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "copy_2d_f32", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_2d_f32");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->copy_2d_f32, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "copy_2d_f32", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_copy_2d_i64(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, cl_mem arg11, cl_mem arg12)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 0, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 9, sizeof(arg9), &arg9));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 10, sizeof(arg10), &arg10));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 11, sizeof(arg11), &arg11));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->copy_2d_i64, 12, sizeof(arg12), &arg12));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "copy_2d_i64", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_2d_i64");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->copy_2d_i64, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "copy_2d_i64", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_f32_low_width_i32(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i32, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i32, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i32, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i32, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i32, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i32, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i32, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i32, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i32, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i32, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_f32_low_width_i32", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_f32_low_width_i32");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_f32_low_width_i32, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_f32_low_width_i32", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_f32_low_width_i64(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i64, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i64, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i64, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i64, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i64, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i64, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i64, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i64, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i64, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_width_i64, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_f32_low_width_i64", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_f32_low_width_i64");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_f32_low_width_i64, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_f32_low_width_i64", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_f32_low_height_i32(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i32, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i32, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i32, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i32, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i32, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i32, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i32, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i32, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i32, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i32, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_f32_low_height_i32", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_f32_low_height_i32");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_f32_low_height_i32, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_f32_low_height_i32", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_f32_low_height_i64(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i64, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i64, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i64, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i64, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i64, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i64, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i64, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i64, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i64, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_low_height_i64, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_f32_low_height_i64", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_f32_low_height_i64");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_f32_low_height_i64, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_f32_low_height_i64", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_f32_small_i32(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i32, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i32, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i32, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i32, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i32, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i32, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i32, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i32, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i32, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i32, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_f32_small_i32", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_f32_small_i32");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_f32_small_i32, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_f32_small_i32", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_f32_small_i64(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i64, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i64, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i64, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i64, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i64, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i64, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i64, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i64, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i64, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_small_i64, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_f32_small_i64", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_f32_small_i64");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_f32_small_i64, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_f32_small_i64", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_f32_i32(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i32, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i32, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i32, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i32, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i32, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i32, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i32, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i32, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i32, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i32, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_f32_i32", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_f32_i32");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_f32_i32, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_f32_i32", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_f32_i64(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i64, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i64, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i64, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i64, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i64, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i64, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i64, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i64, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i64, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_f32_i64, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_f32_i64", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_f32_i64");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_f32_i64, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_f32_i64", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_i64_low_width_i32(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i32, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i32, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i32, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i32, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i32, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i32, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i32, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i32, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i32, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i32, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_i64_low_width_i32", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_i64_low_width_i32");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_i64_low_width_i32, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_i64_low_width_i32", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_i64_low_width_i64(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i64, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i64, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i64, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i64, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i64, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i64, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i64, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i64, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i64, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_width_i64, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_i64_low_width_i64", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_i64_low_width_i64");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_i64_low_width_i64, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_i64_low_width_i64", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_i64_low_height_i32(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i32, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i32, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i32, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i32, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i32, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i32, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i32, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i32, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i32, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i32, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_i64_low_height_i32", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_i64_low_height_i32");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_i64_low_height_i32, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_i64_low_height_i32", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_i64_low_height_i64(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i64, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i64, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i64, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i64, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i64, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i64, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i64, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i64, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i64, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_low_height_i64, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_i64_low_height_i64", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_i64_low_height_i64");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_i64_low_height_i64, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_i64_low_height_i64", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_i64_small_i32(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i32, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i32, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i32, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i32, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i32, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i32, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i32, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i32, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i32, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i32, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_i64_small_i32", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_i64_small_i32");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_i64_small_i32, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_i64_small_i32", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_i64_small_i64(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i64, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i64, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i64, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i64, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i64, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i64, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i64, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i64, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i64, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_small_i64, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_i64_small_i64", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_i64_small_i64");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_i64_small_i64, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_i64_small_i64", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_i64_i32(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i32, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i32, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i32, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i32, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i32, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i32, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i32, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i32, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i32, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i32, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_i64_i32", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_i64_i32");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_i64_i32, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_i64_i32", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_gpu_map_transpose_i64_i64(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i64, 0, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i64, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i64, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i64, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i64, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i64, 5, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i64, 6, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i64, 7, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i64, 8, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->gpu_map_transpose_i64_i64, 9, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "gpu_map_transpose_i64_i64", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "gpu_map_transpose_i64_i64");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->gpu_map_transpose_i64_i64, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "gpu_map_transpose_i64_i64", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_builtinzhreplicate_f32zireplicate_26114(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, float arg1, int64_t arg2, int64_t arg3, int64_t arg4, cl_mem arg5)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_f32zireplicate_26114, 0, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_f32zireplicate_26114, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_f32zireplicate_26114, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_f32zireplicate_26114, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_f32zireplicate_26114, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_f32zireplicate_26114, 5, sizeof(arg5), &arg5));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "builtin#replicate_f32.replicate_26114", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "builtin#replicate_f32.replicate_26114");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->builtinzhreplicate_f32zireplicate_26114, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "builtin#replicate_f32.replicate_26114", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_builtinzhreplicate_i32zireplicate_26267(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int32_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, cl_mem arg5)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i32zireplicate_26267, 0, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i32zireplicate_26267, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i32zireplicate_26267, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i32zireplicate_26267, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i32zireplicate_26267, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i32zireplicate_26267, 5, sizeof(arg5), &arg5));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "builtin#replicate_i32.replicate_26267", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "builtin#replicate_i32.replicate_26267");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->builtinzhreplicate_i32zireplicate_26267, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "builtin#replicate_i32.replicate_26267", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_builtinzhreplicate_i64zireplicate_26134(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, cl_mem arg5)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i64zireplicate_26134, 0, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i64zireplicate_26134, 1, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i64zireplicate_26134, 2, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i64zireplicate_26134, 3, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i64zireplicate_26134, 4, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->builtinzhreplicate_i64zireplicate_26134, 5, sizeof(arg5), &arg5));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "builtin#replicate_i64.replicate_26134", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "builtin#replicate_i64.replicate_26134");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->builtinzhreplicate_i64zireplicate_26134, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "builtin#replicate_i64.replicate_26134", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_24379(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int32_t arg2, cl_mem arg3, cl_mem arg4, cl_mem arg5, cl_mem arg6, cl_mem arg7, cl_mem arg8, cl_mem arg9, cl_mem arg10, cl_mem arg11, cl_mem arg12, cl_mem arg13, cl_mem arg14)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 7, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 8, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 9, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 10, sizeof(arg9), &arg9));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 11, sizeof(arg10), &arg10));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 12, sizeof(arg11), &arg11));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 13, sizeof(arg12), &arg12));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 14, sizeof(arg13), &arg13));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24379, 15, sizeof(arg14), &arg14));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_24379", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_24379");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_24379, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_24379", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_24855(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int32_t arg2, cl_mem arg3, cl_mem arg4, cl_mem arg5, cl_mem arg6, cl_mem arg7, cl_mem arg8, cl_mem arg9)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24855, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24855, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24855, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24855, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24855, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24855, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24855, 7, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24855, 8, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24855, 9, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24855, 10, sizeof(arg9), &arg9));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_24855", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_24855");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_24855, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_24855", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegred_small_24912(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int64_t arg3, cl_mem arg4, cl_mem arg5, cl_mem arg6, cl_mem arg7)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_small_24912, 1, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_small_24912, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_small_24912, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_small_24912, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_small_24912, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_small_24912, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_small_24912, 7, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_small_24912, 8, sizeof(arg7), &arg7));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segred_small_24912", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segred_small_24912");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegred_small_24912, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segred_small_24912", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegred_large_24912(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, unsigned int arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t arg5, int64_t arg6, int64_t arg7, cl_mem arg8, cl_mem arg9, cl_mem arg10, cl_mem arg11, cl_mem arg12, cl_mem arg13)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 1, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 2, arg1, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 7, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 8, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 9, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 10, sizeof(arg9), &arg9));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 11, sizeof(arg10), &arg10));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 12, sizeof(arg11), &arg11));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 13, sizeof(arg12), &arg12));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegred_large_24912, 14, sizeof(arg13), &arg13));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segred_large_24912", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segred_large_24912");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegred_large_24912, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segred_large_24912", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_24925(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, cl_mem arg1, cl_mem arg2, cl_mem arg3)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24925, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24925, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24925, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24925, 4, sizeof(arg3), &arg3));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_24925", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_24925");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_24925, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_24925", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_24941(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, cl_mem arg1, cl_mem arg2, cl_mem arg3)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24941, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24941, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24941, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24941, 4, sizeof(arg3), &arg3));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_24941", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_24941");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_24941, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_24941", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_24954(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int32_t arg2, cl_mem arg3, cl_mem arg4, cl_mem arg5, cl_mem arg6, cl_mem arg7, cl_mem arg8)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24954, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24954, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24954, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24954, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24954, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24954, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24954, 7, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24954, 8, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24954, 9, sizeof(arg8), &arg8));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_24954", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_24954");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_24954, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_24954", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_24976(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, cl_mem arg1, cl_mem arg2)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24976, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24976, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24976, 3, sizeof(arg2), &arg2));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_24976", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_24976");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_24976, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_24976", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_24992(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, cl_mem arg1, cl_mem arg2, cl_mem arg3, cl_mem arg4)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24992, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24992, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24992, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24992, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_24992, 5, sizeof(arg4), &arg4));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_24992", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_24992");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_24992, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_24992", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderziscan_stage1_25070(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, float arg2, float arg3, float arg4, float arg5, float arg6, float arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11, int32_t arg12, cl_mem arg13, cl_mem arg14, cl_mem arg15, cl_mem arg16)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 1, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 7, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 8, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 9, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 10, sizeof(arg9), &arg9));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 11, sizeof(arg10), &arg10));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 12, sizeof(arg11), &arg11));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 13, sizeof(arg12), &arg12));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 14, sizeof(arg13), &arg13));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 15, sizeof(arg14), &arg14));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 16, sizeof(arg15), &arg15));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage1_25070, 17, sizeof(arg16), &arg16));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.scan_stage1_25070", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.scan_stage1_25070");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderziscan_stage1_25070, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.scan_stage1_25070", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderziscan_stage2_25070(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, unsigned int arg0, int64_t arg1, int64_t arg2, int32_t arg3, cl_mem arg4)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage2_25070, 1, arg0, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage2_25070, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage2_25070, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage2_25070, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage2_25070, 5, sizeof(arg4), &arg4));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.scan_stage2_25070", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.scan_stage2_25070");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderziscan_stage2_25070, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.scan_stage2_25070", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderziscan_stage3_25070(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int32_t arg2, int32_t arg3, cl_mem arg4)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage3_25070, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage3_25070, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage3_25070, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage3_25070, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderziscan_stage3_25070, 5, sizeof(arg4), &arg4));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.scan_stage3_25070", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.scan_stage3_25070");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderziscan_stage3_25070, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.scan_stage3_25070", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_25072(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, cl_mem arg2, cl_mem arg3, cl_mem arg4, cl_mem arg5, cl_mem arg6, cl_mem arg7, cl_mem arg8, cl_mem arg9, cl_mem arg10, cl_mem arg11, cl_mem arg12, cl_mem arg13, cl_mem arg14, cl_mem arg15)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 7, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 8, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 9, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 10, sizeof(arg9), &arg9));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 11, sizeof(arg10), &arg10));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 12, sizeof(arg11), &arg11));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 13, sizeof(arg12), &arg12));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 14, sizeof(arg13), &arg13));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 15, sizeof(arg14), &arg14));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25072, 16, sizeof(arg15), &arg15));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_25072", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_25072");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_25072, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_25072", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_25105(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, float arg0, float arg1, float arg2, float arg3, float arg4, float arg5, int64_t arg6, cl_mem arg7, cl_mem arg8, cl_mem arg9, cl_mem arg10)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 7, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 8, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 9, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 10, sizeof(arg9), &arg9));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25105, 11, sizeof(arg10), &arg10));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_25105", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_25105");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_25105, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_25105", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_25121(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int64_t arg2, cl_mem arg3, cl_mem arg4, cl_mem arg5, cl_mem arg6)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25121, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25121, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25121, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25121, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25121, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25121, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25121, 7, sizeof(arg6), &arg6));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_25121", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_25121");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_25121, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_25121", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_25300(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, cl_mem arg2, cl_mem arg3)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25300, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25300, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25300, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25300, 4, sizeof(arg3), &arg3));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_25300", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_25300");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_25300, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_25300", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_25398(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, float arg0, float arg1, float arg2, float arg3, float arg4, float arg5, int64_t arg6, cl_mem arg7, cl_mem arg8, cl_mem arg9, cl_mem arg10)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 7, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 8, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 9, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 10, sizeof(arg9), &arg9));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25398, 11, sizeof(arg10), &arg10));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_25398", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_25398");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_25398, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_25398", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_25414(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int64_t arg2, cl_mem arg3, cl_mem arg4, cl_mem arg5, cl_mem arg6)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25414, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25414, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25414, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25414, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25414, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25414, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25414, 7, sizeof(arg6), &arg6));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_25414", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_25414");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_25414, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_25414", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_25577(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, cl_mem arg2, cl_mem arg3)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25577, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25577, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25577, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25577, 4, sizeof(arg3), &arg3));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_25577", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_25577");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_25577, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_25577", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_25667(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, float arg0, float arg1, float arg2, float arg3, float arg4, float arg5, int64_t arg6, cl_mem arg7, cl_mem arg8, cl_mem arg9, cl_mem arg10)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 7, sizeof(arg6), &arg6));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 8, sizeof(arg7), &arg7));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 9, sizeof(arg8), &arg8));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 10, sizeof(arg9), &arg9));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25667, 11, sizeof(arg10), &arg10));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_25667", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_25667");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_25667, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_25667", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_25683(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, int64_t arg2, cl_mem arg3, cl_mem arg4, cl_mem arg5, cl_mem arg6)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25683, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25683, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25683, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25683, 4, sizeof(arg3), &arg3));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25683, 5, sizeof(arg4), &arg4));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25683, 6, sizeof(arg5), &arg5));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25683, 7, sizeof(arg6), &arg6));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_25683", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_25683");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_25683, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_25683", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
static int gpu_kernel_renderzisegmap_25770(struct futhark_context *ctx, unsigned int grid_x, unsigned int grid_y, unsigned int grid_z, unsigned int block_x, unsigned int block_y, unsigned int block_z, unsigned int local_bytes, int64_t arg0, int64_t arg1, cl_mem arg2, cl_mem arg3)
{
    (void) local_bytes;
    if (grid_x * grid_y * grid_z * block_x * block_y * block_z != 0) {
        const size_t global_work_size[3] = {grid_x * block_x, grid_y * block_y, grid_z * block_z};
        const size_t local_work_size[3] = {block_x, block_y, block_z};
        int64_t time_start = 0, time_end = 0;
        
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25770, 1, sizeof(arg0), &arg0));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25770, 2, sizeof(arg1), &arg1));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25770, 3, sizeof(arg2), &arg2));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->program->renderzisegmap_25770, 4, sizeof(arg3), &arg3));
        if (ctx->debugging) {
            fprintf(ctx->log, "Launching %s with grid size [%d, %d, %d] and group size [%d, %d, %d]; local memory: %d bytes.\n", "render.segmap_25770", grid_x, grid_y, grid_z, block_x, block_y, block_z, local_bytes);
            time_start = get_wall_time();
        }
        
        cl_event *pevent = ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "render.segmap_25770");
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->queue, ctx->program->renderzisegmap_25770, 3, NULL, global_work_size, local_work_size, 0, NULL, pevent));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            time_end = get_wall_time();
            
            long time_diff = time_end - time_start;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "render.segmap_25770", time_diff);
        }
    }
    return FUTHARK_SUCCESS;
}
struct futhark_u8_1d {
    struct memblock_device mem;
    int64_t shape[1];
};
struct futhark_u8_1d *futhark_new_u8_1d(struct futhark_context *ctx, const uint8_t *data, int64_t dim0)
{
    struct futhark_u8_1d *bad = NULL;
    struct futhark_u8_1d *arr = (struct futhark_u8_1d *) malloc(sizeof(struct futhark_u8_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, dim0 * 1, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 1 > 0)
        OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->queue, arr->mem.mem, CL_FALSE, (size_t) 0, (size_t) ((size_t) dim0 * 1), data + 0, 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_dev_to_host")));
    lock_unlock(&ctx->lock);
    return arr;
}
struct futhark_u8_1d *futhark_new_raw_u8_1d(struct futhark_context *ctx, const cl_mem data, int64_t offset, int64_t dim0)
{
    struct futhark_u8_1d *bad = NULL;
    struct futhark_u8_1d *arr = (struct futhark_u8_1d *) malloc(sizeof(struct futhark_u8_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, dim0 * 1, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 1 > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->queue, data, arr->mem.mem, (size_t) offset, (size_t) 0, (size_t) ((size_t) dim0 * 1), 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_dev_to_dev")));
        if (ctx->debugging)
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
    }
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_u8_1d(struct futhark_context *ctx, struct futhark_u8_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref_device(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_u8_1d(struct futhark_context *ctx, struct futhark_u8_1d *arr, uint8_t *data)
{
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 1 > 0) {
        cl_bool sync_call = CL_FALSE;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->queue, arr->mem.mem, ctx->failure_is_an_option ? CL_FALSE : sync_call, (size_t) 0, (size_t) ((size_t) arr->shape[0] * 1), data + 0, 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_host_to_dev")));
        if ((sync_call && ctx->failure_is_an_option) && futhark_context_sync(ctx) != 0)
            return 1;
    }
    lock_unlock(&ctx->lock);
    return 0;
}
cl_mem futhark_values_raw_u8_1d(struct futhark_context *ctx, struct futhark_u8_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_u8_1d(struct futhark_context *ctx, struct futhark_u8_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_u32_2d {
    struct memblock_device mem;
    int64_t shape[2];
};
struct futhark_u32_2d *futhark_new_u32_2d(struct futhark_context *ctx, const uint32_t *data, int64_t dim0, int64_t dim1)
{
    struct futhark_u32_2d *bad = NULL;
    struct futhark_u32_2d *arr = (struct futhark_u32_2d *) malloc(sizeof(struct futhark_u32_2d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, dim0 * dim1 * 4, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    if ((size_t) (dim0 * dim1) * 4 > 0)
        OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->queue, arr->mem.mem, CL_FALSE, (size_t) 0, (size_t) ((size_t) (dim0 * dim1) * 4), data + 0, 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_dev_to_host")));
    lock_unlock(&ctx->lock);
    return arr;
}
struct futhark_u32_2d *futhark_new_raw_u32_2d(struct futhark_context *ctx, const cl_mem data, int64_t offset, int64_t dim0, int64_t dim1)
{
    struct futhark_u32_2d *bad = NULL;
    struct futhark_u32_2d *arr = (struct futhark_u32_2d *) malloc(sizeof(struct futhark_u32_2d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, dim0 * dim1 * 4, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    if ((size_t) (dim0 * dim1) * 4 > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->queue, data, arr->mem.mem, (size_t) offset, (size_t) 0, (size_t) ((size_t) (dim0 * dim1) * 4), 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_dev_to_dev")));
        if (ctx->debugging)
            OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
    }
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_u32_2d(struct futhark_context *ctx, struct futhark_u32_2d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref_device(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_u32_2d(struct futhark_context *ctx, struct futhark_u32_2d *arr, uint32_t *data)
{
    lock_lock(&ctx->lock);
    if ((size_t) (arr->shape[0] * arr->shape[1]) * 4 > 0) {
        cl_bool sync_call = CL_FALSE;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->queue, arr->mem.mem, ctx->failure_is_an_option ? CL_FALSE : sync_call, (size_t) 0, (size_t) ((size_t) (arr->shape[0] * arr->shape[1]) * 4), data + 0, 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_host_to_dev")));
        if ((sync_call && ctx->failure_is_an_option) && futhark_context_sync(ctx) != 0)
            return 1;
    }
    lock_unlock(&ctx->lock);
    return 0;
}
cl_mem futhark_values_raw_u32_2d(struct futhark_context *ctx, struct futhark_u32_2d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_u32_2d(struct futhark_context *ctx, struct futhark_u32_2d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_opaque_f5b98ad5 {
    bool v0;
    float v1;
};
int futhark_project_opaque_f5b98ad5_enabled(struct futhark_context *ctx, bool *out, const struct futhark_opaque_f5b98ad5 *obj)
{
    (void) ctx;
    
    bool v;
    
    v = obj->v0;
    *out = v;
    return 0;
}
int futhark_project_opaque_f5b98ad5_factor(struct futhark_context *ctx, float *out, const struct futhark_opaque_f5b98ad5 *obj)
{
    (void) ctx;
    
    float v;
    
    v = obj->v1;
    *out = v;
    return 0;
}
int futhark_new_opaque_f5b98ad5(struct futhark_context *ctx, struct futhark_opaque_f5b98ad5 **out, const bool f_enabled, const float f_factor)
{
    struct futhark_opaque_f5b98ad5 *v = malloc(sizeof(struct futhark_opaque_f5b98ad5));
    
    lock_lock(&ctx->lock);
    v->v0 = f_enabled;
    v->v1 = f_factor;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_free_opaque_f5b98ad5(struct futhark_context *ctx, struct futhark_opaque_f5b98ad5 *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    free(obj);
    return ret;
}
int futhark_store_opaque_f5b98ad5(struct futhark_context *ctx, const struct futhark_opaque_f5b98ad5 *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(bool);
    int64_t size_1 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, "bool", 4);
        out += 4;
        memcpy(out, &obj->v0, sizeof(obj->v0));
        out += sizeof(obj->v0);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v1, sizeof(obj->v1));
        out += sizeof(obj->v1);
    }
    return ret;
}
struct futhark_opaque_f5b98ad5 *futhark_restore_opaque_f5b98ad5(struct futhark_context *ctx, const void *p)
{
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_f5b98ad5 *obj = malloc(sizeof(struct futhark_opaque_f5b98ad5));
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, "bool", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    src += sizeof(obj->v0);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    src += sizeof(obj->v1);
    if (err == 0) {
        memcpy(&obj->v0, data_0, sizeof(obj->v0));
        memcpy(&obj->v1, data_1, sizeof(obj->v1));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_b2de7ac {
    int8_t v0;
};
int futhark_free_opaque_b2de7ac(struct futhark_context *ctx, struct futhark_opaque_b2de7ac *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    free(obj);
    return ret;
}
int futhark_store_opaque_b2de7ac(struct futhark_context *ctx, const struct futhark_opaque_b2de7ac *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int8_t);
    
    *n = size_0;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, "  i8", 4);
        out += 4;
        memcpy(out, &obj->v0, sizeof(obj->v0));
        out += sizeof(obj->v0);
    }
    return ret;
}
struct futhark_opaque_b2de7ac *futhark_restore_opaque_b2de7ac(struct futhark_context *ctx, const void *p)
{
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_b2de7ac *obj = malloc(sizeof(struct futhark_opaque_b2de7ac));
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, "  i8", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    src += sizeof(obj->v0);
    if (err == 0) {
        memcpy(&obj->v0, data_0, sizeof(obj->v0));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_86dd06d3 {
    uint64_t v0;
    uint64_t v1;
};
int futhark_project_opaque_86dd06d3_0(struct futhark_context *ctx, uint64_t *out, const struct futhark_opaque_86dd06d3 *obj)
{
    (void) ctx;
    
    uint64_t v;
    
    v = obj->v0;
    *out = v;
    return 0;
}
int futhark_project_opaque_86dd06d3_1(struct futhark_context *ctx, uint64_t *out, const struct futhark_opaque_86dd06d3 *obj)
{
    (void) ctx;
    
    uint64_t v;
    
    v = obj->v1;
    *out = v;
    return 0;
}
int futhark_new_opaque_86dd06d3(struct futhark_context *ctx, struct futhark_opaque_86dd06d3 **out, const uint64_t v0, const uint64_t v1)
{
    struct futhark_opaque_86dd06d3 *v = malloc(sizeof(struct futhark_opaque_86dd06d3));
    
    lock_lock(&ctx->lock);
    v->v0 = v0;
    v->v1 = v1;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_free_opaque_86dd06d3(struct futhark_context *ctx, struct futhark_opaque_86dd06d3 *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    free(obj);
    return ret;
}
int futhark_store_opaque_86dd06d3(struct futhark_context *ctx, const struct futhark_opaque_86dd06d3 *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int64_t);
    int64_t size_1 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int64_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " u64", 4);
        out += 4;
        memcpy(out, &obj->v0, sizeof(obj->v0));
        out += sizeof(obj->v0);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " u64", 4);
        out += 4;
        memcpy(out, &obj->v1, sizeof(obj->v1));
        out += sizeof(obj->v1);
    }
    return ret;
}
struct futhark_opaque_86dd06d3 *futhark_restore_opaque_86dd06d3(struct futhark_context *ctx, const void *p)
{
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_86dd06d3 *obj = malloc(sizeof(struct futhark_opaque_86dd06d3));
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " u64", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    src += sizeof(obj->v0);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " u64", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    src += sizeof(obj->v1);
    if (err == 0) {
        memcpy(&obj->v0, data_0, sizeof(obj->v0));
        memcpy(&obj->v1, data_1, sizeof(obj->v1));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_40c80b6a {
    int8_t v0;
    uint64_t v1;
    uint64_t v2;
    float v3;
};
int futhark_project_opaque_40c80b6a_approach(struct futhark_context *ctx, struct futhark_opaque_b2de7ac **out, const struct futhark_opaque_40c80b6a *obj)
{
    (void) ctx;
    
    struct futhark_opaque_b2de7ac *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_opaque_b2de7ac));
    v->v0 = obj->v0;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_40c80b6a_rng(struct futhark_context *ctx, struct futhark_opaque_86dd06d3 **out, const struct futhark_opaque_40c80b6a *obj)
{
    (void) ctx;
    
    struct futhark_opaque_86dd06d3 *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_opaque_86dd06d3));
    v->v0 = obj->v1;
    v->v1 = obj->v2;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_40c80b6a_time(struct futhark_context *ctx, float *out, const struct futhark_opaque_40c80b6a *obj)
{
    (void) ctx;
    
    float v;
    
    v = obj->v3;
    *out = v;
    return 0;
}
int futhark_new_opaque_40c80b6a(struct futhark_context *ctx, struct futhark_opaque_40c80b6a **out, const struct futhark_opaque_b2de7ac *f_approach, const struct futhark_opaque_86dd06d3 *f_rng, const float f_time)
{
    struct futhark_opaque_40c80b6a *v = malloc(sizeof(struct futhark_opaque_40c80b6a));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = f_approach->v0;
    }
    {
        v->v1 = f_rng->v0;
        v->v2 = f_rng->v1;
    }
    v->v3 = f_time;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_free_opaque_40c80b6a(struct futhark_context *ctx, struct futhark_opaque_40c80b6a *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    free(obj);
    return ret;
}
int futhark_store_opaque_40c80b6a(struct futhark_context *ctx, const struct futhark_opaque_40c80b6a *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int8_t);
    int64_t size_1 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int64_t);
    int64_t size_2 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int64_t);
    int64_t size_3 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    
    *n = size_0 + size_1 + size_2 + size_3;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, "  i8", 4);
        out += 4;
        memcpy(out, &obj->v0, sizeof(obj->v0));
        out += sizeof(obj->v0);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " u64", 4);
        out += 4;
        memcpy(out, &obj->v1, sizeof(obj->v1));
        out += sizeof(obj->v1);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " u64", 4);
        out += 4;
        memcpy(out, &obj->v2, sizeof(obj->v2));
        out += sizeof(obj->v2);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v3, sizeof(obj->v3));
        out += sizeof(obj->v3);
    }
    return ret;
}
struct futhark_opaque_40c80b6a *futhark_restore_opaque_40c80b6a(struct futhark_context *ctx, const void *p)
{
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_40c80b6a *obj = malloc(sizeof(struct futhark_opaque_40c80b6a));
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, "  i8", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    src += sizeof(obj->v0);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " u64", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    src += sizeof(obj->v1);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " u64", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    src += sizeof(obj->v2);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_3 = src;
    
    src += sizeof(obj->v3);
    if (err == 0) {
        memcpy(&obj->v0, data_0, sizeof(obj->v0));
        memcpy(&obj->v1, data_1, sizeof(obj->v1));
        memcpy(&obj->v2, data_2, sizeof(obj->v2));
        memcpy(&obj->v3, data_3, sizeof(obj->v3));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_11462a01 {
    int32_t v0;
    int32_t v1;
};
int futhark_project_opaque_11462a01_x(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_11462a01 *obj)
{
    (void) ctx;
    
    int32_t v;
    
    v = obj->v0;
    *out = v;
    return 0;
}
int futhark_project_opaque_11462a01_y(struct futhark_context *ctx, int32_t *out, const struct futhark_opaque_11462a01 *obj)
{
    (void) ctx;
    
    int32_t v;
    
    v = obj->v1;
    *out = v;
    return 0;
}
int futhark_new_opaque_11462a01(struct futhark_context *ctx, struct futhark_opaque_11462a01 **out, const int32_t f_x, const int32_t f_y)
{
    struct futhark_opaque_11462a01 *v = malloc(sizeof(struct futhark_opaque_11462a01));
    
    lock_lock(&ctx->lock);
    v->v0 = f_x;
    v->v1 = f_y;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_free_opaque_11462a01(struct futhark_context *ctx, struct futhark_opaque_11462a01 *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    free(obj);
    return ret;
}
int futhark_store_opaque_11462a01(struct futhark_context *ctx, const struct futhark_opaque_11462a01 *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int32_t);
    int64_t size_1 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int32_t);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, &obj->v0, sizeof(obj->v0));
        out += sizeof(obj->v0);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, &obj->v1, sizeof(obj->v1));
        out += sizeof(obj->v1);
    }
    return ret;
}
struct futhark_opaque_11462a01 *futhark_restore_opaque_11462a01(struct futhark_context *ctx, const void *p)
{
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_11462a01 *obj = malloc(sizeof(struct futhark_opaque_11462a01));
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    src += sizeof(obj->v0);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    src += sizeof(obj->v1);
    if (err == 0) {
        memcpy(&obj->v0, data_0, sizeof(obj->v0));
        memcpy(&obj->v1, data_1, sizeof(obj->v1));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_9eab96ba {
    float v0;
    float v1;
};
int futhark_project_opaque_9eab96ba_x(struct futhark_context *ctx, float *out, const struct futhark_opaque_9eab96ba *obj)
{
    (void) ctx;
    
    float v;
    
    v = obj->v0;
    *out = v;
    return 0;
}
int futhark_project_opaque_9eab96ba_y(struct futhark_context *ctx, float *out, const struct futhark_opaque_9eab96ba *obj)
{
    (void) ctx;
    
    float v;
    
    v = obj->v1;
    *out = v;
    return 0;
}
int futhark_new_opaque_9eab96ba(struct futhark_context *ctx, struct futhark_opaque_9eab96ba **out, const float f_x, const float f_y)
{
    struct futhark_opaque_9eab96ba *v = malloc(sizeof(struct futhark_opaque_9eab96ba));
    
    lock_lock(&ctx->lock);
    v->v0 = f_x;
    v->v1 = f_y;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_free_opaque_9eab96ba(struct futhark_context *ctx, struct futhark_opaque_9eab96ba *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    free(obj);
    return ret;
}
int futhark_store_opaque_9eab96ba(struct futhark_context *ctx, const struct futhark_opaque_9eab96ba *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_1 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    
    *n = size_0 + size_1;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v0, sizeof(obj->v0));
        out += sizeof(obj->v0);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v1, sizeof(obj->v1));
        out += sizeof(obj->v1);
    }
    return ret;
}
struct futhark_opaque_9eab96ba *futhark_restore_opaque_9eab96ba(struct futhark_context *ctx, const void *p)
{
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_9eab96ba *obj = malloc(sizeof(struct futhark_opaque_9eab96ba));
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    src += sizeof(obj->v0);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    src += sizeof(obj->v1);
    if (err == 0) {
        memcpy(&obj->v0, data_0, sizeof(obj->v0));
        memcpy(&obj->v1, data_1, sizeof(obj->v1));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_84640977 {
    float v0;
    float v1;
    float v2;
    float v3;
    int64_t v4;
    float v5;
    float v6;
};
int futhark_project_opaque_84640977_center_offset(struct futhark_context *ctx, struct futhark_opaque_9eab96ba **out, const struct futhark_opaque_84640977 *obj)
{
    (void) ctx;
    
    struct futhark_opaque_9eab96ba *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_opaque_9eab96ba));
    v->v0 = obj->v0;
    v->v1 = obj->v1;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_84640977_offset_viewport_scaled(struct futhark_context *ctx, struct futhark_opaque_9eab96ba **out, const struct futhark_opaque_84640977 *obj)
{
    (void) ctx;
    
    struct futhark_opaque_9eab96ba *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_opaque_9eab96ba));
    v->v0 = obj->v2;
    v->v1 = obj->v3;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_84640977_precision(struct futhark_context *ctx, int64_t *out, const struct futhark_opaque_84640977 *obj)
{
    (void) ctx;
    
    int64_t v;
    
    v = obj->v4;
    *out = v;
    return 0;
}
int futhark_project_opaque_84640977_xy_factor_inv(struct futhark_context *ctx, float *out, const struct futhark_opaque_84640977 *obj)
{
    (void) ctx;
    
    float v;
    
    v = obj->v5;
    *out = v;
    return 0;
}
int futhark_project_opaque_84640977_zoom_factor(struct futhark_context *ctx, float *out, const struct futhark_opaque_84640977 *obj)
{
    (void) ctx;
    
    float v;
    
    v = obj->v6;
    *out = v;
    return 0;
}
int futhark_new_opaque_84640977(struct futhark_context *ctx, struct futhark_opaque_84640977 **out, const struct futhark_opaque_9eab96ba *f_center_offset, const struct futhark_opaque_9eab96ba *f_offset_viewport_scaled, const int64_t f_precision, const float f_xy_factor_inv, const float f_zzoom_factor)
{
    struct futhark_opaque_84640977 *v = malloc(sizeof(struct futhark_opaque_84640977));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = f_center_offset->v0;
        v->v1 = f_center_offset->v1;
    }
    {
        v->v2 = f_offset_viewport_scaled->v0;
        v->v3 = f_offset_viewport_scaled->v1;
    }
    v->v4 = f_precision;
    v->v5 = f_xy_factor_inv;
    v->v6 = f_zzoom_factor;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_free_opaque_84640977(struct futhark_context *ctx, struct futhark_opaque_84640977 *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    free(obj);
    return ret;
}
int futhark_store_opaque_84640977(struct futhark_context *ctx, const struct futhark_opaque_84640977 *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_1 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_2 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_3 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_4 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int64_t);
    int64_t size_5 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_6 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    
    *n = size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v0, sizeof(obj->v0));
        out += sizeof(obj->v0);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v1, sizeof(obj->v1));
        out += sizeof(obj->v1);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v2, sizeof(obj->v2));
        out += sizeof(obj->v2);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v3, sizeof(obj->v3));
        out += sizeof(obj->v3);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, &obj->v4, sizeof(obj->v4));
        out += sizeof(obj->v4);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v5, sizeof(obj->v5));
        out += sizeof(obj->v5);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v6, sizeof(obj->v6));
        out += sizeof(obj->v6);
    }
    return ret;
}
struct futhark_opaque_84640977 *futhark_restore_opaque_84640977(struct futhark_context *ctx, const void *p)
{
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_84640977 *obj = malloc(sizeof(struct futhark_opaque_84640977));
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    src += sizeof(obj->v0);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    src += sizeof(obj->v1);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    src += sizeof(obj->v2);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_3 = src;
    
    src += sizeof(obj->v3);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_4 = src;
    
    src += sizeof(obj->v4);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_5 = src;
    
    src += sizeof(obj->v5);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_6 = src;
    
    src += sizeof(obj->v6);
    if (err == 0) {
        memcpy(&obj->v0, data_0, sizeof(obj->v0));
        memcpy(&obj->v1, data_1, sizeof(obj->v1));
        memcpy(&obj->v2, data_2, sizeof(obj->v2));
        memcpy(&obj->v3, data_3, sizeof(obj->v3));
        memcpy(&obj->v4, data_4, sizeof(obj->v4));
        memcpy(&obj->v5, data_5, sizeof(obj->v5));
        memcpy(&obj->v6, data_6, sizeof(obj->v6));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_721f284b {
    float v0;
    float v1;
    float v2;
};
int futhark_project_opaque_721f284b_center(struct futhark_context *ctx, struct futhark_opaque_9eab96ba **out, const struct futhark_opaque_721f284b *obj)
{
    (void) ctx;
    
    struct futhark_opaque_9eab96ba *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_opaque_9eab96ba));
    v->v0 = obj->v0;
    v->v1 = obj->v1;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_721f284b_zoom(struct futhark_context *ctx, float *out, const struct futhark_opaque_721f284b *obj)
{
    (void) ctx;
    
    float v;
    
    v = obj->v2;
    *out = v;
    return 0;
}
int futhark_new_opaque_721f284b(struct futhark_context *ctx, struct futhark_opaque_721f284b **out, const struct futhark_opaque_9eab96ba *f_center, const float f_zzoom)
{
    struct futhark_opaque_721f284b *v = malloc(sizeof(struct futhark_opaque_721f284b));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = f_center->v0;
        v->v1 = f_center->v1;
    }
    v->v2 = f_zzoom;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_free_opaque_721f284b(struct futhark_context *ctx, struct futhark_opaque_721f284b *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    free(obj);
    return ret;
}
int futhark_store_opaque_721f284b(struct futhark_context *ctx, const struct futhark_opaque_721f284b *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_1 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_2 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    
    *n = size_0 + size_1 + size_2;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v0, sizeof(obj->v0));
        out += sizeof(obj->v0);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v1, sizeof(obj->v1));
        out += sizeof(obj->v1);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v2, sizeof(obj->v2));
        out += sizeof(obj->v2);
    }
    return ret;
}
struct futhark_opaque_721f284b *futhark_restore_opaque_721f284b(struct futhark_context *ctx, const void *p)
{
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_721f284b *obj = malloc(sizeof(struct futhark_opaque_721f284b));
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    src += sizeof(obj->v0);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    src += sizeof(obj->v1);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    src += sizeof(obj->v2);
    if (err == 0) {
        memcpy(&obj->v0, data_0, sizeof(obj->v0));
        memcpy(&obj->v1, data_1, sizeof(obj->v1));
        memcpy(&obj->v2, data_2, sizeof(obj->v2));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        free(obj);
        obj = NULL;
    }
    return obj;
}
struct futhark_opaque_state {
    bool v0;
    float v1;
    int8_t v2;
    uint64_t v3;
    uint64_t v4;
    float v5;
    int64_t v6;
    int32_t v7;
    int32_t v8;
    float v9;
    float v10;
    float v11;
    float v12;
    int64_t v13;
    float v14;
    float v15;
    float v16;
    float v17;
    float v18;
    int64_t v19;
};
int futhark_project_opaque_state_auto_zoom(struct futhark_context *ctx, struct futhark_opaque_f5b98ad5 **out, const struct futhark_opaque_state *obj)
{
    (void) ctx;
    
    struct futhark_opaque_f5b98ad5 *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_opaque_f5b98ad5));
    v->v0 = obj->v0;
    v->v1 = obj->v1;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_state_base(struct futhark_context *ctx, struct futhark_opaque_40c80b6a **out, const struct futhark_opaque_state *obj)
{
    (void) ctx;
    
    struct futhark_opaque_40c80b6a *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_opaque_40c80b6a));
    v->v0 = obj->v2;
    v->v1 = obj->v3;
    v->v2 = obj->v4;
    v->v3 = obj->v5;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_state_height(struct futhark_context *ctx, int64_t *out, const struct futhark_opaque_state *obj)
{
    (void) ctx;
    
    int64_t v;
    
    v = obj->v6;
    *out = v;
    return 0;
}
int futhark_project_opaque_state_mouse(struct futhark_context *ctx, struct futhark_opaque_11462a01 **out, const struct futhark_opaque_state *obj)
{
    (void) ctx;
    
    struct futhark_opaque_11462a01 *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_opaque_11462a01));
    v->v0 = obj->v7;
    v->v1 = obj->v8;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_state_screen_calculations(struct futhark_context *ctx, struct futhark_opaque_84640977 **out, const struct futhark_opaque_state *obj)
{
    (void) ctx;
    
    struct futhark_opaque_84640977 *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_opaque_84640977));
    v->v0 = obj->v9;
    v->v1 = obj->v10;
    v->v2 = obj->v11;
    v->v3 = obj->v12;
    v->v4 = obj->v13;
    v->v5 = obj->v14;
    v->v6 = obj->v15;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_state_viewport(struct futhark_context *ctx, struct futhark_opaque_721f284b **out, const struct futhark_opaque_state *obj)
{
    (void) ctx;
    
    struct futhark_opaque_721f284b *v;
    
    lock_lock(&ctx->lock);
    v = malloc(sizeof(struct futhark_opaque_721f284b));
    v->v0 = obj->v16;
    v->v1 = obj->v17;
    v->v2 = obj->v18;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_project_opaque_state_width(struct futhark_context *ctx, int64_t *out, const struct futhark_opaque_state *obj)
{
    (void) ctx;
    
    int64_t v;
    
    v = obj->v19;
    *out = v;
    return 0;
}
int futhark_new_opaque_state(struct futhark_context *ctx, struct futhark_opaque_state **out, const struct futhark_opaque_f5b98ad5 *f_auto_zzoom, const struct futhark_opaque_40c80b6a *f_base, const int64_t f_height, const struct futhark_opaque_11462a01 *f_mouse, const struct futhark_opaque_84640977 *f_screen_calculations, const struct futhark_opaque_721f284b *f_viewport, const int64_t f_width)
{
    struct futhark_opaque_state *v = malloc(sizeof(struct futhark_opaque_state));
    
    lock_lock(&ctx->lock);
    {
        v->v0 = f_auto_zzoom->v0;
        v->v1 = f_auto_zzoom->v1;
    }
    {
        v->v2 = f_base->v0;
        v->v3 = f_base->v1;
        v->v4 = f_base->v2;
        v->v5 = f_base->v3;
    }
    v->v6 = f_height;
    {
        v->v7 = f_mouse->v0;
        v->v8 = f_mouse->v1;
    }
    {
        v->v9 = f_screen_calculations->v0;
        v->v10 = f_screen_calculations->v1;
        v->v11 = f_screen_calculations->v2;
        v->v12 = f_screen_calculations->v3;
        v->v13 = f_screen_calculations->v4;
        v->v14 = f_screen_calculations->v5;
        v->v15 = f_screen_calculations->v6;
    }
    {
        v->v16 = f_viewport->v0;
        v->v17 = f_viewport->v1;
        v->v18 = f_viewport->v2;
    }
    v->v19 = f_width;
    lock_unlock(&ctx->lock);
    *out = v;
    return 0;
}
int futhark_free_opaque_state(struct futhark_context *ctx, struct futhark_opaque_state *obj)
{
    (void) ctx;
    
    int ret = 0, tmp;
    
    free(obj);
    return ret;
}
int futhark_store_opaque_state(struct futhark_context *ctx, const struct futhark_opaque_state *obj, void **p, size_t *n)
{
    (void) ctx;
    
    int ret = 0;
    int64_t size_0 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(bool);
    int64_t size_1 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_2 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int8_t);
    int64_t size_3 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int64_t);
    int64_t size_4 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int64_t);
    int64_t size_5 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_6 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int64_t);
    int64_t size_7 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int32_t);
    int64_t size_8 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int32_t);
    int64_t size_9 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_10 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_11 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_12 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_13 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int64_t);
    int64_t size_14 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_15 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_16 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_17 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_18 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(float);
    int64_t size_19 = 7 + 0 * sizeof(int64_t) + 1 * sizeof(int64_t);
    
    *n = size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6 + size_7 + size_8 + size_9 + size_10 + size_11 + size_12 + size_13 + size_14 + size_15 + size_16 + size_17 + size_18 + size_19;
    if (p != NULL && *p == NULL)
        *p = malloc(*n);
    if (p != NULL) {
        unsigned char *out = *p;
        
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, "bool", 4);
        out += 4;
        memcpy(out, &obj->v0, sizeof(obj->v0));
        out += sizeof(obj->v0);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v1, sizeof(obj->v1));
        out += sizeof(obj->v1);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, "  i8", 4);
        out += 4;
        memcpy(out, &obj->v2, sizeof(obj->v2));
        out += sizeof(obj->v2);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " u64", 4);
        out += 4;
        memcpy(out, &obj->v3, sizeof(obj->v3));
        out += sizeof(obj->v3);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " u64", 4);
        out += 4;
        memcpy(out, &obj->v4, sizeof(obj->v4));
        out += sizeof(obj->v4);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v5, sizeof(obj->v5));
        out += sizeof(obj->v5);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, &obj->v6, sizeof(obj->v6));
        out += sizeof(obj->v6);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, &obj->v7, sizeof(obj->v7));
        out += sizeof(obj->v7);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i32", 4);
        out += 4;
        memcpy(out, &obj->v8, sizeof(obj->v8));
        out += sizeof(obj->v8);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v9, sizeof(obj->v9));
        out += sizeof(obj->v9);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v10, sizeof(obj->v10));
        out += sizeof(obj->v10);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v11, sizeof(obj->v11));
        out += sizeof(obj->v11);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v12, sizeof(obj->v12));
        out += sizeof(obj->v12);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, &obj->v13, sizeof(obj->v13));
        out += sizeof(obj->v13);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v14, sizeof(obj->v14));
        out += sizeof(obj->v14);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v15, sizeof(obj->v15));
        out += sizeof(obj->v15);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v16, sizeof(obj->v16));
        out += sizeof(obj->v16);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v17, sizeof(obj->v17));
        out += sizeof(obj->v17);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " f32", 4);
        out += 4;
        memcpy(out, &obj->v18, sizeof(obj->v18));
        out += sizeof(obj->v18);
        *out++ = 'b';
        *out++ = 2;
        *out++ = 0;
        memcpy(out, " i64", 4);
        out += 4;
        memcpy(out, &obj->v19, sizeof(obj->v19));
        out += sizeof(obj->v19);
    }
    return ret;
}
struct futhark_opaque_state *futhark_restore_opaque_state(struct futhark_context *ctx, const void *p)
{
    int err = 0;
    const unsigned char *src = p;
    struct futhark_opaque_state *obj = malloc(sizeof(struct futhark_opaque_state));
    
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, "bool", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_0 = src;
    
    src += sizeof(obj->v0);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_1 = src;
    
    src += sizeof(obj->v1);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, "  i8", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_2 = src;
    
    src += sizeof(obj->v2);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " u64", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_3 = src;
    
    src += sizeof(obj->v3);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " u64", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_4 = src;
    
    src += sizeof(obj->v4);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_5 = src;
    
    src += sizeof(obj->v5);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_6 = src;
    
    src += sizeof(obj->v6);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_7 = src;
    
    src += sizeof(obj->v7);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_8 = src;
    
    src += sizeof(obj->v8);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_9 = src;
    
    src += sizeof(obj->v9);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_10 = src;
    
    src += sizeof(obj->v10);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_11 = src;
    
    src += sizeof(obj->v11);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_12 = src;
    
    src += sizeof(obj->v12);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_13 = src;
    
    src += sizeof(obj->v13);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_14 = src;
    
    src += sizeof(obj->v14);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_15 = src;
    
    src += sizeof(obj->v15);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_16 = src;
    
    src += sizeof(obj->v16);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_17 = src;
    
    src += sizeof(obj->v17);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " f32", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_18 = src;
    
    src += sizeof(obj->v18);
    err |= *src++ != 'b';
    err |= *src++ != 2;
    err |= *src++ != 0;
    err |= memcmp(src, " i64", 4) != 0;
    src += 4;
    if (err == 0) {
        src += 0 * sizeof(int64_t);
    }
    
    const void *data_19 = src;
    
    src += sizeof(obj->v19);
    if (err == 0) {
        memcpy(&obj->v0, data_0, sizeof(obj->v0));
        memcpy(&obj->v1, data_1, sizeof(obj->v1));
        memcpy(&obj->v2, data_2, sizeof(obj->v2));
        memcpy(&obj->v3, data_3, sizeof(obj->v3));
        memcpy(&obj->v4, data_4, sizeof(obj->v4));
        memcpy(&obj->v5, data_5, sizeof(obj->v5));
        memcpy(&obj->v6, data_6, sizeof(obj->v6));
        memcpy(&obj->v7, data_7, sizeof(obj->v7));
        memcpy(&obj->v8, data_8, sizeof(obj->v8));
        memcpy(&obj->v9, data_9, sizeof(obj->v9));
        memcpy(&obj->v10, data_10, sizeof(obj->v10));
        memcpy(&obj->v11, data_11, sizeof(obj->v11));
        memcpy(&obj->v12, data_12, sizeof(obj->v12));
        memcpy(&obj->v13, data_13, sizeof(obj->v13));
        memcpy(&obj->v14, data_14, sizeof(obj->v14));
        memcpy(&obj->v15, data_15, sizeof(obj->v15));
        memcpy(&obj->v16, data_16, sizeof(obj->v16));
        memcpy(&obj->v17, data_17, sizeof(obj->v17));
        memcpy(&obj->v18, data_18, sizeof(obj->v18));
        memcpy(&obj->v19, data_19, sizeof(obj->v19));
    }
    if (err != 0) {
        int ret = 0, tmp;
        
        free(obj);
        obj = NULL;
    }
    return obj;
}

static int futrts_builtinzhgpu_copy_1d_i8(struct futhark_context *ctx, struct memblock_device destmem_0, int64_t dest_offset_1, int64_t dest_stride_2, int64_t dest_shape_3, struct memblock_device srcmem_4, int64_t src_offset_5, int64_t src_stride_6, int64_t src_shape_7)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# Copy []i8");
    
    int64_t group_sizze_8;
    int64_t num_groups_9;
    
    group_sizze_8 = *ctx->tuning_params.copy_group_sizze;
    num_groups_9 = *ctx->tuning_params.copy_num_groups;
    if (dest_stride_2 == (int64_t) 1 && (dest_stride_2 == src_stride_6 && dest_shape_3 == src_shape_7)) {
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "## Simple copy");
        if (src_shape_7 > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->queue, srcmem_4.mem, destmem_0.mem, (size_t) src_offset_5, (size_t) dest_offset_1, (size_t) src_shape_7, 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_dev_to_dev")));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
        }
    } else {
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "## Kernel copy");
        {
            err = gpu_kernel_copy_1d_i8(ctx, num_groups_9, 1, 1, group_sizze_8, 1, 1, 0, dest_offset_1, dest_stride_2, dest_shape_3, src_offset_5, src_stride_6, src_shape_7, num_groups_9, destmem_0.mem, srcmem_4.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    
  cleanup:
    { }
    return err;
}
static int futrts_builtinzhgpu_copy_2d_f32(struct futhark_context *ctx, struct memblock_device destmem_0, int64_t dest_offset_1, int64_t dest_stride_2, int64_t dest_shape_3, int64_t dest_stride_4, int64_t dest_shape_5, struct memblock_device srcmem_6, int64_t src_offset_7, int64_t src_stride_8, int64_t src_shape_9, int64_t src_stride_10, int64_t src_shape_11)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# Copy [][]f32");
    
    int64_t group_sizze_12;
    int64_t num_groups_13;
    
    group_sizze_12 = *ctx->tuning_params.copy_group_sizze;
    num_groups_13 = *ctx->tuning_params.copy_num_groups;
    if ((dest_stride_2 == dest_shape_5 && dest_stride_4 == (int64_t) 1) && ((dest_stride_2 == src_stride_8 && dest_shape_3 == src_shape_9) && (dest_stride_4 == src_stride_10 && dest_shape_5 == src_shape_11))) {
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "## Simple copy");
        if (src_shape_9 * src_shape_11 * (int64_t) 4 > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->queue, srcmem_6.mem, destmem_0.mem, (size_t) (src_offset_7 * (int64_t) 4), (size_t) (dest_offset_1 * (int64_t) 4), (size_t) (src_shape_9 * src_shape_11 * (int64_t) 4), 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_dev_to_dev")));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
        }
    } else {
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "## Kernel copy");
        {
            err = gpu_kernel_copy_2d_f32(ctx, num_groups_13, 1, 1, group_sizze_12, 1, 1, 0, dest_offset_1, dest_stride_2, dest_shape_3, dest_stride_4, dest_shape_5, src_offset_7, src_stride_8, src_shape_9, src_stride_10, src_shape_11, num_groups_13, destmem_0.mem, srcmem_6.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    
  cleanup:
    { }
    return err;
}
static int futrts_builtinzhgpu_copy_2d_i64(struct futhark_context *ctx, struct memblock_device destmem_0, int64_t dest_offset_1, int64_t dest_stride_2, int64_t dest_shape_3, int64_t dest_stride_4, int64_t dest_shape_5, struct memblock_device srcmem_6, int64_t src_offset_7, int64_t src_stride_8, int64_t src_shape_9, int64_t src_stride_10, int64_t src_shape_11)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# Copy [][]i64");
    
    int64_t group_sizze_12;
    int64_t num_groups_13;
    
    group_sizze_12 = *ctx->tuning_params.copy_group_sizze;
    num_groups_13 = *ctx->tuning_params.copy_num_groups;
    if ((dest_stride_2 == dest_shape_5 && dest_stride_4 == (int64_t) 1) && ((dest_stride_2 == src_stride_8 && dest_shape_3 == src_shape_9) && (dest_stride_4 == src_stride_10 && dest_shape_5 == src_shape_11))) {
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "## Simple copy");
        if (src_shape_9 * src_shape_11 * (int64_t) 8 > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->queue, srcmem_6.mem, destmem_0.mem, (size_t) (src_offset_7 * (int64_t) 8), (size_t) (dest_offset_1 * (int64_t) 8), (size_t) (src_shape_9 * src_shape_11 * (int64_t) 8), 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_dev_to_dev")));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
        }
    } else {
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "## Kernel copy");
        {
            err = gpu_kernel_copy_2d_i64(ctx, num_groups_13, 1, 1, group_sizze_12, 1, 1, 0, dest_offset_1, dest_stride_2, dest_shape_3, dest_stride_4, dest_shape_5, src_offset_7, src_stride_8, src_shape_9, src_stride_10, src_shape_11, num_groups_13, destmem_0.mem, srcmem_6.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    
  cleanup:
    { }
    return err;
}
static int futrts_builtinzhgpu_map_transpose_f32(struct futhark_context *ctx, struct memblock_device destmem_0, int64_t destoffset_1, struct memblock_device srcmem_2, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# Transpose f32");
    if (ctx->debugging)
        fprintf(ctx->log, "%s: %llu%c", "Number of arrays  ", (long long) num_arrays_4, '\n');
    if (ctx->debugging)
        fprintf(ctx->log, "%s: %llu%c", "X elements        ", (long long) x_elems_5, '\n');
    if (ctx->debugging)
        fprintf(ctx->log, "%s: %llu%c", "Y elements        ", (long long) y_elems_6, '\n');
    if (ctx->debugging)
        fprintf(ctx->log, "%s: %llu%c", "Source      offset", (long long) srcoffset_3, '\n');
    if (ctx->debugging)
        fprintf(ctx->log, "%s: %llu%c", "Destination offset", (long long) destoffset_1, '\n');
    if (!(num_arrays_4 == (int64_t) 0 || (x_elems_5 == (int64_t) 0 || y_elems_6 == (int64_t) 0))) {
        int64_t muly_8 = squot64((int64_t) 16, x_elems_5);
        int64_t mulx_7 = squot64((int64_t) 16, y_elems_6);
        bool use_32b_10 = sle64(destoffset_1 + num_arrays_4 * x_elems_5 * y_elems_6, (int64_t) 2147483647) && sle64(srcoffset_3 + num_arrays_4 * x_elems_5 * y_elems_6, (int64_t) 2147483647);
        
        if (num_arrays_4 == (int64_t) 1 && (x_elems_5 == (int64_t) 1 || y_elems_6 == (int64_t) 1)) {
            if (x_elems_5 * y_elems_6 * (int64_t) 4 > 0) {
                OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->queue, srcmem_2.mem, destmem_0.mem, (size_t) srcoffset_3, (size_t) destoffset_1, (size_t) (x_elems_5 * y_elems_6 * (int64_t) 4), 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_dev_to_dev")));
                if (ctx->debugging)
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            }
        } else if (sle64(x_elems_5, (int64_t) 8) && slt64((int64_t) 16, y_elems_6)) {
            if (use_32b_10) {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 32-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_f32_low_width_i32(ctx, sdiv_up32(sext_i64_i32(x_elems_5), 16), sdiv_up32(sdiv_up32(sext_i64_i32(y_elems_6), sext_i64_i32(muly_8)), 16), sext_i64_i32(num_arrays_4), 16, 16, 1, 0 + (int64_t) 1088, (int64_t) 1088, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            } else {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 64-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_f32_low_width_i64(ctx, sdiv_up64(x_elems_5, (int64_t) 16), sdiv_up64(sdiv_up64(y_elems_6, muly_8), (int64_t) 16), num_arrays_4, (int64_t) 16, (int64_t) 16, (int64_t) 1, 0 + (int64_t) 1088, (int64_t) 1088, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            }
        } else if (sle64(y_elems_6, (int64_t) 8) && slt64((int64_t) 16, x_elems_5)) {
            if (use_32b_10) {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 32-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_f32_low_height_i32(ctx, sdiv_up32(sdiv_up32(sext_i64_i32(x_elems_5), sext_i64_i32(mulx_7)), 16), sdiv_up32(sext_i64_i32(y_elems_6), 16), sext_i64_i32(num_arrays_4), 16, 16, 1, 0 + (int64_t) 1088, (int64_t) 1088, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            } else {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 64-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_f32_low_height_i64(ctx, sdiv_up64(sdiv_up64(x_elems_5, mulx_7), (int64_t) 16), sdiv_up64(y_elems_6, (int64_t) 16), num_arrays_4, (int64_t) 16, (int64_t) 16, (int64_t) 1, 0 + (int64_t) 1088, (int64_t) 1088, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            }
        } else if (sle64(x_elems_5, (int64_t) 8) && sle64(y_elems_6, (int64_t) 8)) {
            if (use_32b_10) {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 32-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_f32_small_i32(ctx, sdiv_up32(sext_i64_i32(num_arrays_4) * sext_i64_i32(x_elems_5) * sext_i64_i32(y_elems_6), 256), 1, 1, 256, 1, 1, 0 + (int64_t) 1, (int64_t) 1, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            } else {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 64-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_f32_small_i64(ctx, sdiv_up64(num_arrays_4 * x_elems_5 * y_elems_6, (int64_t) 256), 1, 1, (int64_t) 256, 1, 1, 0 + (int64_t) 1, (int64_t) 1, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            }
        } else if (use_32b_10) {
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "Using 32-bit indexing");
            {
                err = gpu_kernel_gpu_map_transpose_f32_i32(ctx, sdiv_up32(sext_i64_i32(x_elems_5), 32), sdiv_up32(sext_i64_i32(y_elems_6), 32), sext_i64_i32(num_arrays_4), 32, 4, 1, 0 + (int64_t) 4224, (int64_t) 4224, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
        } else {
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "Using 64-bit indexing");
            {
                err = gpu_kernel_gpu_map_transpose_f32_i64(ctx, sdiv_up64(x_elems_5, (int64_t) 32), sdiv_up64(y_elems_6, (int64_t) 32), num_arrays_4, (int64_t) 32, (int64_t) 4, (int64_t) 1, 0 + (int64_t) 4224, (int64_t) 4224, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    
  cleanup:
    { }
    return err;
}
static int futrts_builtinzhgpu_map_transpose_i64(struct futhark_context *ctx, struct memblock_device destmem_0, int64_t destoffset_1, struct memblock_device srcmem_2, int64_t srcoffset_3, int64_t num_arrays_4, int64_t x_elems_5, int64_t y_elems_6)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# Transpose i64");
    if (ctx->debugging)
        fprintf(ctx->log, "%s: %llu%c", "Number of arrays  ", (long long) num_arrays_4, '\n');
    if (ctx->debugging)
        fprintf(ctx->log, "%s: %llu%c", "X elements        ", (long long) x_elems_5, '\n');
    if (ctx->debugging)
        fprintf(ctx->log, "%s: %llu%c", "Y elements        ", (long long) y_elems_6, '\n');
    if (ctx->debugging)
        fprintf(ctx->log, "%s: %llu%c", "Source      offset", (long long) srcoffset_3, '\n');
    if (ctx->debugging)
        fprintf(ctx->log, "%s: %llu%c", "Destination offset", (long long) destoffset_1, '\n');
    if (!(num_arrays_4 == (int64_t) 0 || (x_elems_5 == (int64_t) 0 || y_elems_6 == (int64_t) 0))) {
        int64_t muly_8 = squot64((int64_t) 16, x_elems_5);
        int64_t mulx_7 = squot64((int64_t) 16, y_elems_6);
        bool use_32b_10 = sle64(destoffset_1 + num_arrays_4 * x_elems_5 * y_elems_6, (int64_t) 2147483647) && sle64(srcoffset_3 + num_arrays_4 * x_elems_5 * y_elems_6, (int64_t) 2147483647);
        
        if (num_arrays_4 == (int64_t) 1 && (x_elems_5 == (int64_t) 1 || y_elems_6 == (int64_t) 1)) {
            if (x_elems_5 * y_elems_6 * (int64_t) 8 > 0) {
                OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->queue, srcmem_2.mem, destmem_0.mem, (size_t) srcoffset_3, (size_t) destoffset_1, (size_t) (x_elems_5 * y_elems_6 * (int64_t) 8), 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_dev_to_dev")));
                if (ctx->debugging)
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->queue));
            }
        } else if (sle64(x_elems_5, (int64_t) 8) && slt64((int64_t) 16, y_elems_6)) {
            if (use_32b_10) {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 32-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_i64_low_width_i32(ctx, sdiv_up32(sext_i64_i32(x_elems_5), 16), sdiv_up32(sdiv_up32(sext_i64_i32(y_elems_6), sext_i64_i32(muly_8)), 16), sext_i64_i32(num_arrays_4), 16, 16, 1, 0 + (int64_t) 2176, (int64_t) 2176, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            } else {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 64-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_i64_low_width_i64(ctx, sdiv_up64(x_elems_5, (int64_t) 16), sdiv_up64(sdiv_up64(y_elems_6, muly_8), (int64_t) 16), num_arrays_4, (int64_t) 16, (int64_t) 16, (int64_t) 1, 0 + (int64_t) 2176, (int64_t) 2176, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            }
        } else if (sle64(y_elems_6, (int64_t) 8) && slt64((int64_t) 16, x_elems_5)) {
            if (use_32b_10) {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 32-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_i64_low_height_i32(ctx, sdiv_up32(sdiv_up32(sext_i64_i32(x_elems_5), sext_i64_i32(mulx_7)), 16), sdiv_up32(sext_i64_i32(y_elems_6), 16), sext_i64_i32(num_arrays_4), 16, 16, 1, 0 + (int64_t) 2176, (int64_t) 2176, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            } else {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 64-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_i64_low_height_i64(ctx, sdiv_up64(sdiv_up64(x_elems_5, mulx_7), (int64_t) 16), sdiv_up64(y_elems_6, (int64_t) 16), num_arrays_4, (int64_t) 16, (int64_t) 16, (int64_t) 1, 0 + (int64_t) 2176, (int64_t) 2176, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            }
        } else if (sle64(x_elems_5, (int64_t) 8) && sle64(y_elems_6, (int64_t) 8)) {
            if (use_32b_10) {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 32-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_i64_small_i32(ctx, sdiv_up32(sext_i64_i32(num_arrays_4) * sext_i64_i32(x_elems_5) * sext_i64_i32(y_elems_6), 256), 1, 1, 256, 1, 1, 0 + (int64_t) 1, (int64_t) 1, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            } else {
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "Using 64-bit indexing");
                {
                    err = gpu_kernel_gpu_map_transpose_i64_small_i64(ctx, sdiv_up64(num_arrays_4 * x_elems_5 * y_elems_6, (int64_t) 256), 1, 1, (int64_t) 256, 1, 1, 0 + (int64_t) 1, (int64_t) 1, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            }
        } else if (use_32b_10) {
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "Using 32-bit indexing");
            {
                err = gpu_kernel_gpu_map_transpose_i64_i32(ctx, sdiv_up32(sext_i64_i32(x_elems_5), 32), sdiv_up32(sext_i64_i32(y_elems_6), 32), sext_i64_i32(num_arrays_4), 32, 4, 1, 0 + (int64_t) 8448, (int64_t) 8448, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
        } else {
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "Using 64-bit indexing");
            {
                err = gpu_kernel_gpu_map_transpose_i64_i64(ctx, sdiv_up64(x_elems_5, (int64_t) 32), sdiv_up64(y_elems_6, (int64_t) 32), num_arrays_4, (int64_t) 32, (int64_t) 4, (int64_t) 1, 0 + (int64_t) 8448, (int64_t) 8448, destoffset_1, srcoffset_3, num_arrays_4, x_elems_5, y_elems_6, mulx_7, muly_8, destmem_0.mem, srcmem_2.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    
  cleanup:
    { }
    return err;
}
static int futrts_builtinzhreplicate_f32(struct futhark_context *ctx, struct memblock_device mem_26109, int64_t num_elems_26110, float val_26111)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    int64_t replicate_n_26113 = num_elems_26110;
    int64_t group_sizze_26118;
    
    group_sizze_26118 = *ctx->tuning_params.builtinzhreplicate_f32zigroup_sizze_26118;
    
    int64_t virt_num_groups_26119 = sdiv_up64(replicate_n_26113, group_sizze_26118);
    int64_t num_groups_26120 = smin64(virt_num_groups_26119, (int64_t) 1048576);
    
    {
        err = gpu_kernel_builtinzhreplicate_f32zireplicate_26114(ctx, num_groups_26120, 1, 1, group_sizze_26118, 1, 1, 0, num_elems_26110, val_26111, replicate_n_26113, virt_num_groups_26119, num_groups_26120, mem_26109.mem);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
  cleanup:
    { }
    return err;
}
static int futrts_builtinzhreplicate_i32(struct futhark_context *ctx, struct memblock_device mem_26262, int64_t num_elems_26263, int32_t val_26264)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    int64_t replicate_n_26266 = num_elems_26263;
    int64_t group_sizze_26271;
    
    group_sizze_26271 = *ctx->tuning_params.builtinzhreplicate_i32zigroup_sizze_26271;
    
    int64_t virt_num_groups_26272 = sdiv_up64(replicate_n_26266, group_sizze_26271);
    int64_t num_groups_26273 = smin64(virt_num_groups_26272, (int64_t) 1048576);
    
    {
        err = gpu_kernel_builtinzhreplicate_i32zireplicate_26267(ctx, num_groups_26273, 1, 1, group_sizze_26271, 1, 1, 0, num_elems_26263, val_26264, replicate_n_26266, virt_num_groups_26272, num_groups_26273, mem_26262.mem);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
  cleanup:
    { }
    return err;
}
static int futrts_builtinzhreplicate_i64(struct futhark_context *ctx, struct memblock_device mem_26129, int64_t num_elems_26130, int64_t val_26131)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    int64_t replicate_n_26133 = num_elems_26130;
    int64_t group_sizze_26138;
    
    group_sizze_26138 = *ctx->tuning_params.builtinzhreplicate_i64zigroup_sizze_26138;
    
    int64_t virt_num_groups_26139 = sdiv_up64(replicate_n_26133, group_sizze_26138);
    int64_t num_groups_26140 = smin64(virt_num_groups_26139, (int64_t) 1048576);
    
    {
        err = gpu_kernel_builtinzhreplicate_i64zireplicate_26134(ctx, num_groups_26140, 1, 1, group_sizze_26138, 1, 1, 0, num_elems_26130, val_26131, replicate_n_26133, virt_num_groups_26139, num_groups_26140, mem_26129.mem);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_grab_mouse(struct futhark_context *ctx, bool *out_prim_out_26534)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    bool prim_out_26106;
    
    prim_out_26106 = 0;
    *out_prim_out_26534 = prim_out_26106;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_init(struct futhark_context *ctx, bool *out_prim_out_26535, float *out_prim_out_26536, int8_t *out_prim_out_26537, int64_t *out_prim_out_26538, int64_t *out_prim_out_26539, float *out_prim_out_26540, int64_t *out_prim_out_26541, int32_t *out_prim_out_26542, int32_t *out_prim_out_26543, float *out_prim_out_26544, float *out_prim_out_26545, float *out_prim_out_26546, float *out_prim_out_26547, int64_t *out_prim_out_26548, float *out_prim_out_26549, float *out_prim_out_26550, float *out_prim_out_26551, float *out_prim_out_26552, float *out_prim_out_26553, int64_t *out_prim_out_26554, int32_t seed_16471, int32_t h_16472, int32_t w_16473)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    bool prim_out_26106;
    float prim_out_26107;
    int8_t prim_out_26108;
    int64_t prim_out_26109;
    int64_t prim_out_26110;
    float prim_out_26111;
    int64_t prim_out_26112;
    int32_t prim_out_26113;
    int32_t prim_out_26114;
    float prim_out_26115;
    float prim_out_26116;
    float prim_out_26117;
    float prim_out_26118;
    int64_t prim_out_26119;
    float prim_out_26120;
    float prim_out_26121;
    float prim_out_26122;
    float prim_out_26123;
    float prim_out_26124;
    int64_t prim_out_26125;
    int64_t i32_res_20733 = sext_i32_i64(w_16473);
    int64_t i32_res_20734 = sext_i32_i64(h_16472);
    int32_t zc_lhs_23652 = lshr32(seed_16471, 16);
    int32_t zt_lhs_23653 = seed_16471 ^ zc_lhs_23652;
    int32_t x_23654 = mul32(73244475, zt_lhs_23653);
    int32_t zc_lhs_23655 = lshr32(x_23654, 16);
    int32_t zt_lhs_23656 = x_23654 ^ zc_lhs_23655;
    int32_t x_23657 = mul32(73244475, zt_lhs_23656);
    int32_t zc_lhs_23658 = lshr32(x_23657, 16);
    int32_t x_23659 = x_23657 ^ zc_lhs_23658;
    int64_t unsign_arg0_23660 = zext_i32_i64(x_23659);
    int64_t rand_arg0_23661 = (int64_t) 539527247 ^ unsign_arg0_23660;
    int64_t zc_rhs_23662 = shl64(rand_arg0_23661, (int64_t) 23);
    int64_t x_23663 = rand_arg0_23661 ^ zc_rhs_23662;
    int64_t zc_lhs_23664 = (int64_t) 824515495 ^ x_23663;
    int64_t zc_rhs_23665 = lshr64(x_23663, (int64_t) 17);
    int64_t zc_lhs_23666 = zc_lhs_23664 ^ zc_rhs_23665;
    int64_t new_y_23668 = (int64_t) 12 ^ zc_lhs_23666;
    int64_t zc_lhs_22896 = (int64_t) 6916485073332985 ^ zc_lhs_23666;
    int64_t zc_rhs_22897 = lshr64(new_y_23668, (int64_t) 26);
    int64_t new_y_22898 = zc_lhs_22896 ^ zc_rhs_22897;
    int64_t zc_rhs_22899 = shl64(new_y_23668, (int64_t) 23);
    int64_t x_22900 = zc_rhs_22899 ^ new_y_23668;
    int64_t zc_lhs_22901 = new_y_22898 ^ x_22900;
    int64_t zc_rhs_22902 = lshr64(x_22900, (int64_t) 17);
    int64_t zc_lhs_22903 = zc_lhs_22901 ^ zc_rhs_22902;
    int64_t zc_rhs_22904 = lshr64(new_y_22898, (int64_t) 26);
    int64_t new_y_22905 = zc_lhs_22903 ^ zc_rhs_22904;
    int64_t min_res_22918 = smin64(i32_res_20733, i32_res_20734);
    float i64_res_22920 = sitofp_i64_f32(min_res_22918);
    float xy_factor_inv_22921 = 1.0F / i64_res_22920;
    float zs_lhs_22923 = i64_res_22920 / i64_res_22920;
    float dup_arg0_22924 = zs_lhs_22923 / 2.0F;
    int64_t max_arg1_22928 = sub64(i32_res_20733, i32_res_20734);
    int64_t max_res_22929 = smax64((int64_t) 0, max_arg1_22928);
    float i64_res_22930 = sitofp_i64_f32(max_res_22929);
    float offset_22931 = i64_res_22930 / i64_res_22920;
    int64_t max_arg1_22932 = sub64(i32_res_20734, i32_res_20733);
    int64_t max_res_22933 = smax64((int64_t) 0, max_arg1_22932);
    float i64_res_22934 = sitofp_i64_f32(max_res_22933);
    float offset_22935 = i64_res_22934 / i64_res_22920;
    float zt_res_22936 = 0.5F * offset_22935;
    float zt_res_22937 = 0.5F * offset_22931;
    float zp_res_22938 = 0.5F + zt_res_22936;
    float zp_res_22939 = 0.5F + zt_res_22937;
    float zt_res_22944 = i64_res_22920 * zp_res_22938;
    float zt_res_22945 = i64_res_22920 * zp_res_22939;
    
    prim_out_26106 = 0;
    prim_out_26107 = 1.01F;
    prim_out_26108 = (int8_t) 1;
    prim_out_26109 = new_y_22898;
    prim_out_26110 = new_y_22905;
    prim_out_26111 = 0.0F;
    prim_out_26112 = i32_res_20734;
    prim_out_26113 = 0;
    prim_out_26114 = 0;
    prim_out_26115 = dup_arg0_22924;
    prim_out_26116 = dup_arg0_22924;
    prim_out_26117 = zt_res_22944;
    prim_out_26118 = zt_res_22945;
    prim_out_26119 = min_res_22918;
    prim_out_26120 = xy_factor_inv_22921;
    prim_out_26121 = i64_res_22920;
    prim_out_26122 = 0.0F;
    prim_out_26123 = 0.0F;
    prim_out_26124 = 1.0F;
    prim_out_26125 = i32_res_20733;
    *out_prim_out_26535 = prim_out_26106;
    *out_prim_out_26536 = prim_out_26107;
    *out_prim_out_26537 = prim_out_26108;
    *out_prim_out_26538 = prim_out_26109;
    *out_prim_out_26539 = prim_out_26110;
    *out_prim_out_26540 = prim_out_26111;
    *out_prim_out_26541 = prim_out_26112;
    *out_prim_out_26542 = prim_out_26113;
    *out_prim_out_26543 = prim_out_26114;
    *out_prim_out_26544 = prim_out_26115;
    *out_prim_out_26545 = prim_out_26116;
    *out_prim_out_26546 = prim_out_26117;
    *out_prim_out_26547 = prim_out_26118;
    *out_prim_out_26548 = prim_out_26119;
    *out_prim_out_26549 = prim_out_26120;
    *out_prim_out_26550 = prim_out_26121;
    *out_prim_out_26551 = prim_out_26122;
    *out_prim_out_26552 = prim_out_26123;
    *out_prim_out_26553 = prim_out_26124;
    *out_prim_out_26554 = prim_out_26125;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_key(struct futhark_context *ctx, bool *out_prim_out_26555, float *out_prim_out_26556, int8_t *out_prim_out_26557, int64_t *out_prim_out_26558, int64_t *out_prim_out_26559, float *out_prim_out_26560, int64_t *out_prim_out_26561, int32_t *out_prim_out_26562, int32_t *out_prim_out_26563, float *out_prim_out_26564, float *out_prim_out_26565, float *out_prim_out_26566, float *out_prim_out_26567, int64_t *out_prim_out_26568, float *out_prim_out_26569, float *out_prim_out_26570, float *out_prim_out_26571, float *out_prim_out_26572, float *out_prim_out_26573, int64_t *out_prim_out_26574, int32_t e_17618, int32_t key_17619, bool auto_zzoom_17620, float auto_zzoom_17621, int8_t base_17622, int64_t base_17623, int64_t base_17624, float base_17625, int64_t height_17626, int32_t mouse_17627, int32_t mouse_17628, float screen_calculations_17629, float screen_calculations_17630, float screen_calculations_17631, float screen_calculations_17632, int64_t screen_calculations_17633, float screen_calculations_17634, float screen_calculations_17635, float viewport_17636, float viewport_17637, float viewport_17638, int64_t width_17639)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    bool prim_out_26106;
    float prim_out_26107;
    int8_t prim_out_26108;
    int64_t prim_out_26109;
    int64_t prim_out_26110;
    float prim_out_26111;
    int64_t prim_out_26112;
    int32_t prim_out_26113;
    int32_t prim_out_26114;
    float prim_out_26115;
    float prim_out_26116;
    float prim_out_26117;
    float prim_out_26118;
    int64_t prim_out_26119;
    float prim_out_26120;
    float prim_out_26121;
    float prim_out_26122;
    float prim_out_26123;
    float prim_out_26124;
    int64_t prim_out_26125;
    bool cond_20617 = e_17618 == 0;
    bool cond_neg_20618 = !cond_20617;
    int8_t ezq_20619 = btoi_bool_i8(cond_neg_20618);
    int32_t event_res_23383;
    
    if (ezq_20619 == (int8_t) 3) {
        event_res_23383 = mouse_17627;
    } else if (ezq_20619 == (int8_t) 2) {
        event_res_23383 = 0;
    } else if (ezq_20619 == (int8_t) 4) {
        event_res_23383 = mouse_17627;
    } else {
        event_res_23383 = mouse_17627;
    }
    
    int32_t event_res_23384;
    
    if (ezq_20619 == (int8_t) 3) {
        event_res_23384 = mouse_17628;
    } else if (ezq_20619 == (int8_t) 2) {
        event_res_23384 = 0;
    } else if (ezq_20619 == (int8_t) 4) {
        event_res_23384 = mouse_17628;
    } else {
        event_res_23384 = mouse_17628;
    }
    
    bool event_res_23385;
    float event_res_23387;
    float event_res_23388;
    float event_res_23389;
    float event_res_23390;
    int64_t event_res_23391;
    float event_res_23392;
    float event_res_23393;
    float event_res_23394;
    float event_res_23395;
    float event_res_23396;
    
    if (ezq_20619 == (int8_t) 3) {
        float case_res_23741;
        float case_res_23742;
        float case_res_23743;
        float case_res_23744;
        int64_t case_res_23745;
        float case_res_23746;
        float case_res_23747;
        float case_res_23748;
        float case_res_23749;
        float case_res_23750;
        
        if (auto_zzoom_17620 == 1) {
            float s_23769 = auto_zzoom_17621 * viewport_17638;
            float log2_res_23772 = futrts_log2_32(s_23769);
            float ceil_res_23773 = futrts_ceil32(log2_res_23772);
            int64_t f32_res_23774 = fptosi_f32_i64(ceil_res_23773);
            int64_t max_res_23775 = smax64((int64_t) 0, f32_res_23774);
            bool nonnegative_23776 = sle64((int64_t) 0, max_res_23775);
            bool nonzzero_cert_23777;
            
            if (!nonnegative_23776) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  squarezoom-random.fut:30:28-85\n   #1  ../zoomable.fut:49:34-101\n   #2  ../zoomable.fut:85:8-36\n   #3  squarezoom-random_wrapper.fut:22:6-22\n   #4  squarezoom-random_wrapper.fut:20:1-22:22\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t min_res_23751 = smin64(height_17626, width_17639);
            float i64_res_23752 = sitofp_i64_f32(min_res_23751);
            float xy_factor_23753 = viewport_17638 * i64_res_23752;
            int32_t i64_res_23754 = sext_i64_i32(width_17639);
            int32_t zm_rhs_23755 = sdiv32(i64_res_23754, 2);
            int32_t r32_arg0_23756 = sub32(mouse_17627, zm_rhs_23755);
            float i32_res_23757 = sitofp_i32_f32(r32_arg0_23756);
            float zm_lhs_23758 = i32_res_23757 / xy_factor_23753;
            float zs_rhs_23759 = auto_zzoom_17621 * xy_factor_23753;
            float zm_rhs_23760 = i32_res_23757 / zs_rhs_23759;
            float xd_23761 = zm_lhs_23758 - zm_rhs_23760;
            int32_t i64_res_23762 = sext_i64_i32(height_17626);
            int32_t zm_rhs_23763 = sdiv32(i64_res_23762, 2);
            int32_t r32_arg0_23764 = sub32(mouse_17628, zm_rhs_23763);
            float i32_res_23765 = sitofp_i32_f32(r32_arg0_23764);
            float zm_lhs_23766 = i32_res_23765 / xy_factor_23753;
            float zm_rhs_23767 = i32_res_23765 / zs_rhs_23759;
            float yd_23768 = zm_lhs_23766 - zm_rhs_23767;
            float s_23770 = viewport_17636 + xd_23761;
            float s_23771 = viewport_17637 + yd_23768;
            int64_t precision_scale_23778 = shl64((int64_t) 1, max_res_23775);
            int64_t precision_23779 = mul64(min_res_23751, precision_scale_23778);
            float xy_factor_inv_23780 = 1.0F / i64_res_23752;
            float i64_res_23781 = sitofp_i64_f32(precision_23779);
            float zs_lhs_23782 = i64_res_23781 / i64_res_23752;
            float dup_arg0_23783 = zs_lhs_23782 / 2.0F;
            float zs_lhs_23784 = i64_res_23752 * s_23769;
            float i64_res_23785 = sitofp_i64_f32(precision_scale_23778);
            float zzoom_factor_23786 = zs_lhs_23784 / i64_res_23785;
            int64_t max_arg1_23787 = sub64(width_17639, height_17626);
            int64_t max_res_23788 = smax64((int64_t) 0, max_arg1_23787);
            float i64_res_23789 = sitofp_i64_f32(max_res_23788);
            float offset_23790 = i64_res_23789 / i64_res_23752;
            int64_t max_arg1_23791 = sub64(height_17626, width_17639);
            int64_t max_res_23792 = smax64((int64_t) 0, max_arg1_23791);
            float i64_res_23793 = sitofp_i64_f32(max_res_23792);
            float offset_23794 = i64_res_23793 / i64_res_23752;
            float zt_res_23795 = 0.5F * offset_23794;
            float zt_res_23796 = 0.5F * offset_23790;
            float zp_res_23797 = 0.5F + zt_res_23795;
            float zp_res_23798 = 0.5F + zt_res_23796;
            float zt_res_23799 = s_23769 * s_23770;
            float zt_res_23800 = s_23769 * s_23771;
            float zm_res_23801 = zp_res_23797 - zt_res_23799;
            float zm_res_23802 = zp_res_23798 - zt_res_23800;
            float zt_res_23803 = i64_res_23752 * zm_res_23801;
            float zt_res_23804 = i64_res_23752 * zm_res_23802;
            
            case_res_23741 = dup_arg0_23783;
            case_res_23742 = dup_arg0_23783;
            case_res_23743 = zt_res_23803;
            case_res_23744 = zt_res_23804;
            case_res_23745 = precision_23779;
            case_res_23746 = xy_factor_inv_23780;
            case_res_23747 = zzoom_factor_23786;
            case_res_23748 = s_23770;
            case_res_23749 = s_23771;
            case_res_23750 = s_23769;
        } else {
            case_res_23741 = screen_calculations_17629;
            case_res_23742 = screen_calculations_17630;
            case_res_23743 = screen_calculations_17631;
            case_res_23744 = screen_calculations_17632;
            case_res_23745 = screen_calculations_17633;
            case_res_23746 = screen_calculations_17634;
            case_res_23747 = screen_calculations_17635;
            case_res_23748 = viewport_17636;
            case_res_23749 = viewport_17637;
            case_res_23750 = viewport_17638;
        }
        event_res_23385 = auto_zzoom_17620;
        event_res_23387 = case_res_23741;
        event_res_23388 = case_res_23742;
        event_res_23389 = case_res_23743;
        event_res_23390 = case_res_23744;
        event_res_23391 = case_res_23745;
        event_res_23392 = case_res_23746;
        event_res_23393 = case_res_23747;
        event_res_23394 = case_res_23748;
        event_res_23395 = case_res_23749;
        event_res_23396 = case_res_23750;
    } else if (ezq_20619 == (int8_t) 2) {
        int64_t min_res_23843 = smin64(height_17626, width_17639);
        float i64_res_23844 = sitofp_i64_f32(min_res_23843);
        float xy_factor_23845 = viewport_17638 * i64_res_23844;
        int32_t zeze_lhs_23846 = 1 & key_17619;
        bool cond_23847 = zeze_lhs_23846 == 1;
        int32_t zeze_lhs_23848 = 4 & key_17619;
        bool cond_f_res_23849 = zeze_lhs_23848 == 4;
        bool x_23850 = !cond_23847;
        bool y_23851 = cond_f_res_23849 && x_23850;
        bool cond_23852 = cond_23847 || y_23851;
        float case_res_23853;
        float case_res_23854;
        float case_res_23855;
        float case_res_23856;
        int64_t case_res_23857;
        float case_res_23858;
        float case_res_23859;
        float case_res_23860;
        float case_res_23861;
        
        if (cond_23852 == 1) {
            float log2_res_23868 = futrts_log2_32(viewport_17638);
            float ceil_res_23869 = futrts_ceil32(log2_res_23868);
            int64_t f32_res_23870 = fptosi_f32_i64(ceil_res_23869);
            int64_t max_res_23871 = smax64((int64_t) 0, f32_res_23870);
            bool nonnegative_23872 = sle64((int64_t) 0, max_res_23871);
            bool nonzzero_cert_23873;
            
            if (!nonnegative_23872) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  squarezoom-random.fut:30:28-85\n   #1  squarezoom-random_wrapper.fut:22:6-22\n   #2  squarezoom-random_wrapper.fut:20:1-22:22\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            float i32_res_23862 = sitofp_i32_f32(mouse_17627);
            float zp_rhs_23863 = i32_res_23862 / xy_factor_23845;
            float s_23864 = viewport_17636 + zp_rhs_23863;
            float i32_res_23865 = sitofp_i32_f32(mouse_17628);
            float zp_rhs_23866 = i32_res_23865 / xy_factor_23845;
            float s_23867 = viewport_17637 + zp_rhs_23866;
            int64_t precision_scale_23874 = shl64((int64_t) 1, max_res_23871);
            int64_t precision_23875 = mul64(min_res_23843, precision_scale_23874);
            float xy_factor_inv_23876 = 1.0F / i64_res_23844;
            float i64_res_23877 = sitofp_i64_f32(precision_23875);
            float zs_lhs_23878 = i64_res_23877 / i64_res_23844;
            float dup_arg0_23879 = zs_lhs_23878 / 2.0F;
            float i64_res_23880 = sitofp_i64_f32(precision_scale_23874);
            float zzoom_factor_23881 = xy_factor_23845 / i64_res_23880;
            int64_t max_arg1_23882 = sub64(width_17639, height_17626);
            int64_t max_res_23883 = smax64((int64_t) 0, max_arg1_23882);
            float i64_res_23884 = sitofp_i64_f32(max_res_23883);
            float offset_23885 = i64_res_23884 / i64_res_23844;
            int64_t max_arg1_23886 = sub64(height_17626, width_17639);
            int64_t max_res_23887 = smax64((int64_t) 0, max_arg1_23886);
            float i64_res_23888 = sitofp_i64_f32(max_res_23887);
            float offset_23889 = i64_res_23888 / i64_res_23844;
            float zt_res_23890 = 0.5F * offset_23889;
            float zt_res_23891 = 0.5F * offset_23885;
            float zp_res_23892 = 0.5F + zt_res_23890;
            float zp_res_23893 = 0.5F + zt_res_23891;
            float zt_res_23894 = viewport_17638 * s_23864;
            float zt_res_23895 = viewport_17638 * s_23867;
            float zm_res_23896 = zp_res_23892 - zt_res_23894;
            float zm_res_23897 = zp_res_23893 - zt_res_23895;
            float zt_res_23898 = i64_res_23844 * zm_res_23896;
            float zt_res_23899 = i64_res_23844 * zm_res_23897;
            
            case_res_23853 = dup_arg0_23879;
            case_res_23854 = dup_arg0_23879;
            case_res_23855 = zt_res_23898;
            case_res_23856 = zt_res_23899;
            case_res_23857 = precision_23875;
            case_res_23858 = xy_factor_inv_23876;
            case_res_23859 = zzoom_factor_23881;
            case_res_23860 = s_23864;
            case_res_23861 = s_23867;
        } else {
            case_res_23853 = screen_calculations_17629;
            case_res_23854 = screen_calculations_17630;
            case_res_23855 = screen_calculations_17631;
            case_res_23856 = screen_calculations_17632;
            case_res_23857 = screen_calculations_17633;
            case_res_23858 = screen_calculations_17634;
            case_res_23859 = screen_calculations_17635;
            case_res_23860 = viewport_17636;
            case_res_23861 = viewport_17637;
        }
        event_res_23385 = cond_f_res_23849;
        event_res_23387 = case_res_23853;
        event_res_23388 = case_res_23854;
        event_res_23389 = case_res_23855;
        event_res_23390 = case_res_23856;
        event_res_23391 = case_res_23857;
        event_res_23392 = case_res_23858;
        event_res_23393 = case_res_23859;
        event_res_23394 = case_res_23860;
        event_res_23395 = case_res_23861;
        event_res_23396 = viewport_17638;
    } else if (ezq_20619 == (int8_t) 4) {
        float case_res_23900;
        float case_res_23901;
        float case_res_23902;
        float case_res_23903;
        int64_t case_res_23904;
        float case_res_23905;
        float case_res_23906;
        float case_res_23907;
        float case_res_23908;
        
        if (auto_zzoom_17620 == 1) {
            case_res_23900 = screen_calculations_17629;
            case_res_23901 = screen_calculations_17630;
            case_res_23902 = screen_calculations_17631;
            case_res_23903 = screen_calculations_17632;
            case_res_23904 = screen_calculations_17633;
            case_res_23905 = screen_calculations_17634;
            case_res_23906 = screen_calculations_17635;
            case_res_23907 = viewport_17636;
            case_res_23908 = viewport_17637;
        } else {
            float log2_res_23926 = futrts_log2_32(viewport_17638);
            float ceil_res_23927 = futrts_ceil32(log2_res_23926);
            int64_t f32_res_23928 = fptosi_f32_i64(ceil_res_23927);
            int64_t max_res_23929 = smax64((int64_t) 0, f32_res_23928);
            bool nonnegative_23930 = sle64((int64_t) 0, max_res_23929);
            bool nonzzero_cert_23931;
            
            if (!nonnegative_23930) {
                set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  squarezoom-random.fut:30:28-85\n   #1  ../zoomable.fut:49:34-101\n   #2  ../zoomable.fut:85:8-36\n   #3  squarezoom-random_wrapper.fut:22:6-22\n   #4  squarezoom-random_wrapper.fut:20:1-22:22\n"));
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int64_t min_res_23909 = smin64(height_17626, width_17639);
            float i64_res_23910 = sitofp_i64_f32(min_res_23909);
            float xy_factor_23911 = viewport_17638 * i64_res_23910;
            int32_t i64_res_23912 = sext_i64_i32(width_17639);
            int32_t zm_rhs_23913 = sdiv32(i64_res_23912, 2);
            int32_t r32_arg0_23914 = sub32(mouse_17627, zm_rhs_23913);
            float i32_res_23915 = sitofp_i32_f32(r32_arg0_23914);
            float zm_lhs_23916 = i32_res_23915 / xy_factor_23911;
            float xd_23917 = zm_lhs_23916 - zm_lhs_23916;
            int32_t i64_res_23918 = sext_i64_i32(height_17626);
            int32_t zm_rhs_23919 = sdiv32(i64_res_23918, 2);
            int32_t r32_arg0_23920 = sub32(mouse_17628, zm_rhs_23919);
            float i32_res_23921 = sitofp_i32_f32(r32_arg0_23920);
            float zm_lhs_23922 = i32_res_23921 / xy_factor_23911;
            float yd_23923 = zm_lhs_23922 - zm_lhs_23922;
            float s_23924 = viewport_17636 + xd_23917;
            float s_23925 = viewport_17637 + yd_23923;
            int64_t precision_scale_23932 = shl64((int64_t) 1, max_res_23929);
            int64_t precision_23933 = mul64(min_res_23909, precision_scale_23932);
            float xy_factor_inv_23934 = 1.0F / i64_res_23910;
            float i64_res_23935 = sitofp_i64_f32(precision_23933);
            float zs_lhs_23936 = i64_res_23935 / i64_res_23910;
            float dup_arg0_23937 = zs_lhs_23936 / 2.0F;
            float i64_res_23938 = sitofp_i64_f32(precision_scale_23932);
            float zzoom_factor_23939 = xy_factor_23911 / i64_res_23938;
            int64_t max_arg1_23940 = sub64(width_17639, height_17626);
            int64_t max_res_23941 = smax64((int64_t) 0, max_arg1_23940);
            float i64_res_23942 = sitofp_i64_f32(max_res_23941);
            float offset_23943 = i64_res_23942 / i64_res_23910;
            int64_t max_arg1_23944 = sub64(height_17626, width_17639);
            int64_t max_res_23945 = smax64((int64_t) 0, max_arg1_23944);
            float i64_res_23946 = sitofp_i64_f32(max_res_23945);
            float offset_23947 = i64_res_23946 / i64_res_23910;
            float zt_res_23948 = 0.5F * offset_23947;
            float zt_res_23949 = 0.5F * offset_23943;
            float zp_res_23950 = 0.5F + zt_res_23948;
            float zp_res_23951 = 0.5F + zt_res_23949;
            float zt_res_23952 = viewport_17638 * s_23924;
            float zt_res_23953 = viewport_17638 * s_23925;
            float zm_res_23954 = zp_res_23950 - zt_res_23952;
            float zm_res_23955 = zp_res_23951 - zt_res_23953;
            float zt_res_23956 = i64_res_23910 * zm_res_23954;
            float zt_res_23957 = i64_res_23910 * zm_res_23955;
            
            case_res_23900 = dup_arg0_23937;
            case_res_23901 = dup_arg0_23937;
            case_res_23902 = zt_res_23956;
            case_res_23903 = zt_res_23957;
            case_res_23904 = precision_23933;
            case_res_23905 = xy_factor_inv_23934;
            case_res_23906 = zzoom_factor_23939;
            case_res_23907 = s_23924;
            case_res_23908 = s_23925;
        }
        event_res_23385 = auto_zzoom_17620;
        event_res_23387 = case_res_23900;
        event_res_23388 = case_res_23901;
        event_res_23389 = case_res_23902;
        event_res_23390 = case_res_23903;
        event_res_23391 = case_res_23904;
        event_res_23392 = case_res_23905;
        event_res_23393 = case_res_23906;
        event_res_23394 = case_res_23907;
        event_res_23395 = case_res_23908;
        event_res_23396 = viewport_17638;
    } else {
        event_res_23385 = auto_zzoom_17620;
        event_res_23387 = screen_calculations_17629;
        event_res_23388 = screen_calculations_17630;
        event_res_23389 = screen_calculations_17631;
        event_res_23390 = screen_calculations_17632;
        event_res_23391 = screen_calculations_17633;
        event_res_23392 = screen_calculations_17634;
        event_res_23393 = screen_calculations_17635;
        event_res_23394 = viewport_17636;
        event_res_23395 = viewport_17637;
        event_res_23396 = viewport_17638;
    }
    
    int8_t event_res_23591;
    int64_t event_res_23592;
    int64_t event_res_23593;
    
    if (ezq_20619 == (int8_t) 3) {
        event_res_23591 = base_17622;
        event_res_23592 = base_17623;
        event_res_23593 = base_17624;
    } else if (ezq_20619 == (int8_t) 0) {
        bool cond_23996 = key_17619 == 114;
        int8_t keydown_res_23997;
        int64_t keydown_res_23998;
        int64_t keydown_res_23999;
        
        if (cond_23996 == 1) {
            int64_t zc_rhs_24000 = shl64(base_17623, (int64_t) 23);
            int64_t x_24001 = base_17623 ^ zc_rhs_24000;
            int64_t zc_lhs_24002 = base_17624 ^ x_24001;
            int64_t zc_rhs_24003 = lshr64(x_24001, (int64_t) 17);
            int64_t zc_lhs_24004 = zc_lhs_24002 ^ zc_rhs_24003;
            int64_t zc_rhs_24005 = lshr64(base_17624, (int64_t) 26);
            int64_t new_y_24006 = zc_lhs_24004 ^ zc_rhs_24005;
            int64_t tmp_24007 = add64(base_17624, new_y_24006);
            float t32_arg0_24008 = 3007.0F * base_17625;
            int32_t f32_res_24009 = fptosi_f32_i32(t32_arg0_24008);
            int32_t u64_res_24010 = zext_i64_i32(tmp_24007);
            int32_t rng_from_seed_arg0_24011 = f32_res_24009 ^ u64_res_24010;
            int32_t zc_lhs_24012 = lshr32(rng_from_seed_arg0_24011, 16);
            int32_t zt_lhs_24013 = rng_from_seed_arg0_24011 ^ zc_lhs_24012;
            int32_t x_24014 = mul32(73244475, zt_lhs_24013);
            int32_t zc_lhs_24015 = lshr32(x_24014, 16);
            int32_t zt_lhs_24016 = x_24014 ^ zc_lhs_24015;
            int32_t x_24017 = mul32(73244475, zt_lhs_24016);
            int32_t zc_lhs_24018 = lshr32(x_24017, 16);
            int32_t x_24019 = x_24017 ^ zc_lhs_24018;
            int64_t unsign_arg0_24020 = zext_i32_i64(x_24019);
            int64_t rand_arg0_24021 = (int64_t) 539527247 ^ unsign_arg0_24020;
            int64_t zc_rhs_24022 = shl64(rand_arg0_24021, (int64_t) 23);
            int64_t x_24023 = rand_arg0_24021 ^ zc_rhs_24022;
            int64_t zc_lhs_24024 = (int64_t) 824515495 ^ x_24023;
            int64_t zc_rhs_24025 = lshr64(x_24023, (int64_t) 17);
            int64_t zc_lhs_24026 = zc_lhs_24024 ^ zc_rhs_24025;
            int64_t new_y_24027 = (int64_t) 12 ^ zc_lhs_24026;
            int64_t zc_lhs_24028 = (int64_t) 6916485073332985 ^ zc_lhs_24026;
            int64_t zc_rhs_24029 = lshr64(new_y_24027, (int64_t) 26);
            int64_t new_y_24030 = zc_lhs_24028 ^ zc_rhs_24029;
            int64_t zc_rhs_24031 = shl64(new_y_24027, (int64_t) 23);
            int64_t x_24032 = new_y_24027 ^ zc_rhs_24031;
            int64_t zc_lhs_24033 = new_y_24030 ^ x_24032;
            int64_t zc_rhs_24034 = lshr64(x_24032, (int64_t) 17);
            int64_t zc_lhs_24035 = zc_lhs_24033 ^ zc_rhs_24034;
            int64_t zc_rhs_24036 = lshr64(new_y_24030, (int64_t) 26);
            int64_t new_y_24037 = zc_lhs_24035 ^ zc_rhs_24036;
            
            keydown_res_23997 = base_17622;
            keydown_res_23998 = new_y_24030;
            keydown_res_23999 = new_y_24037;
        } else {
            bool cond_24038 = key_17619 == 104;
            int8_t keydown_res_f_res_24039;
            
            if (cond_24038 == 1) {
                keydown_res_f_res_24039 = (int8_t) 1;
            } else {
                bool cond_24040 = key_17619 == 111;
                int8_t keydown_res_f_res_f_res_24041;
                
                if (cond_24040 == 1) {
                    keydown_res_f_res_f_res_24041 = (int8_t) 2;
                } else {
                    bool cond_24042 = key_17619 == 103;
                    int8_t keydown_res_f_res_f_res_f_res_24043;
                    
                    if (cond_24042 == 1) {
                        keydown_res_f_res_f_res_f_res_24043 = (int8_t) 0;
                    } else {
                        keydown_res_f_res_f_res_f_res_24043 = base_17622;
                    }
                    keydown_res_f_res_f_res_24041 = keydown_res_f_res_f_res_f_res_24043;
                }
                keydown_res_f_res_24039 = keydown_res_f_res_f_res_24041;
            }
            keydown_res_23997 = keydown_res_f_res_24039;
            keydown_res_23998 = base_17623;
            keydown_res_23999 = base_17624;
        }
        event_res_23591 = keydown_res_23997;
        event_res_23592 = keydown_res_23998;
        event_res_23593 = keydown_res_23999;
    } else {
        event_res_23591 = base_17622;
        event_res_23592 = base_17623;
        event_res_23593 = base_17624;
    }
    prim_out_26106 = event_res_23385;
    prim_out_26107 = auto_zzoom_17621;
    prim_out_26108 = event_res_23591;
    prim_out_26109 = event_res_23592;
    prim_out_26110 = event_res_23593;
    prim_out_26111 = base_17625;
    prim_out_26112 = height_17626;
    prim_out_26113 = event_res_23383;
    prim_out_26114 = event_res_23384;
    prim_out_26115 = event_res_23387;
    prim_out_26116 = event_res_23388;
    prim_out_26117 = event_res_23389;
    prim_out_26118 = event_res_23390;
    prim_out_26119 = event_res_23391;
    prim_out_26120 = event_res_23392;
    prim_out_26121 = event_res_23393;
    prim_out_26122 = event_res_23394;
    prim_out_26123 = event_res_23395;
    prim_out_26124 = event_res_23396;
    prim_out_26125 = width_17639;
    *out_prim_out_26555 = prim_out_26106;
    *out_prim_out_26556 = prim_out_26107;
    *out_prim_out_26557 = prim_out_26108;
    *out_prim_out_26558 = prim_out_26109;
    *out_prim_out_26559 = prim_out_26110;
    *out_prim_out_26560 = prim_out_26111;
    *out_prim_out_26561 = prim_out_26112;
    *out_prim_out_26562 = prim_out_26113;
    *out_prim_out_26563 = prim_out_26114;
    *out_prim_out_26564 = prim_out_26115;
    *out_prim_out_26565 = prim_out_26116;
    *out_prim_out_26566 = prim_out_26117;
    *out_prim_out_26567 = prim_out_26118;
    *out_prim_out_26568 = prim_out_26119;
    *out_prim_out_26569 = prim_out_26120;
    *out_prim_out_26570 = prim_out_26121;
    *out_prim_out_26571 = prim_out_26122;
    *out_prim_out_26572 = prim_out_26123;
    *out_prim_out_26573 = prim_out_26124;
    *out_prim_out_26574 = prim_out_26125;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_mouse(struct futhark_context *ctx, bool *out_prim_out_26575, float *out_prim_out_26576, int8_t *out_prim_out_26577, int64_t *out_prim_out_26578, int64_t *out_prim_out_26579, float *out_prim_out_26580, int64_t *out_prim_out_26581, int32_t *out_prim_out_26582, int32_t *out_prim_out_26583, float *out_prim_out_26584, float *out_prim_out_26585, float *out_prim_out_26586, float *out_prim_out_26587, int64_t *out_prim_out_26588, float *out_prim_out_26589, float *out_prim_out_26590, float *out_prim_out_26591, float *out_prim_out_26592, float *out_prim_out_26593, int64_t *out_prim_out_26594, int32_t buttons_17708, int32_t x_17709, int32_t y_17710, bool auto_zzoom_17711, float auto_zzoom_17712, int8_t base_17713, int64_t base_17714, int64_t base_17715, float base_17716, int64_t height_17717, int32_t mouse_17718, int32_t mouse_17719, float screen_calculations_17720, float screen_calculations_17721, float screen_calculations_17722, float screen_calculations_17723, int64_t screen_calculations_17724, float screen_calculations_17725, float screen_calculations_17726, float viewport_17727, float viewport_17728, float viewport_17729, int64_t width_17730)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    bool prim_out_26106;
    float prim_out_26107;
    int8_t prim_out_26108;
    int64_t prim_out_26109;
    int64_t prim_out_26110;
    float prim_out_26111;
    int64_t prim_out_26112;
    int32_t prim_out_26113;
    int32_t prim_out_26114;
    float prim_out_26115;
    float prim_out_26116;
    float prim_out_26117;
    float prim_out_26118;
    int64_t prim_out_26119;
    float prim_out_26120;
    float prim_out_26121;
    float prim_out_26122;
    float prim_out_26123;
    float prim_out_26124;
    int64_t prim_out_26125;
    int32_t x_diff_23461 = sub32(mouse_17718, x_17709);
    int32_t y_diff_23462 = sub32(mouse_17719, y_17710);
    int64_t min_res_23463 = smin64(height_17717, width_17730);
    float i64_res_23464 = sitofp_i64_f32(min_res_23463);
    float xy_factor_23465 = viewport_17729 * i64_res_23464;
    int32_t zeze_lhs_23466 = 1 & buttons_17708;
    bool cond_23467 = zeze_lhs_23466 == 1;
    int32_t zeze_lhs_23468 = 4 & buttons_17708;
    bool cond_f_res_23469 = zeze_lhs_23468 == 4;
    bool x_23470 = !cond_23467;
    bool y_23471 = cond_f_res_23469 && x_23470;
    bool cond_23472 = cond_23467 || y_23471;
    float case_res_23473;
    float case_res_23474;
    float case_res_23475;
    float case_res_23476;
    int64_t case_res_23477;
    float case_res_23478;
    float case_res_23479;
    float case_res_23480;
    float case_res_23481;
    
    if (cond_23472 == 1) {
        float log2_res_23693 = futrts_log2_32(viewport_17729);
        float ceil_res_23694 = futrts_ceil32(log2_res_23693);
        int64_t f32_res_23695 = fptosi_f32_i64(ceil_res_23694);
        int64_t max_res_23696 = smax64((int64_t) 0, f32_res_23695);
        bool nonnegative_23697 = sle64((int64_t) 0, max_res_23696);
        bool nonzzero_cert_23698;
        
        if (!nonnegative_23697) {
            set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  squarezoom-random.fut:30:28-85\n   #1  squarezoom-random_wrapper.fut:25:3-41\n   #2  squarezoom-random_wrapper.fut:24:1-25:41\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        float i32_res_23687 = sitofp_i32_f32(x_diff_23461);
        float zp_rhs_23688 = i32_res_23687 / xy_factor_23465;
        float s_23689 = viewport_17727 + zp_rhs_23688;
        float i32_res_23690 = sitofp_i32_f32(y_diff_23462);
        float zp_rhs_23691 = i32_res_23690 / xy_factor_23465;
        float s_23692 = viewport_17728 + zp_rhs_23691;
        int64_t precision_scale_23699 = shl64((int64_t) 1, max_res_23696);
        int64_t precision_23700 = mul64(min_res_23463, precision_scale_23699);
        float xy_factor_inv_23701 = 1.0F / i64_res_23464;
        float i64_res_23702 = sitofp_i64_f32(precision_23700);
        float zs_lhs_23703 = i64_res_23702 / i64_res_23464;
        float dup_arg0_23704 = zs_lhs_23703 / 2.0F;
        float i64_res_23705 = sitofp_i64_f32(precision_scale_23699);
        float zzoom_factor_23706 = xy_factor_23465 / i64_res_23705;
        int64_t max_arg1_23707 = sub64(width_17730, height_17717);
        int64_t max_res_23708 = smax64((int64_t) 0, max_arg1_23707);
        float i64_res_23709 = sitofp_i64_f32(max_res_23708);
        float offset_23710 = i64_res_23709 / i64_res_23464;
        int64_t max_arg1_23711 = sub64(height_17717, width_17730);
        int64_t max_res_23712 = smax64((int64_t) 0, max_arg1_23711);
        float i64_res_23713 = sitofp_i64_f32(max_res_23712);
        float offset_23714 = i64_res_23713 / i64_res_23464;
        float zt_res_23715 = 0.5F * offset_23714;
        float zt_res_23716 = 0.5F * offset_23710;
        float zp_res_23717 = 0.5F + zt_res_23715;
        float zp_res_23718 = 0.5F + zt_res_23716;
        float zt_res_23719 = viewport_17729 * s_23689;
        float zt_res_23720 = viewport_17729 * s_23692;
        float zm_res_23721 = zp_res_23717 - zt_res_23719;
        float zm_res_23722 = zp_res_23718 - zt_res_23720;
        float zt_res_23723 = i64_res_23464 * zm_res_23721;
        float zt_res_23724 = i64_res_23464 * zm_res_23722;
        
        case_res_23473 = dup_arg0_23704;
        case_res_23474 = dup_arg0_23704;
        case_res_23475 = zt_res_23723;
        case_res_23476 = zt_res_23724;
        case_res_23477 = precision_23700;
        case_res_23478 = xy_factor_inv_23701;
        case_res_23479 = zzoom_factor_23706;
        case_res_23480 = s_23689;
        case_res_23481 = s_23692;
    } else {
        case_res_23473 = screen_calculations_17720;
        case_res_23474 = screen_calculations_17721;
        case_res_23475 = screen_calculations_17722;
        case_res_23476 = screen_calculations_17723;
        case_res_23477 = screen_calculations_17724;
        case_res_23478 = screen_calculations_17725;
        case_res_23479 = screen_calculations_17726;
        case_res_23480 = viewport_17727;
        case_res_23481 = viewport_17728;
    }
    prim_out_26106 = cond_f_res_23469;
    prim_out_26107 = auto_zzoom_17712;
    prim_out_26108 = base_17713;
    prim_out_26109 = base_17714;
    prim_out_26110 = base_17715;
    prim_out_26111 = base_17716;
    prim_out_26112 = height_17717;
    prim_out_26113 = x_17709;
    prim_out_26114 = y_17710;
    prim_out_26115 = case_res_23473;
    prim_out_26116 = case_res_23474;
    prim_out_26117 = case_res_23475;
    prim_out_26118 = case_res_23476;
    prim_out_26119 = case_res_23477;
    prim_out_26120 = case_res_23478;
    prim_out_26121 = case_res_23479;
    prim_out_26122 = case_res_23480;
    prim_out_26123 = case_res_23481;
    prim_out_26124 = viewport_17729;
    prim_out_26125 = width_17730;
    *out_prim_out_26575 = prim_out_26106;
    *out_prim_out_26576 = prim_out_26107;
    *out_prim_out_26577 = prim_out_26108;
    *out_prim_out_26578 = prim_out_26109;
    *out_prim_out_26579 = prim_out_26110;
    *out_prim_out_26580 = prim_out_26111;
    *out_prim_out_26581 = prim_out_26112;
    *out_prim_out_26582 = prim_out_26113;
    *out_prim_out_26583 = prim_out_26114;
    *out_prim_out_26584 = prim_out_26115;
    *out_prim_out_26585 = prim_out_26116;
    *out_prim_out_26586 = prim_out_26117;
    *out_prim_out_26587 = prim_out_26118;
    *out_prim_out_26588 = prim_out_26119;
    *out_prim_out_26589 = prim_out_26120;
    *out_prim_out_26590 = prim_out_26121;
    *out_prim_out_26591 = prim_out_26122;
    *out_prim_out_26592 = prim_out_26123;
    *out_prim_out_26593 = prim_out_26124;
    *out_prim_out_26594 = prim_out_26125;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_render(struct futhark_context *ctx, struct memblock_device *mem_out_p_26595, int64_t *out_prim_out_26596, int64_t *out_prim_out_26597, bool auto_zzoom_20348, float auto_zzoom_20349, int8_t base_20350, int64_t base_20351, int64_t base_20352, float base_20353, int64_t height_20354, int32_t mouse_20355, int32_t mouse_20356, float screen_calculations_20357, float screen_calculations_20358, float screen_calculations_20359, float screen_calculations_20360, int64_t screen_calculations_20361, float screen_calculations_20362, float screen_calculations_20363, float viewport_20364, float viewport_20365, float viewport_20366, int64_t width_20367)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_26078;
    
    mem_26078.references = NULL;
    
    struct memblock_device mem_26072;
    
    mem_26072.references = NULL;
    
    struct memblock_device mem_26069;
    
    mem_26069.references = NULL;
    
    struct memblock_device mem_26104;
    
    mem_26104.references = NULL;
    
    struct memblock_device mem_26098;
    
    mem_26098.references = NULL;
    
    struct memblock_device mem_26095;
    
    mem_26095.references = NULL;
    
    struct memblock_device mem_26091;
    
    mem_26091.references = NULL;
    
    struct memblock_device mem_26085;
    
    mem_26085.references = NULL;
    
    struct memblock_device mem_26082;
    
    mem_26082.references = NULL;
    
    struct memblock_device ext_mem_26105;
    
    ext_mem_26105.references = NULL;
    
    struct memblock_device mem_26065;
    
    mem_26065.references = NULL;
    
    struct memblock_device mem_param_tmp_26154;
    
    mem_param_tmp_26154.references = NULL;
    
    struct memblock_device mem_param_tmp_26153;
    
    mem_param_tmp_26153.references = NULL;
    
    struct memblock_device mem_param_tmp_26152;
    
    mem_param_tmp_26152.references = NULL;
    
    struct memblock_device mem_param_tmp_26151;
    
    mem_param_tmp_26151.references = NULL;
    
    struct memblock_device mem_param_tmp_26150;
    
    mem_param_tmp_26150.references = NULL;
    
    struct memblock_device mem_param_tmp_26149;
    
    mem_param_tmp_26149.references = NULL;
    
    struct memblock_device mem_26023;
    
    mem_26023.references = NULL;
    
    struct memblock_device mem_26020;
    
    mem_26020.references = NULL;
    
    struct memblock_device mem_26017;
    
    mem_26017.references = NULL;
    
    struct memblock_device mem_26014;
    
    mem_26014.references = NULL;
    
    struct memblock_device mem_26011;
    
    mem_26011.references = NULL;
    
    struct memblock_device mem_26008;
    
    mem_26008.references = NULL;
    
    struct memblock_device mem_26030;
    
    mem_26030.references = NULL;
    
    struct memblock_device mem_26027;
    
    mem_26027.references = NULL;
    
    struct memblock_device mem_25944;
    
    mem_25944.references = NULL;
    
    struct memblock_device mem_25940;
    
    mem_25940.references = NULL;
    
    struct memblock_device mem_25935;
    
    mem_25935.references = NULL;
    
    struct memblock_device mem_25930;
    
    mem_25930.references = NULL;
    
    struct memblock_device mem_25927;
    
    mem_25927.references = NULL;
    
    struct memblock_device mem_25924;
    
    mem_25924.references = NULL;
    
    struct memblock_device mem_25918;
    
    mem_25918.references = NULL;
    
    struct memblock_device mem_25913;
    
    mem_25913.references = NULL;
    
    struct memblock_device segred_tmp_mem_26258;
    
    segred_tmp_mem_26258.references = NULL;
    
    struct memblock_device mem_25909;
    
    mem_25909.references = NULL;
    
    struct memblock_device mem_25905;
    
    mem_25905.references = NULL;
    
    struct memblock_device mem_25901;
    
    mem_25901.references = NULL;
    
    struct memblock_device mem_25898;
    
    mem_25898.references = NULL;
    
    struct memblock_device mem_25895;
    
    mem_25895.references = NULL;
    
    struct memblock_device mem_25892;
    
    mem_25892.references = NULL;
    
    struct memblock_device mem_25998;
    
    mem_25998.references = NULL;
    
    struct memblock_device mem_25993;
    
    mem_25993.references = NULL;
    
    struct memblock_device mem_25988;
    
    mem_25988.references = NULL;
    
    struct memblock_device mem_25983;
    
    mem_25983.references = NULL;
    
    struct memblock_device mem_25979;
    
    mem_25979.references = NULL;
    
    struct memblock_device mem_25976;
    
    mem_25976.references = NULL;
    
    struct memblock_device mem_25973;
    
    mem_25973.references = NULL;
    
    struct memblock_device mem_25970;
    
    mem_25970.references = NULL;
    
    struct memblock_device mem_25967;
    
    mem_25967.references = NULL;
    
    struct memblock_device mem_25964;
    
    mem_25964.references = NULL;
    
    struct memblock_device ext_mem_26000;
    
    ext_mem_26000.references = NULL;
    
    struct memblock_device ext_mem_26001;
    
    ext_mem_26001.references = NULL;
    
    struct memblock_device ext_mem_26002;
    
    ext_mem_26002.references = NULL;
    
    struct memblock_device ext_mem_26003;
    
    ext_mem_26003.references = NULL;
    
    struct memblock_device ext_mem_26004;
    
    ext_mem_26004.references = NULL;
    
    struct memblock_device ext_mem_26005;
    
    ext_mem_26005.references = NULL;
    
    struct memblock_device mem_param_25887;
    
    mem_param_25887.references = NULL;
    
    struct memblock_device mem_param_25882;
    
    mem_param_25882.references = NULL;
    
    struct memblock_device mem_param_25877;
    
    mem_param_25877.references = NULL;
    
    struct memblock_device mem_param_25872;
    
    mem_param_25872.references = NULL;
    
    struct memblock_device mem_param_25867;
    
    mem_param_25867.references = NULL;
    
    struct memblock_device mem_param_25862;
    
    mem_param_25862.references = NULL;
    
    struct memblock_device ext_mem_26056;
    
    ext_mem_26056.references = NULL;
    
    struct memblock_device ext_mem_26057;
    
    ext_mem_26057.references = NULL;
    
    struct memblock_device ext_mem_26058;
    
    ext_mem_26058.references = NULL;
    
    struct memblock_device ext_mem_26059;
    
    ext_mem_26059.references = NULL;
    
    struct memblock_device ext_mem_26060;
    
    ext_mem_26060.references = NULL;
    
    struct memblock_device ext_mem_26061;
    
    ext_mem_26061.references = NULL;
    
    struct memblock_device mem_25857;
    
    mem_25857.references = NULL;
    
    struct memblock_device mem_25855;
    
    mem_25855.references = NULL;
    
    struct memblock_device mem_25853;
    
    mem_25853.references = NULL;
    
    struct memblock_device mem_25851;
    
    mem_25851.references = NULL;
    
    struct memblock_device mem_25849;
    
    mem_25849.references = NULL;
    
    struct memblock_device mem_out_26106;
    
    mem_out_26106.references = NULL;
    
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    int64_t prim_out_26107;
    int64_t prim_out_26108;
    int64_t binop_x_26062 = height_20354 * width_20367;
    int64_t binop_y_26063 = (int64_t) 4 * binop_x_26062;
    int64_t bytes_26064 = smax64((int64_t) 0, binop_y_26063);
    float i64_res_22363 = sitofp_i64_f32(screen_calculations_20361);
    float log2_res_22364 = futrts_log2_32(i64_res_22363);
    
    if (memblock_alloc_device(ctx, &mem_25849, (int64_t) 4, "mem_25849")) {
        err = 1;
        goto cleanup;
    }
    if (futrts_builtinzhreplicate_f32(ctx, mem_25849, (int64_t) 1, 1.0F) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc_device(ctx, &mem_25851, (int64_t) 8, "mem_25851")) {
        err = 1;
        goto cleanup;
    }
    if (futrts_builtinzhreplicate_i64(ctx, mem_25851, (int64_t) 1, (int64_t) 0) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc_device(ctx, &mem_25853, (int64_t) 4, "mem_25853")) {
        err = 1;
        goto cleanup;
    }
    if (futrts_builtinzhreplicate_f32(ctx, mem_25853, (int64_t) 1, base_20353) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc_device(ctx, &mem_25855, (int64_t) 8, "mem_25855")) {
        err = 1;
        goto cleanup;
    }
    if (futrts_builtinzhreplicate_i64(ctx, mem_25855, (int64_t) 1, base_20351) != 0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_alloc_device(ctx, &mem_25857, (int64_t) 8, "mem_25857")) {
        err = 1;
        goto cleanup;
    }
    if (futrts_builtinzhreplicate_i64(ctx, mem_25857, (int64_t) 1, base_20352) != 0) {
        err = 1;
        goto cleanup;
    }
    
    int32_t f32_res_22370 = fptosi_f32_i32(log2_res_22364);
    int64_t segmap_group_sizze_24847;
    
    segmap_group_sizze_24847 = *ctx->tuning_params.renderzisegmap_group_sizze_24792;
    
    int64_t segred_group_sizze_24905;
    
    segred_group_sizze_24905 = *ctx->tuning_params.renderzisegred_group_sizze_24772;
    
    int64_t segmap_group_sizze_24921;
    
    segmap_group_sizze_24921 = *ctx->tuning_params.renderzisegmap_group_sizze_24758;
    
    int64_t segmap_group_sizze_24936;
    
    segmap_group_sizze_24936 = *ctx->tuning_params.renderzisegmap_group_sizze_24734;
    
    int64_t segmap_group_sizze_24947;
    
    segmap_group_sizze_24947 = *ctx->tuning_params.renderzisegmap_group_sizze_24702;
    
    int64_t segmap_group_sizze_24971;
    
    segmap_group_sizze_24971 = *ctx->tuning_params.renderzisegmap_group_sizze_24681;
    
    int64_t segmap_group_sizze_24986;
    
    segmap_group_sizze_24986 = *ctx->tuning_params.renderzisegmap_group_sizze_24527;
    
    int64_t segmap_group_sizze_24369;
    
    segmap_group_sizze_24369 = *ctx->tuning_params.renderzisegmap_group_sizze_24229;
    
    int64_t segscan_group_sizze_25065;
    
    segscan_group_sizze_25065 = *ctx->tuning_params.renderzisegscan_group_sizze_25064;
    
    int64_t segmap_group_sizze_25075;
    
    segmap_group_sizze_25075 = *ctx->tuning_params.renderzisegmap_group_sizze_25074;
    
    int64_t ext_26053;
    int64_t ext_26052;
    int64_t ext_26049;
    int64_t ext_26048;
    int64_t ext_26045;
    int64_t ext_26044;
    int64_t ext_26041;
    int64_t ext_26040;
    int64_t ext_26037;
    int64_t ext_26036;
    int64_t ext_26033;
    int64_t ext_26032;
    int64_t r_22371;
    int64_t r_22378;
    int64_t loop_dz2083Uz2086U_22380;
    int64_t blocks_22387;
    int64_t ctx_param_ext_25860;
    int64_t ctx_param_ext_25861;
    int64_t ctx_param_ext_25865;
    int64_t ctx_param_ext_25866;
    int64_t ctx_param_ext_25870;
    int64_t ctx_param_ext_25871;
    int64_t ctx_param_ext_25875;
    int64_t ctx_param_ext_25876;
    int64_t ctx_param_ext_25880;
    int64_t ctx_param_ext_25881;
    int64_t ctx_param_ext_25885;
    int64_t ctx_param_ext_25886;
    
    if (memblock_set_device(ctx, &mem_param_25862, &mem_25849, "mem_25849") != 0)
        return 1;
    if (memblock_set_device(ctx, &mem_param_25867, &mem_25851, "mem_25851") != 0)
        return 1;
    if (memblock_set_device(ctx, &mem_param_25872, &mem_25851, "mem_25851") != 0)
        return 1;
    if (memblock_set_device(ctx, &mem_param_25877, &mem_25853, "mem_25853") != 0)
        return 1;
    if (memblock_set_device(ctx, &mem_param_25882, &mem_25855, "mem_25855") != 0)
        return 1;
    if (memblock_set_device(ctx, &mem_param_25887, &mem_25857, "mem_25857") != 0)
        return 1;
    ctx_param_ext_25860 = (int64_t) 1;
    ctx_param_ext_25861 = (int64_t) 1;
    ctx_param_ext_25865 = (int64_t) 1;
    ctx_param_ext_25866 = (int64_t) 1;
    ctx_param_ext_25870 = (int64_t) 1;
    ctx_param_ext_25871 = (int64_t) 1;
    ctx_param_ext_25875 = (int64_t) 1;
    ctx_param_ext_25876 = (int64_t) 1;
    ctx_param_ext_25880 = (int64_t) 1;
    ctx_param_ext_25881 = (int64_t) 1;
    ctx_param_ext_25885 = (int64_t) 1;
    ctx_param_ext_25886 = (int64_t) 1;
    loop_dz2083Uz2086U_22380 = (int64_t) 1;
    blocks_22387 = screen_calculations_20361;
    for (int32_t _i_22379 = 0; _i_22379 < f32_res_22370; _i_22379++) {
        int64_t dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388 = mul64((int64_t) 4, loop_dz2083Uz2086U_22380);
        int64_t sizzezq_22389 = sdiv64(blocks_22387, (int64_t) 2);
        bool suff_outer_par_24225;
        
        suff_outer_par_24225 = *ctx->tuning_params.renderzisuff_outer_par_0 <= loop_dz2083Uz2086U_22380;
        if (ctx->logging)
            fprintf(ctx->log, "Compared %s <= %ld: %s.\n", "render.suff_outer_par_0", (long) loop_dz2083Uz2086U_22380, suff_outer_par_24225 ? "true" : "false");
        
        int64_t num_groups_24848;
        int32_t max_num_groups_26175;
        
        max_num_groups_26175 = *ctx->tuning_params.renderzisegmap_num_groups_24794;
        num_groups_24848 = sext_i64_i32(smax64((int64_t) 1, smin64(sdiv_up64(loop_dz2083Uz2086U_22380, segmap_group_sizze_24847), sext_i32_i64(max_num_groups_26175))));
        
        int64_t num_groups_24906;
        int32_t max_num_groups_26176;
        
        max_num_groups_26176 = *ctx->tuning_params.renderzisegred_num_groups_24774;
        num_groups_24906 = sext_i64_i32(smax64((int64_t) 1, smin64(sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, segred_group_sizze_24905), sext_i32_i64(max_num_groups_26176))));
        
        int64_t num_groups_24948;
        int32_t max_num_groups_26177;
        
        max_num_groups_26177 = *ctx->tuning_params.renderzisegmap_num_groups_24704;
        num_groups_24948 = sext_i64_i32(smax64((int64_t) 1, smin64(sdiv_up64(loop_dz2083Uz2086U_22380, segmap_group_sizze_24947), sext_i32_i64(max_num_groups_26177))));
        
        int64_t num_groups_24370;
        int32_t max_num_groups_26178;
        
        max_num_groups_26178 = *ctx->tuning_params.renderzisegmap_num_groups_24231;
        num_groups_24370 = sext_i64_i32(smax64((int64_t) 1, smin64(sdiv_up64(loop_dz2083Uz2086U_22380, segmap_group_sizze_24369), sext_i32_i64(max_num_groups_26178))));
        
        int64_t bytes_25891 = smax64((int64_t) 0, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388);
        int64_t bytes_25894 = (int64_t) 16 * loop_dz2083Uz2086U_22380;
        int64_t binop_y_25896 = (int64_t) 8 * loop_dz2083Uz2086U_22380;
        int64_t bytes_25897 = smax64((int64_t) 0, binop_y_25896);
        int64_t bytes_25908 = smax64((int64_t) 0, bytes_25894);
        int64_t bytes_25926 = (int64_t) 32 * loop_dz2083Uz2086U_22380;
        int64_t bytes_25939 = smax64((int64_t) 0, bytes_25926);
        int32_t local_memory_capacity_26374;
        
        local_memory_capacity_26374 = ctx->max_local_memory;
        if (suff_outer_par_24225 == 1 && sle64((int64_t) 0, sext_i32_i64(local_memory_capacity_26374))) {
            if (memblock_alloc_device(ctx, &mem_25964, bytes_25894, "mem_25964")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25967, bytes_25926, "mem_25967")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25970, bytes_25926, "mem_25970")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25973, bytes_25894, "mem_25973")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25976, bytes_25926, "mem_25976")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25979, bytes_25926, "mem_25979")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegMap");
            
            int32_t virt_num_groups_26179 = sext_i64_i32(sdiv_up64(loop_dz2083Uz2086U_22380, segmap_group_sizze_24369));
            
            {
                err = gpu_kernel_renderzisegmap_24379(ctx, num_groups_24370, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_24229, 1, 1, 0, loop_dz2083Uz2086U_22380, num_groups_24370, virt_num_groups_26179, mem_param_25862.mem, mem_param_25867.mem, mem_param_25872.mem, mem_param_25877.mem, mem_param_25882.mem, mem_param_25887.mem, mem_25964.mem, mem_25967.mem, mem_25970.mem, mem_25973.mem, mem_25976.mem, mem_25979.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            if (memblock_alloc_device(ctx, &mem_25983, bytes_25908, "mem_25983")) {
                err = 1;
                goto cleanup;
            }
            if (futrts_builtinzhgpu_map_transpose_f32(ctx, mem_25983, (int64_t) 0, mem_25964, (int64_t) 0, (int64_t) 1, loop_dz2083Uz2086U_22380, (int64_t) 4) != 0) {
                err = 1;
                goto cleanup;
            }
            if (memblock_unref_device(ctx, &mem_25964, "mem_25964") != 0)
                return 1;
            if (memblock_alloc_device(ctx, &mem_25988, bytes_25908, "mem_25988")) {
                err = 1;
                goto cleanup;
            }
            if (futrts_builtinzhgpu_map_transpose_f32(ctx, mem_25988, (int64_t) 0, mem_25973, (int64_t) 0, (int64_t) 1, loop_dz2083Uz2086U_22380, (int64_t) 4) != 0) {
                err = 1;
                goto cleanup;
            }
            if (memblock_unref_device(ctx, &mem_25973, "mem_25973") != 0)
                return 1;
            if (memblock_alloc_device(ctx, &mem_25993, bytes_25939, "mem_25993")) {
                err = 1;
                goto cleanup;
            }
            if (futrts_builtinzhgpu_map_transpose_i64(ctx, mem_25993, (int64_t) 0, mem_25976, (int64_t) 0, (int64_t) 1, loop_dz2083Uz2086U_22380, (int64_t) 4) != 0) {
                err = 1;
                goto cleanup;
            }
            if (memblock_unref_device(ctx, &mem_25976, "mem_25976") != 0)
                return 1;
            if (memblock_alloc_device(ctx, &mem_25998, bytes_25939, "mem_25998")) {
                err = 1;
                goto cleanup;
            }
            if (futrts_builtinzhgpu_map_transpose_i64(ctx, mem_25998, (int64_t) 0, mem_25979, (int64_t) 0, (int64_t) 1, loop_dz2083Uz2086U_22380, (int64_t) 4) != 0) {
                err = 1;
                goto cleanup;
            }
            if (memblock_unref_device(ctx, &mem_25979, "mem_25979") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26005, &mem_25983, "mem_25983") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26004, &mem_25967, "mem_25967") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26003, &mem_25970, "mem_25970") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26002, &mem_25988, "mem_25988") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26001, &mem_25993, "mem_25993") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26000, &mem_25998, "mem_25998") != 0)
                return 1;
        } else {
            if (memblock_alloc_device(ctx, &mem_25892, bytes_25891, "mem_25892")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25895, bytes_25894, "mem_25895")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25898, bytes_25897, "mem_25898")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25901, bytes_25897, "mem_25901")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegMap");
            
            int32_t virt_num_groups_26210 = sext_i64_i32(sdiv_up64(loop_dz2083Uz2086U_22380, segmap_group_sizze_24847));
            
            {
                err = gpu_kernel_renderzisegmap_24855(ctx, num_groups_24848, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_24792, 1, 1, 0, loop_dz2083Uz2086U_22380, num_groups_24848, virt_num_groups_26210, mem_param_25877.mem, mem_param_25882.mem, mem_param_25887.mem, mem_25892.mem, mem_25895.mem, mem_25898.mem, mem_25901.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            if (memblock_alloc_device(ctx, &mem_25905, bytes_25891, "mem_25905")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25909, bytes_25908, "mem_25909")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegRed");
            if (slt64((int64_t) 8, segred_group_sizze_24905)) {
                int64_t segment_sizze_nonzzero_26225 = smax64((int64_t) 1, (int64_t) 4);
                int64_t num_threads_26226 = num_groups_24906 * segred_group_sizze_24905;
                
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "# SegRed-small");
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "num_segments", (long long) loop_dz2083Uz2086U_22380, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "segment_size", (long long) (int64_t) 4, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "segments_per_group", (long long) squot64(segred_group_sizze_24905, segment_sizze_nonzzero_26225), '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "required_groups", (long long) sext_i64_i32(sdiv_up64(loop_dz2083Uz2086U_22380, squot64(segred_group_sizze_24905, segment_sizze_nonzzero_26225))), '\n');
                {
                    err = gpu_kernel_renderzisegred_small_24912(ctx, num_groups_24906, 1, 1, *ctx->tuning_params.renderzisegred_group_sizze_24772, 1, 1, 0 + (int64_t) 4 * segred_group_sizze_24905, (int64_t) 4 * segred_group_sizze_24905, loop_dz2083Uz2086U_22380, num_groups_24906, segment_sizze_nonzzero_26225, mem_25892.mem, mem_25895.mem, mem_25905.mem, mem_25909.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            } else {
                int64_t groups_per_segment_26253 = sdiv_up64(num_groups_24906, smax64((int64_t) 1, loop_dz2083Uz2086U_22380));
                int64_t elements_per_thread_26254 = sdiv_up64((int64_t) 4, segred_group_sizze_24905 * groups_per_segment_26253);
                int64_t virt_num_groups_26255 = groups_per_segment_26253 * loop_dz2083Uz2086U_22380;
                int64_t num_threads_26256 = num_groups_24906 * segred_group_sizze_24905;
                int64_t threads_per_segment_26257 = groups_per_segment_26253 * segred_group_sizze_24905;
                
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "# SegRed-large");
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "num_segments", (long long) loop_dz2083Uz2086U_22380, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "segment_size", (long long) (int64_t) 4, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "virt_num_groups", (long long) virt_num_groups_26255, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "num_groups", (long long) num_groups_24906, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "group_size", (long long) segred_group_sizze_24905, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "elems_per_thread", (long long) elements_per_thread_26254, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "groups_per_segment", (long long) groups_per_segment_26253, '\n');
                if (memblock_alloc_device(ctx, &segred_tmp_mem_26258, (int64_t) 4 * virt_num_groups_26255, "segred_tmp_mem_26258")) {
                    err = 1;
                    goto cleanup;
                }
                {
                    err = gpu_kernel_renderzisegred_large_24912(ctx, num_groups_24906, 1, 1, *ctx->tuning_params.renderzisegred_group_sizze_24772, 1, 1, 0 + 1 + (int64_t) 4 * segred_group_sizze_24905, 1, (int64_t) 4 * segred_group_sizze_24905, loop_dz2083Uz2086U_22380, num_groups_24906, groups_per_segment_26253, elements_per_thread_26254, virt_num_groups_26255, threads_per_segment_26257, mem_25892.mem, mem_25895.mem, mem_25905.mem, mem_25909.mem, segred_tmp_mem_26258.mem, counters_mem_26260.mem);
                    if (err != FUTHARK_SUCCESS)
                        goto cleanup;
                }
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            if (memblock_unref_device(ctx, &mem_25892, "mem_25892") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_25895, "mem_25895") != 0)
                return 1;
            
            int64_t segmap_usable_groups_24922 = sdiv_up64(loop_dz2083Uz2086U_22380, segmap_group_sizze_24921);
            
            if (memblock_alloc_device(ctx, &mem_25913, bytes_25891, "mem_25913")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegMap");
            
            int32_t virt_num_groups_26315 = sext_i64_i32(sdiv_up64(loop_dz2083Uz2086U_22380, segmap_group_sizze_24921));
            
            {
                err = gpu_kernel_renderzisegmap_24925(ctx, segmap_usable_groups_24922, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_24758, 1, 1, 0, loop_dz2083Uz2086U_22380, mem_param_25862.mem, mem_25905.mem, mem_25913.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            if (memblock_unref_device(ctx, &mem_25905, "mem_25905") != 0)
                return 1;
            
            int64_t segmap_usable_groups_24937 = sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, segmap_group_sizze_24936);
            
            if (memblock_alloc_device(ctx, &mem_25918, bytes_25908, "mem_25918")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegMap");
            
            int32_t virt_num_groups_26324 = sext_i64_i32(sdiv_up64(loop_dz2083Uz2086U_22380 * (int64_t) 4, segmap_group_sizze_24936));
            
            {
                err = gpu_kernel_renderzisegmap_24941(ctx, segmap_usable_groups_24937, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_24734, 1, 1, 0, loop_dz2083Uz2086U_22380, mem_25909.mem, mem_25913.mem, mem_25918.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            if (memblock_unref_device(ctx, &mem_25909, "mem_25909") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_25913, "mem_25913") != 0)
                return 1;
            if (memblock_alloc_device(ctx, &mem_25924, bytes_25891, "mem_25924")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25927, bytes_25926, "mem_25927")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25930, bytes_25926, "mem_25930")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegMap");
            
            int32_t virt_num_groups_26335 = sext_i64_i32(sdiv_up64(loop_dz2083Uz2086U_22380, segmap_group_sizze_24947));
            
            {
                err = gpu_kernel_renderzisegmap_24954(ctx, num_groups_24948, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_24702, 1, 1, 0, loop_dz2083Uz2086U_22380, num_groups_24948, virt_num_groups_26335, mem_param_25867.mem, mem_param_25872.mem, mem_param_25877.mem, mem_25924.mem, mem_25927.mem, mem_25930.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            
            int64_t segmap_usable_groups_24972 = sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, segmap_group_sizze_24971);
            
            if (memblock_alloc_device(ctx, &mem_25935, bytes_25908, "mem_25935")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegMap");
            
            int32_t virt_num_groups_26352 = sext_i64_i32(sdiv_up64(loop_dz2083Uz2086U_22380 * (int64_t) 4, segmap_group_sizze_24971));
            
            {
                err = gpu_kernel_renderzisegmap_24976(ctx, segmap_usable_groups_24972, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_24681, 1, 1, 0, loop_dz2083Uz2086U_22380, mem_25924.mem, mem_25935.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            if (memblock_unref_device(ctx, &mem_25924, "mem_25924") != 0)
                return 1;
            
            int64_t segmap_usable_groups_24987 = sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, segmap_group_sizze_24986);
            
            if (memblock_alloc_device(ctx, &mem_25940, bytes_25939, "mem_25940")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc_device(ctx, &mem_25944, bytes_25939, "mem_25944")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegMap");
            
            int32_t virt_num_groups_26363 = sext_i64_i32(sdiv_up64(loop_dz2083Uz2086U_22380 * (int64_t) 4, segmap_group_sizze_24986));
            
            {
                err = gpu_kernel_renderzisegmap_24992(ctx, segmap_usable_groups_24987, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_24527, 1, 1, 0, loop_dz2083Uz2086U_22380, mem_25898.mem, mem_25901.mem, mem_25940.mem, mem_25944.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            if (memblock_unref_device(ctx, &mem_25898, "mem_25898") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_25901, "mem_25901") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26005, &mem_25918, "mem_25918") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26004, &mem_25927, "mem_25927") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26003, &mem_25930, "mem_25930") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26002, &mem_25935, "mem_25935") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26001, &mem_25940, "mem_25940") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_26000, &mem_25944, "mem_25944") != 0)
                return 1;
        }
        
        int64_t num_groups_25067;
        int32_t max_num_groups_26375;
        
        max_num_groups_26375 = *ctx->tuning_params.renderzisegscan_num_groups_25066;
        num_groups_25067 = sext_i64_i32(smax64((int64_t) 1, smin64(sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, segscan_group_sizze_25065), sext_i32_i64(max_num_groups_26375))));
        if (memblock_alloc_device(ctx, &mem_26027, bytes_25939, "mem_26027")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc_device(ctx, &mem_26030, bytes_25939, "mem_26030")) {
            err = 1;
            goto cleanup;
        }
        if (slt64((int64_t) 0, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388)) {
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegScan");
            
            int64_t stage1_max_num_groups_26376;
            
            stage1_max_num_groups_26376 = ctx->max_group_size;
            
            int64_t stage1_num_groups_26377 = smin64(stage1_max_num_groups_26376, num_groups_25067);
            int32_t num_threads_26378 = sext_i64_i32(stage1_num_groups_26377 * segscan_group_sizze_25065);
            
            {
                err = gpu_kernel_renderziscan_stage1_25070(ctx, stage1_num_groups_26377, 1, 1, *ctx->tuning_params.renderzisegscan_group_sizze_25064, 1, 1, 0 + smax64((int64_t) 1, (int64_t) 8 * segscan_group_sizze_25065), smax64((int64_t) 1, (int64_t) 8 * segscan_group_sizze_25065), height_20354, screen_calculations_20357, screen_calculations_20358, screen_calculations_20359, screen_calculations_20360, screen_calculations_20362, screen_calculations_20363, width_20367, loop_dz2083Uz2086U_22380, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, sizzezq_22389, num_threads_26378, ext_mem_26003.mem, ext_mem_26004.mem, mem_26027.mem, mem_26030.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "elems_per_group", (long long) (segscan_group_sizze_25065 * sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, sext_i32_i64(num_threads_26378))), '\n');
            {
                err = gpu_kernel_renderziscan_stage2_25070(ctx, (int64_t) 1, 1, 1, stage1_num_groups_26377, 1, 1, 0 + smax64((int64_t) 1, (int64_t) 8 * stage1_num_groups_26377), smax64((int64_t) 1, (int64_t) 8 * stage1_num_groups_26377), dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, stage1_num_groups_26377, num_threads_26378, mem_26027.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            
            int32_t required_groups_26423 = sext_i64_i32(sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, segscan_group_sizze_25065));
            
            {
                err = gpu_kernel_renderziscan_stage3_25070(ctx, num_groups_25067, 1, 1, *ctx->tuning_params.renderzisegscan_group_sizze_25064, 1, 1, 0, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, num_groups_25067, num_threads_26378, required_groups_26423, mem_26027.mem);
                if (err != FUTHARK_SUCCESS)
                    goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
        }
        
        int64_t last_index_22504 = dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388 - (int64_t) 1;
        bool is_empty_22505 = dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388 == (int64_t) 0;
        bool x_22506 = !is_empty_22505;
        int64_t last_offset_22507;
        
        if (x_22506 == 1) {
            int64_t read_res_26598;
            
            OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->queue, mem_26027.mem, ctx->failure_is_an_option ? CL_FALSE : CL_TRUE, last_index_22504 * sizeof(int64_t), sizeof(int64_t), &read_res_26598, 0, NULL, ctx->profiling_paused || !ctx->profiling ? NULL : opencl_get_event(ctx, "copy_scalar_from_dev")));
            if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
                return 1;
            
            int64_t x_23992 = read_res_26598;
            
            last_offset_22507 = x_23992;
        } else {
            last_offset_22507 = (int64_t) 0;
        }
        
        int64_t partition_sizze_22509;
        
        if (is_empty_22505 == 1) {
            partition_sizze_22509 = (int64_t) 0;
        } else {
            partition_sizze_22509 = last_offset_22507;
        }
        
        bool eq_x_zz_22533 = (int64_t) 0 == last_offset_22507;
        bool p_and_eq_x_y_22534 = x_22506 && eq_x_zz_22533;
        bool empty_slice_22535 = is_empty_22505 || p_and_eq_x_y_22534;
        int64_t m_22536 = sub64(partition_sizze_22509, (int64_t) 1);
        bool zzero_leq_i_p_m_t_s_22537 = sle64((int64_t) 0, m_22536);
        bool i_p_m_t_s_leq_w_22538 = slt64(m_22536, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388);
        bool i_lte_j_22539 = sle64((int64_t) 0, partition_sizze_22509);
        bool y_22540 = zzero_leq_i_p_m_t_s_22537 && i_p_m_t_s_leq_w_22538;
        bool forwards_ok_22541 = i_lte_j_22539 && y_22540;
        bool ok_or_empty_22542 = empty_slice_22535 || forwards_ok_22541;
        bool index_certs_22543;
        
        if (!ok_or_empty_22542) {
            set_error(ctx, msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s", "Index [:", (long long) partition_sizze_22509, "] out of bounds for array of shape [", (long long) dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, "].", "-> #0  /prelude/soacs.fut:173:6-17\n   #1  /prelude/functional.fut:9:44-45\n   #2  squarezoom-random.fut:108:18-34\n   #3  squarezoom-random.fut:114:15-21\n   #4  squarezoom-random_wrapper.fut:33:27-41\n   #5  squarezoom-random_wrapper.fut:33:1-41\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        if (memblock_alloc_device(ctx, &mem_26008, bytes_25939, "mem_26008")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc_device(ctx, &mem_26011, bytes_25939, "mem_26011")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc_device(ctx, &mem_26014, bytes_25908, "mem_26014")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc_device(ctx, &mem_26017, bytes_25939, "mem_26017")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc_device(ctx, &mem_26020, bytes_25939, "mem_26020")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc_device(ctx, &mem_26023, bytes_25908, "mem_26023")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t segmap_usable_groups_25076 = sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, segmap_group_sizze_25075);
        
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        
        int32_t virt_num_groups_26436 = sext_i64_i32(sdiv_up64(dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, segmap_group_sizze_25075));
        
        {
            err = gpu_kernel_renderzisegmap_25072(ctx, segmap_usable_groups_25076, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_25074, 1, 1, 0, loop_dz2083Uz2086U_22380, dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388, ext_mem_26000.mem, ext_mem_26001.mem, ext_mem_26002.mem, ext_mem_26003.mem, ext_mem_26004.mem, ext_mem_26005.mem, mem_26008.mem, mem_26011.mem, mem_26014.mem, mem_26017.mem, mem_26020.mem, mem_26023.mem, mem_26027.mem, mem_26030.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_unref_device(ctx, &ext_mem_26000, "ext_mem_26000") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26001, "ext_mem_26001") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26002, "ext_mem_26002") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26003, "ext_mem_26003") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26004, "ext_mem_26004") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26005, "ext_mem_26005") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26027, "mem_26027") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26030, "mem_26030") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_tmp_26149, &mem_26023, "mem_26023") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_tmp_26150, &mem_26020, "mem_26020") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_tmp_26151, &mem_26017, "mem_26017") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_tmp_26152, &mem_26014, "mem_26014") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_tmp_26153, &mem_26011, "mem_26011") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_tmp_26154, &mem_26008, "mem_26008") != 0)
            return 1;
        
        int64_t ctx_param_ext_tmp_26155 = partition_sizze_22509;
        int64_t ctx_param_ext_tmp_26156 = dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388;
        int64_t ctx_param_ext_tmp_26157 = partition_sizze_22509;
        int64_t ctx_param_ext_tmp_26158 = dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388;
        int64_t ctx_param_ext_tmp_26159 = partition_sizze_22509;
        int64_t ctx_param_ext_tmp_26160 = dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388;
        int64_t ctx_param_ext_tmp_26161 = partition_sizze_22509;
        int64_t ctx_param_ext_tmp_26162 = dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388;
        int64_t ctx_param_ext_tmp_26163 = partition_sizze_22509;
        int64_t ctx_param_ext_tmp_26164 = dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388;
        int64_t ctx_param_ext_tmp_26165 = partition_sizze_22509;
        int64_t ctx_param_ext_tmp_26166 = dzlz7bUZLztZRz20Udz2081Uz20U4z7dUzg_22388;
        int64_t loop_dz2083Uz2086U_tmp_26167 = partition_sizze_22509;
        int64_t blocks_tmp_26174 = sizzezq_22389;
        
        if (memblock_set_device(ctx, &mem_param_25862, &mem_param_tmp_26149, "mem_param_tmp_26149") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_25867, &mem_param_tmp_26150, "mem_param_tmp_26150") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_25872, &mem_param_tmp_26151, "mem_param_tmp_26151") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_25877, &mem_param_tmp_26152, "mem_param_tmp_26152") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_25882, &mem_param_tmp_26153, "mem_param_tmp_26153") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_25887, &mem_param_tmp_26154, "mem_param_tmp_26154") != 0)
            return 1;
        ctx_param_ext_25860 = ctx_param_ext_tmp_26155;
        ctx_param_ext_25861 = ctx_param_ext_tmp_26156;
        ctx_param_ext_25865 = ctx_param_ext_tmp_26157;
        ctx_param_ext_25866 = ctx_param_ext_tmp_26158;
        ctx_param_ext_25870 = ctx_param_ext_tmp_26159;
        ctx_param_ext_25871 = ctx_param_ext_tmp_26160;
        ctx_param_ext_25875 = ctx_param_ext_tmp_26161;
        ctx_param_ext_25876 = ctx_param_ext_tmp_26162;
        ctx_param_ext_25880 = ctx_param_ext_tmp_26163;
        ctx_param_ext_25881 = ctx_param_ext_tmp_26164;
        ctx_param_ext_25885 = ctx_param_ext_tmp_26165;
        ctx_param_ext_25886 = ctx_param_ext_tmp_26166;
        loop_dz2083Uz2086U_22380 = loop_dz2083Uz2086U_tmp_26167;
        blocks_22387 = blocks_tmp_26174;
    }
    if (memblock_set_device(ctx, &ext_mem_26061, &mem_param_25862, "mem_param_25862") != 0)
        return 1;
    if (memblock_set_device(ctx, &ext_mem_26060, &mem_param_25867, "mem_param_25867") != 0)
        return 1;
    if (memblock_set_device(ctx, &ext_mem_26059, &mem_param_25872, "mem_param_25872") != 0)
        return 1;
    if (memblock_set_device(ctx, &ext_mem_26058, &mem_param_25877, "mem_param_25877") != 0)
        return 1;
    if (memblock_set_device(ctx, &ext_mem_26057, &mem_param_25882, "mem_param_25882") != 0)
        return 1;
    if (memblock_set_device(ctx, &ext_mem_26056, &mem_param_25887, "mem_param_25887") != 0)
        return 1;
    ext_26053 = ctx_param_ext_25860;
    ext_26052 = ctx_param_ext_25861;
    ext_26049 = ctx_param_ext_25865;
    ext_26048 = ctx_param_ext_25866;
    ext_26045 = ctx_param_ext_25870;
    ext_26044 = ctx_param_ext_25871;
    ext_26041 = ctx_param_ext_25875;
    ext_26040 = ctx_param_ext_25876;
    ext_26037 = ctx_param_ext_25880;
    ext_26036 = ctx_param_ext_25881;
    ext_26033 = ctx_param_ext_25885;
    ext_26032 = ctx_param_ext_25886;
    r_22371 = loop_dz2083Uz2086U_22380;
    r_22378 = blocks_22387;
    if (memblock_unref_device(ctx, &mem_25849, "mem_25849") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_25851, "mem_25851") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_25853, "mem_25853") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_25855, "mem_25855") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_25857, "mem_25857") != 0)
        return 1;
    if (memblock_alloc_device(ctx, &mem_26065, bytes_26064, "mem_26065")) {
        err = 1;
        goto cleanup;
    }
    if (futrts_builtinzhreplicate_f32(ctx, mem_26065, height_20354 * width_20367, 0.0F) != 0) {
        err = 1;
        goto cleanup;
    }
    
    int64_t binop_y_26067 = (int64_t) 8 * r_22371;
    int64_t bytes_26068 = smax64((int64_t) 0, binop_y_26067);
    
    if (base_20350 == (int8_t) 1) {
        int64_t segmap_group_sizze_25100;
        
        segmap_group_sizze_25100 = *ctx->tuning_params.renderzisegmap_group_sizze_25080;
        
        int64_t segmap_usable_groups_25101 = sdiv_up64(r_22371, segmap_group_sizze_25100);
        
        if (memblock_alloc_device(ctx, &mem_26082, bytes_26068, "mem_26082")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc_device(ctx, &mem_26085, bytes_26068, "mem_26085")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        
        int32_t virt_num_groups_26445 = sext_i64_i32(sdiv_up64(r_22371, segmap_group_sizze_25100));
        
        {
            err = gpu_kernel_renderzisegmap_25105(ctx, segmap_usable_groups_25101, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_25080, 1, 1, 0, screen_calculations_20357, screen_calculations_20358, screen_calculations_20359, screen_calculations_20360, screen_calculations_20362, screen_calculations_20363, r_22371, ext_mem_26059.mem, ext_mem_26060.mem, mem_26082.mem, mem_26085.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        
        int64_t segmap_group_sizze_25124;
        
        segmap_group_sizze_25124 = *ctx->tuning_params.renderzisegmap_group_sizze_25123;
        
        int64_t segmap_usable_groups_25125 = sdiv_up64(r_22371, segmap_group_sizze_25124);
        
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        
        int32_t virt_num_groups_26454 = sext_i64_i32(sdiv_up64(r_22371, segmap_group_sizze_25124));
        
        {
            err = gpu_kernel_renderzisegmap_25121(ctx, segmap_usable_groups_25125, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_25123, 1, 1, 0, height_20354, width_20367, r_22371, ext_mem_26061.mem, mem_26065.mem, mem_26082.mem, mem_26085.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_unref_device(ctx, &mem_26082, "mem_26082") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26085, "mem_26085") != 0)
            return 1;
        
        int64_t segmap_group_sizze_25295;
        
        segmap_group_sizze_25295 = *ctx->tuning_params.renderzisegmap_group_sizze_25139;
        
        int64_t segmap_usable_groups_25296 = sdiv_up64(binop_x_26062, segmap_group_sizze_25295);
        
        if (memblock_alloc_device(ctx, &mem_26091, bytes_26064, "mem_26091")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        
        int32_t virt_num_groups_26463 = sext_i64_i32(sdiv_up64(height_20354 * width_20367, segmap_group_sizze_25295));
        
        {
            err = gpu_kernel_renderzisegmap_25300(ctx, segmap_usable_groups_25296, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_25139, 1, 1, 0, height_20354, width_20367, mem_26065.mem, mem_26091.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_set_device(ctx, &ext_mem_26105, &mem_26091, "mem_26091") != 0)
            return 1;
    } else if (base_20350 == (int8_t) 2) {
        int64_t segmap_group_sizze_25393;
        
        segmap_group_sizze_25393 = *ctx->tuning_params.renderzisegmap_group_sizze_25373;
        
        int64_t segmap_usable_groups_25394 = sdiv_up64(r_22371, segmap_group_sizze_25393);
        
        if (memblock_alloc_device(ctx, &mem_26095, bytes_26068, "mem_26095")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc_device(ctx, &mem_26098, bytes_26068, "mem_26098")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        
        int32_t virt_num_groups_26474 = sext_i64_i32(sdiv_up64(r_22371, segmap_group_sizze_25393));
        
        {
            err = gpu_kernel_renderzisegmap_25398(ctx, segmap_usable_groups_25394, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_25373, 1, 1, 0, screen_calculations_20357, screen_calculations_20358, screen_calculations_20359, screen_calculations_20360, screen_calculations_20362, screen_calculations_20363, r_22371, ext_mem_26059.mem, ext_mem_26060.mem, mem_26095.mem, mem_26098.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        
        int64_t segmap_group_sizze_25417;
        
        segmap_group_sizze_25417 = *ctx->tuning_params.renderzisegmap_group_sizze_25416;
        
        int64_t segmap_usable_groups_25418 = sdiv_up64(r_22371, segmap_group_sizze_25417);
        
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        
        int32_t virt_num_groups_26483 = sext_i64_i32(sdiv_up64(r_22371, segmap_group_sizze_25417));
        
        {
            err = gpu_kernel_renderzisegmap_25414(ctx, segmap_usable_groups_25418, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_25416, 1, 1, 0, height_20354, width_20367, r_22371, ext_mem_26061.mem, mem_26065.mem, mem_26095.mem, mem_26098.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_unref_device(ctx, &mem_26095, "mem_26095") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26098, "mem_26098") != 0)
            return 1;
        
        int64_t segmap_group_sizze_25572;
        
        segmap_group_sizze_25572 = *ctx->tuning_params.renderzisegmap_group_sizze_25432;
        
        int64_t segmap_usable_groups_25573 = sdiv_up64(binop_x_26062, segmap_group_sizze_25572);
        
        if (memblock_alloc_device(ctx, &mem_26104, bytes_26064, "mem_26104")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        
        int32_t virt_num_groups_26492 = sext_i64_i32(sdiv_up64(height_20354 * width_20367, segmap_group_sizze_25572));
        
        {
            err = gpu_kernel_renderzisegmap_25577(ctx, segmap_usable_groups_25573, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_25432, 1, 1, 0, height_20354, width_20367, mem_26065.mem, mem_26104.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_set_device(ctx, &ext_mem_26105, &mem_26104, "mem_26104") != 0)
            return 1;
    } else {
        int64_t segmap_group_sizze_25662;
        
        segmap_group_sizze_25662 = *ctx->tuning_params.renderzisegmap_group_sizze_25642;
        
        int64_t segmap_usable_groups_25663 = sdiv_up64(r_22371, segmap_group_sizze_25662);
        
        if (memblock_alloc_device(ctx, &mem_26069, bytes_26068, "mem_26069")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc_device(ctx, &mem_26072, bytes_26068, "mem_26072")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        
        int32_t virt_num_groups_26503 = sext_i64_i32(sdiv_up64(r_22371, segmap_group_sizze_25662));
        
        {
            err = gpu_kernel_renderzisegmap_25667(ctx, segmap_usable_groups_25663, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_25642, 1, 1, 0, screen_calculations_20357, screen_calculations_20358, screen_calculations_20359, screen_calculations_20360, screen_calculations_20362, screen_calculations_20363, r_22371, ext_mem_26059.mem, ext_mem_26060.mem, mem_26069.mem, mem_26072.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        
        int64_t segmap_group_sizze_25686;
        
        segmap_group_sizze_25686 = *ctx->tuning_params.renderzisegmap_group_sizze_25685;
        
        int64_t segmap_usable_groups_25687 = sdiv_up64(r_22371, segmap_group_sizze_25686);
        
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        
        int32_t virt_num_groups_26512 = sext_i64_i32(sdiv_up64(r_22371, segmap_group_sizze_25686));
        
        {
            err = gpu_kernel_renderzisegmap_25683(ctx, segmap_usable_groups_25687, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_25685, 1, 1, 0, height_20354, width_20367, r_22371, ext_mem_26061.mem, mem_26065.mem, mem_26069.mem, mem_26072.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_unref_device(ctx, &mem_26069, "mem_26069") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26072, "mem_26072") != 0)
            return 1;
        
        int64_t segmap_group_sizze_25765;
        
        segmap_group_sizze_25765 = *ctx->tuning_params.renderzisegmap_group_sizze_25701;
        
        int64_t segmap_usable_groups_25766 = sdiv_up64(binop_x_26062, segmap_group_sizze_25765);
        
        if (memblock_alloc_device(ctx, &mem_26078, bytes_26064, "mem_26078")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        
        int32_t virt_num_groups_26521 = sext_i64_i32(sdiv_up64(height_20354 * width_20367, segmap_group_sizze_25765));
        
        {
            err = gpu_kernel_renderzisegmap_25770(ctx, segmap_usable_groups_25766, 1, 1, *ctx->tuning_params.renderzisegmap_group_sizze_25701, 1, 1, 0, height_20354, width_20367, mem_26065.mem, mem_26078.mem);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_set_device(ctx, &ext_mem_26105, &mem_26078, "mem_26078") != 0)
            return 1;
    }
    if (memblock_unref_device(ctx, &ext_mem_26059, "ext_mem_26059") != 0)
        return 1;
    if (memblock_unref_device(ctx, &ext_mem_26060, "ext_mem_26060") != 0)
        return 1;
    if (memblock_unref_device(ctx, &ext_mem_26061, "ext_mem_26061") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_26065, "mem_26065") != 0)
        return 1;
    if (memblock_set_device(ctx, &mem_out_26106, &ext_mem_26105, "ext_mem_26105") != 0)
        return 1;
    prim_out_26107 = height_20354;
    prim_out_26108 = width_20367;
    if (memblock_set_device(ctx, &*mem_out_p_26595, &mem_out_26106, "mem_out_26106") != 0)
        return 1;
    *out_prim_out_26596 = prim_out_26107;
    *out_prim_out_26597 = prim_out_26108;
    
  cleanup:
    {
        if (memblock_unref_device(ctx, &mem_26078, "mem_26078") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26072, "mem_26072") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26069, "mem_26069") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26104, "mem_26104") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26098, "mem_26098") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26095, "mem_26095") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26091, "mem_26091") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26085, "mem_26085") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26082, "mem_26082") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26105, "ext_mem_26105") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26065, "mem_26065") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_tmp_26154, "mem_param_tmp_26154") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_tmp_26153, "mem_param_tmp_26153") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_tmp_26152, "mem_param_tmp_26152") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_tmp_26151, "mem_param_tmp_26151") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_tmp_26150, "mem_param_tmp_26150") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_tmp_26149, "mem_param_tmp_26149") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26023, "mem_26023") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26020, "mem_26020") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26017, "mem_26017") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26014, "mem_26014") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26011, "mem_26011") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26008, "mem_26008") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26030, "mem_26030") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_26027, "mem_26027") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25944, "mem_25944") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25940, "mem_25940") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25935, "mem_25935") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25930, "mem_25930") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25927, "mem_25927") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25924, "mem_25924") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25918, "mem_25918") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25913, "mem_25913") != 0)
            return 1;
        if (memblock_unref_device(ctx, &segred_tmp_mem_26258, "segred_tmp_mem_26258") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25909, "mem_25909") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25905, "mem_25905") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25901, "mem_25901") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25898, "mem_25898") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25895, "mem_25895") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25892, "mem_25892") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25998, "mem_25998") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25993, "mem_25993") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25988, "mem_25988") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25983, "mem_25983") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25979, "mem_25979") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25976, "mem_25976") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25973, "mem_25973") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25970, "mem_25970") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25967, "mem_25967") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25964, "mem_25964") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26000, "ext_mem_26000") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26001, "ext_mem_26001") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26002, "ext_mem_26002") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26003, "ext_mem_26003") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26004, "ext_mem_26004") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26005, "ext_mem_26005") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_25887, "mem_param_25887") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_25882, "mem_param_25882") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_25877, "mem_param_25877") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_25872, "mem_param_25872") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_25867, "mem_param_25867") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_25862, "mem_param_25862") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26056, "ext_mem_26056") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26057, "ext_mem_26057") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26058, "ext_mem_26058") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26059, "ext_mem_26059") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26060, "ext_mem_26060") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_26061, "ext_mem_26061") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25857, "mem_25857") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25855, "mem_25855") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25853, "mem_25853") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25851, "mem_25851") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_25849, "mem_25849") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_out_26106, "mem_out_26106") != 0)
            return 1;
    }
    return err;
}
static int futrts_entry_resizze(struct futhark_context *ctx, bool *out_prim_out_26599, float *out_prim_out_26600, int8_t *out_prim_out_26601, int64_t *out_prim_out_26602, int64_t *out_prim_out_26603, float *out_prim_out_26604, int64_t *out_prim_out_26605, int32_t *out_prim_out_26606, int32_t *out_prim_out_26607, float *out_prim_out_26608, float *out_prim_out_26609, float *out_prim_out_26610, float *out_prim_out_26611, int64_t *out_prim_out_26612, float *out_prim_out_26613, float *out_prim_out_26614, float *out_prim_out_26615, float *out_prim_out_26616, float *out_prim_out_26617, int64_t *out_prim_out_26618, int32_t h_16698, int32_t w_16699, bool auto_zzoom_16700, float auto_zzoom_16701, int8_t base_16702, int64_t base_16703, int64_t base_16704, float base_16705, int64_t height_16706, int32_t mouse_16707, int32_t mouse_16708, float screen_calculations_16709, float screen_calculations_16710, float screen_calculations_16711, float screen_calculations_16712, int64_t screen_calculations_16713, float screen_calculations_16714, float screen_calculations_16715, float viewport_16716, float viewport_16717, float viewport_16718, int64_t width_16719)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    bool prim_out_26106;
    float prim_out_26107;
    int8_t prim_out_26108;
    int64_t prim_out_26109;
    int64_t prim_out_26110;
    float prim_out_26111;
    int64_t prim_out_26112;
    int32_t prim_out_26113;
    int32_t prim_out_26114;
    float prim_out_26115;
    float prim_out_26116;
    float prim_out_26117;
    float prim_out_26118;
    int64_t prim_out_26119;
    float prim_out_26120;
    float prim_out_26121;
    float prim_out_26122;
    float prim_out_26123;
    float prim_out_26124;
    int64_t prim_out_26125;
    float log2_res_22829 = futrts_log2_32(viewport_16718);
    float ceil_res_22830 = futrts_ceil32(log2_res_22829);
    int64_t f32_res_22831 = fptosi_f32_i64(ceil_res_22830);
    int64_t max_res_22832 = smax64((int64_t) 0, f32_res_22831);
    bool nonnegative_22833 = sle64((int64_t) 0, max_res_22832);
    bool nonzzero_cert_22834;
    
    if (!nonnegative_22833) {
        set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  squarezoom-random.fut:30:28-85\n"));
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t i32_res_20929 = sext_i32_i64(w_16699);
    int64_t i32_res_20930 = sext_i32_i64(h_16698);
    int64_t precision_scale_22835 = shl64((int64_t) 1, max_res_22832);
    int64_t min_res_22836 = smin64(i32_res_20929, i32_res_20930);
    int64_t precision_22837 = mul64(precision_scale_22835, min_res_22836);
    float i64_res_22838 = sitofp_i64_f32(min_res_22836);
    float xy_factor_inv_22839 = 1.0F / i64_res_22838;
    float i64_res_22840 = sitofp_i64_f32(precision_22837);
    float zs_lhs_22841 = i64_res_22840 / i64_res_22838;
    float dup_arg0_22842 = zs_lhs_22841 / 2.0F;
    float zs_lhs_22843 = viewport_16718 * i64_res_22838;
    float i64_res_22844 = sitofp_i64_f32(precision_scale_22835);
    float zzoom_factor_22845 = zs_lhs_22843 / i64_res_22844;
    int64_t max_arg1_22846 = sub64(i32_res_20929, i32_res_20930);
    int64_t max_res_22847 = smax64((int64_t) 0, max_arg1_22846);
    float i64_res_22848 = sitofp_i64_f32(max_res_22847);
    float offset_22849 = i64_res_22848 / i64_res_22838;
    int64_t max_arg1_22850 = sub64(i32_res_20930, i32_res_20929);
    int64_t max_res_22851 = smax64((int64_t) 0, max_arg1_22850);
    float i64_res_22852 = sitofp_i64_f32(max_res_22851);
    float offset_22853 = i64_res_22852 / i64_res_22838;
    float zt_res_22854 = 0.5F * offset_22853;
    float zt_res_22855 = 0.5F * offset_22849;
    float zp_res_22856 = 0.5F + zt_res_22854;
    float zp_res_22857 = 0.5F + zt_res_22855;
    float zt_res_22858 = viewport_16716 * viewport_16718;
    float zt_res_22859 = viewport_16717 * viewport_16718;
    float zm_res_22860 = zp_res_22856 - zt_res_22858;
    float zm_res_22861 = zp_res_22857 - zt_res_22859;
    float zt_res_22862 = i64_res_22838 * zm_res_22860;
    float zt_res_22863 = i64_res_22838 * zm_res_22861;
    
    prim_out_26106 = auto_zzoom_16700;
    prim_out_26107 = auto_zzoom_16701;
    prim_out_26108 = base_16702;
    prim_out_26109 = base_16703;
    prim_out_26110 = base_16704;
    prim_out_26111 = base_16705;
    prim_out_26112 = i32_res_20930;
    prim_out_26113 = mouse_16707;
    prim_out_26114 = mouse_16708;
    prim_out_26115 = dup_arg0_22842;
    prim_out_26116 = dup_arg0_22842;
    prim_out_26117 = zt_res_22862;
    prim_out_26118 = zt_res_22863;
    prim_out_26119 = precision_22837;
    prim_out_26120 = xy_factor_inv_22839;
    prim_out_26121 = zzoom_factor_22845;
    prim_out_26122 = viewport_16716;
    prim_out_26123 = viewport_16717;
    prim_out_26124 = viewport_16718;
    prim_out_26125 = i32_res_20929;
    *out_prim_out_26599 = prim_out_26106;
    *out_prim_out_26600 = prim_out_26107;
    *out_prim_out_26601 = prim_out_26108;
    *out_prim_out_26602 = prim_out_26109;
    *out_prim_out_26603 = prim_out_26110;
    *out_prim_out_26604 = prim_out_26111;
    *out_prim_out_26605 = prim_out_26112;
    *out_prim_out_26606 = prim_out_26113;
    *out_prim_out_26607 = prim_out_26114;
    *out_prim_out_26608 = prim_out_26115;
    *out_prim_out_26609 = prim_out_26116;
    *out_prim_out_26610 = prim_out_26117;
    *out_prim_out_26611 = prim_out_26118;
    *out_prim_out_26612 = prim_out_26119;
    *out_prim_out_26613 = prim_out_26120;
    *out_prim_out_26614 = prim_out_26121;
    *out_prim_out_26615 = prim_out_26122;
    *out_prim_out_26616 = prim_out_26123;
    *out_prim_out_26617 = prim_out_26124;
    *out_prim_out_26618 = prim_out_26125;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_step(struct futhark_context *ctx, bool *out_prim_out_26619, float *out_prim_out_26620, int8_t *out_prim_out_26621, int64_t *out_prim_out_26622, int64_t *out_prim_out_26623, float *out_prim_out_26624, int64_t *out_prim_out_26625, int32_t *out_prim_out_26626, int32_t *out_prim_out_26627, float *out_prim_out_26628, float *out_prim_out_26629, float *out_prim_out_26630, float *out_prim_out_26631, int64_t *out_prim_out_26632, float *out_prim_out_26633, float *out_prim_out_26634, float *out_prim_out_26635, float *out_prim_out_26636, float *out_prim_out_26637, int64_t *out_prim_out_26638, float td_17886, bool auto_zzoom_17887, float auto_zzoom_17888, int8_t base_17889, int64_t base_17890, int64_t base_17891, float base_17892, int64_t height_17893, int32_t mouse_17894, int32_t mouse_17895, float screen_calculations_17896, float screen_calculations_17897, float screen_calculations_17898, float screen_calculations_17899, int64_t screen_calculations_17900, float screen_calculations_17901, float screen_calculations_17902, float viewport_17903, float viewport_17904, float viewport_17905, int64_t width_17906)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    bool prim_out_26106;
    float prim_out_26107;
    int8_t prim_out_26108;
    int64_t prim_out_26109;
    int64_t prim_out_26110;
    float prim_out_26111;
    int64_t prim_out_26112;
    int32_t prim_out_26113;
    int32_t prim_out_26114;
    float prim_out_26115;
    float prim_out_26116;
    float prim_out_26117;
    float prim_out_26118;
    int64_t prim_out_26119;
    float prim_out_26120;
    float prim_out_26121;
    float prim_out_26122;
    float prim_out_26123;
    float prim_out_26124;
    int64_t prim_out_26125;
    float case_res_23397;
    float case_res_23398;
    float case_res_23399;
    float case_res_23400;
    int64_t case_res_23401;
    float case_res_23402;
    float case_res_23403;
    float case_res_23404;
    float case_res_23405;
    float case_res_23406;
    
    if (auto_zzoom_17887 == 1) {
        float s_23705 = auto_zzoom_17888 * viewport_17905;
        float log2_res_23708 = futrts_log2_32(s_23705);
        float ceil_res_23709 = futrts_ceil32(log2_res_23708);
        int64_t f32_res_23710 = fptosi_f32_i64(ceil_res_23709);
        int64_t max_res_23711 = smax64((int64_t) 0, f32_res_23710);
        bool nonnegative_23712 = sle64((int64_t) 0, max_res_23711);
        bool nonzzero_cert_23713;
        
        if (!nonnegative_23712) {
            set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  squarezoom-random.fut:30:28-85\n   #1  ../zoomable.fut:49:34-101\n   #2  ../zoomable.fut:85:8-36\n   #3  squarezoom-random_wrapper.fut:31:3-27\n   #4  squarezoom-random_wrapper.fut:30:1-31:27\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t min_res_23687 = smin64(height_17893, width_17906);
        float i64_res_23688 = sitofp_i64_f32(min_res_23687);
        float xy_factor_23689 = viewport_17905 * i64_res_23688;
        int32_t i64_res_23690 = sext_i64_i32(width_17906);
        int32_t zm_rhs_23691 = sdiv32(i64_res_23690, 2);
        int32_t r32_arg0_23692 = sub32(mouse_17894, zm_rhs_23691);
        float i32_res_23693 = sitofp_i32_f32(r32_arg0_23692);
        float zm_lhs_23694 = i32_res_23693 / xy_factor_23689;
        float zs_rhs_23695 = auto_zzoom_17888 * xy_factor_23689;
        float zm_rhs_23696 = i32_res_23693 / zs_rhs_23695;
        float xd_23697 = zm_lhs_23694 - zm_rhs_23696;
        int32_t i64_res_23698 = sext_i64_i32(height_17893);
        int32_t zm_rhs_23699 = sdiv32(i64_res_23698, 2);
        int32_t r32_arg0_23700 = sub32(mouse_17895, zm_rhs_23699);
        float i32_res_23701 = sitofp_i32_f32(r32_arg0_23700);
        float zm_lhs_23702 = i32_res_23701 / xy_factor_23689;
        float zm_rhs_23703 = i32_res_23701 / zs_rhs_23695;
        float yd_23704 = zm_lhs_23702 - zm_rhs_23703;
        float s_23706 = viewport_17903 + xd_23697;
        float s_23707 = viewport_17904 + yd_23704;
        int64_t precision_scale_23714 = shl64((int64_t) 1, max_res_23711);
        int64_t precision_23715 = mul64(min_res_23687, precision_scale_23714);
        float xy_factor_inv_23716 = 1.0F / i64_res_23688;
        float i64_res_23717 = sitofp_i64_f32(precision_23715);
        float zs_lhs_23718 = i64_res_23717 / i64_res_23688;
        float dup_arg0_23719 = zs_lhs_23718 / 2.0F;
        float zs_lhs_23720 = i64_res_23688 * s_23705;
        float i64_res_23721 = sitofp_i64_f32(precision_scale_23714);
        float zzoom_factor_23722 = zs_lhs_23720 / i64_res_23721;
        int64_t max_arg1_23723 = sub64(width_17906, height_17893);
        int64_t max_res_23724 = smax64((int64_t) 0, max_arg1_23723);
        float i64_res_23725 = sitofp_i64_f32(max_res_23724);
        float offset_23726 = i64_res_23725 / i64_res_23688;
        int64_t max_arg1_23727 = sub64(height_17893, width_17906);
        int64_t max_res_23728 = smax64((int64_t) 0, max_arg1_23727);
        float i64_res_23729 = sitofp_i64_f32(max_res_23728);
        float offset_23730 = i64_res_23729 / i64_res_23688;
        float zt_res_23731 = 0.5F * offset_23730;
        float zt_res_23732 = 0.5F * offset_23726;
        float zp_res_23733 = 0.5F + zt_res_23731;
        float zp_res_23734 = 0.5F + zt_res_23732;
        float zt_res_23735 = s_23705 * s_23706;
        float zt_res_23736 = s_23705 * s_23707;
        float zm_res_23737 = zp_res_23733 - zt_res_23735;
        float zm_res_23738 = zp_res_23734 - zt_res_23736;
        float zt_res_23739 = i64_res_23688 * zm_res_23737;
        float zt_res_23740 = i64_res_23688 * zm_res_23738;
        
        case_res_23397 = dup_arg0_23719;
        case_res_23398 = dup_arg0_23719;
        case_res_23399 = zt_res_23739;
        case_res_23400 = zt_res_23740;
        case_res_23401 = precision_23715;
        case_res_23402 = xy_factor_inv_23716;
        case_res_23403 = zzoom_factor_23722;
        case_res_23404 = s_23706;
        case_res_23405 = s_23707;
        case_res_23406 = s_23705;
    } else {
        case_res_23397 = screen_calculations_17896;
        case_res_23398 = screen_calculations_17897;
        case_res_23399 = screen_calculations_17898;
        case_res_23400 = screen_calculations_17899;
        case_res_23401 = screen_calculations_17900;
        case_res_23402 = screen_calculations_17901;
        case_res_23403 = screen_calculations_17902;
        case_res_23404 = viewport_17903;
        case_res_23405 = viewport_17904;
        case_res_23406 = viewport_17905;
    }
    
    float tmp_23595 = td_17886 + base_17892;
    
    prim_out_26106 = auto_zzoom_17887;
    prim_out_26107 = auto_zzoom_17888;
    prim_out_26108 = base_17889;
    prim_out_26109 = base_17890;
    prim_out_26110 = base_17891;
    prim_out_26111 = tmp_23595;
    prim_out_26112 = height_17893;
    prim_out_26113 = mouse_17894;
    prim_out_26114 = mouse_17895;
    prim_out_26115 = case_res_23397;
    prim_out_26116 = case_res_23398;
    prim_out_26117 = case_res_23399;
    prim_out_26118 = case_res_23400;
    prim_out_26119 = case_res_23401;
    prim_out_26120 = case_res_23402;
    prim_out_26121 = case_res_23403;
    prim_out_26122 = case_res_23404;
    prim_out_26123 = case_res_23405;
    prim_out_26124 = case_res_23406;
    prim_out_26125 = width_17906;
    *out_prim_out_26619 = prim_out_26106;
    *out_prim_out_26620 = prim_out_26107;
    *out_prim_out_26621 = prim_out_26108;
    *out_prim_out_26622 = prim_out_26109;
    *out_prim_out_26623 = prim_out_26110;
    *out_prim_out_26624 = prim_out_26111;
    *out_prim_out_26625 = prim_out_26112;
    *out_prim_out_26626 = prim_out_26113;
    *out_prim_out_26627 = prim_out_26114;
    *out_prim_out_26628 = prim_out_26115;
    *out_prim_out_26629 = prim_out_26116;
    *out_prim_out_26630 = prim_out_26117;
    *out_prim_out_26631 = prim_out_26118;
    *out_prim_out_26632 = prim_out_26119;
    *out_prim_out_26633 = prim_out_26120;
    *out_prim_out_26634 = prim_out_26121;
    *out_prim_out_26635 = prim_out_26122;
    *out_prim_out_26636 = prim_out_26123;
    *out_prim_out_26637 = prim_out_26124;
    *out_prim_out_26638 = prim_out_26125;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_text_colour(struct futhark_context *ctx, int32_t *out_prim_out_26639, bool auto_zzoom_20413, float auto_zzoom_20414, int8_t base_20415, int64_t base_20416, int64_t base_20417, float base_20418, int64_t height_20419, int32_t mouse_20420, int32_t mouse_20421, float screen_calculations_20422, float screen_calculations_20423, float screen_calculations_20424, float screen_calculations_20425, int64_t screen_calculations_20426, float screen_calculations_20427, float screen_calculations_20428, float viewport_20429, float viewport_20430, float viewport_20431, int64_t width_20432)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    int32_t prim_out_26106;
    int32_t text_colour_res_20702;
    
    if (base_20415 == (int8_t) 1) {
        text_colour_res_20702 = -16777216;
    } else if (base_20415 == (int8_t) 2) {
        text_colour_res_20702 = -16777216;
    } else {
        text_colour_res_20702 = -16711936;
    }
    prim_out_26106 = text_colour_res_20702;
    *out_prim_out_26639 = prim_out_26106;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_text_content(struct futhark_context *ctx, int32_t *out_prim_out_26640, int32_t *out_prim_out_26641, float *out_prim_out_26642, float *out_prim_out_26643, float *out_prim_out_26644, int32_t *out_prim_out_26645, float render_duration_20548, bool auto_zzoom_20549, float auto_zzoom_20550, int8_t base_20551, int64_t base_20552, int64_t base_20553, float base_20554, int64_t height_20555, int32_t mouse_20556, int32_t mouse_20557, float screen_calculations_20558, float screen_calculations_20559, float screen_calculations_20560, float screen_calculations_20561, int64_t screen_calculations_20562, float screen_calculations_20563, float screen_calculations_20564, float viewport_20565, float viewport_20566, float viewport_20567, int64_t width_20568)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    int32_t prim_out_26106;
    int32_t prim_out_26107;
    float prim_out_26108;
    float prim_out_26109;
    float prim_out_26110;
    int32_t prim_out_26111;
    int32_t approach_20928;
    
    if (base_20551 == (int8_t) 1) {
        approach_20928 = 0;
    } else if (base_20551 == (int8_t) 2) {
        approach_20928 = 1;
    } else {
        approach_20928 = 2;
    }
    
    int32_t bool_res_20929 = btoi_bool_i32(auto_zzoom_20549);
    int32_t f32_res_20930 = fptosi_f32_i32(render_duration_20548);
    
    prim_out_26106 = f32_res_20930;
    prim_out_26107 = approach_20928;
    prim_out_26108 = viewport_20565;
    prim_out_26109 = viewport_20566;
    prim_out_26110 = viewport_20567;
    prim_out_26111 = bool_res_20929;
    *out_prim_out_26640 = prim_out_26106;
    *out_prim_out_26641 = prim_out_26107;
    *out_prim_out_26642 = prim_out_26108;
    *out_prim_out_26643 = prim_out_26109;
    *out_prim_out_26644 = prim_out_26110;
    *out_prim_out_26645 = prim_out_26111;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_text_format(struct futhark_context *ctx, struct memblock_device *mem_out_p_26646, int64_t *out_prim_out_26647)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_26106;
    
    mem_out_26106.references = NULL;
    
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    int64_t prim_out_26107;
    
    if (memblock_set_device(ctx, &mem_out_26106, &mem_25847, "mem_25847") != 0)
        return 1;
    prim_out_26107 = (int64_t) 119;
    if (memblock_set_device(ctx, &*mem_out_p_26646, &mem_out_26106, "mem_out_26106") != 0)
        return 1;
    *out_prim_out_26647 = prim_out_26107;
    
  cleanup:
    {
        if (memblock_unref_device(ctx, &mem_out_26106, "mem_out_26106") != 0)
            return 1;
    }
    return err;
}
static int futrts_entry_wheel(struct futhark_context *ctx, bool *out_prim_out_26648, float *out_prim_out_26649, int8_t *out_prim_out_26650, int64_t *out_prim_out_26651, int64_t *out_prim_out_26652, float *out_prim_out_26653, int64_t *out_prim_out_26654, int32_t *out_prim_out_26655, int32_t *out_prim_out_26656, float *out_prim_out_26657, float *out_prim_out_26658, float *out_prim_out_26659, float *out_prim_out_26660, int64_t *out_prim_out_26661, float *out_prim_out_26662, float *out_prim_out_26663, float *out_prim_out_26664, float *out_prim_out_26665, float *out_prim_out_26666, int64_t *out_prim_out_26667, int32_t dx_17798, int32_t dy_17799, bool auto_zzoom_17800, float auto_zzoom_17801, int8_t base_17802, int64_t base_17803, int64_t base_17804, float base_17805, int64_t height_17806, int32_t mouse_17807, int32_t mouse_17808, float screen_calculations_17809, float screen_calculations_17810, float screen_calculations_17811, float screen_calculations_17812, int64_t screen_calculations_17813, float screen_calculations_17814, float screen_calculations_17815, float viewport_17816, float viewport_17817, float viewport_17818, int64_t width_17819)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
    struct memblock_device mem_25847 = ctx->constants->mem_25847;
    bool prim_out_26106;
    float prim_out_26107;
    int8_t prim_out_26108;
    int64_t prim_out_26109;
    int64_t prim_out_26110;
    float prim_out_26111;
    int64_t prim_out_26112;
    int32_t prim_out_26113;
    int32_t prim_out_26114;
    float prim_out_26115;
    float prim_out_26116;
    float prim_out_26117;
    float prim_out_26118;
    int64_t prim_out_26119;
    float prim_out_26120;
    float prim_out_26121;
    float prim_out_26122;
    float prim_out_26123;
    float prim_out_26124;
    int64_t prim_out_26125;
    float case_res_23520;
    float case_res_23521;
    float case_res_23522;
    float case_res_23523;
    float case_res_23524;
    int64_t case_res_23525;
    float case_res_23526;
    float case_res_23527;
    float case_res_23528;
    float case_res_23529;
    float case_res_23530;
    
    if (auto_zzoom_17800 == 1) {
        float i32_res_23687 = sitofp_i32_f32(dy_17799);
        float zp_rhs_23688 = 1.0e-2F * i32_res_23687;
        float tmp_23689 = auto_zzoom_17801 + zp_rhs_23688;
        
        case_res_23520 = tmp_23689;
        case_res_23521 = screen_calculations_17809;
        case_res_23522 = screen_calculations_17810;
        case_res_23523 = screen_calculations_17811;
        case_res_23524 = screen_calculations_17812;
        case_res_23525 = screen_calculations_17813;
        case_res_23526 = screen_calculations_17814;
        case_res_23527 = screen_calculations_17815;
        case_res_23528 = viewport_17816;
        case_res_23529 = viewport_17817;
        case_res_23530 = viewport_17818;
    } else {
        float i32_res_23534 = sitofp_i32_f32(dy_17799);
        float zp_rhs_23535 = 1.0e-2F * i32_res_23534;
        float zzoom_factor_23536 = 1.0F + zp_rhs_23535;
        float s_23555 = viewport_17818 * zzoom_factor_23536;
        float log2_res_23558 = futrts_log2_32(s_23555);
        float ceil_res_23559 = futrts_ceil32(log2_res_23558);
        int64_t f32_res_23560 = fptosi_f32_i64(ceil_res_23559);
        int64_t max_res_23561 = smax64((int64_t) 0, f32_res_23560);
        bool nonnegative_23562 = sle64((int64_t) 0, max_res_23561);
        bool nonzzero_cert_23563;
        
        if (!nonnegative_23562) {
            set_error(ctx, msgprintf("Error: %s\n\nBacktrace:\n%s", "negative exponent", "-> #0  squarezoom-random.fut:30:28-85\n   #1  ../zoomable.fut:49:34-101\n   #2  ../zoomable.fut:85:8-36\n   #3  squarezoom-random_wrapper.fut:28:3-34\n   #4  squarezoom-random_wrapper.fut:27:1-28:34\n"));
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t min_res_23537 = smin64(height_17806, width_17819);
        float i64_res_23538 = sitofp_i64_f32(min_res_23537);
        float xy_factor_23539 = viewport_17818 * i64_res_23538;
        int32_t i64_res_23540 = sext_i64_i32(width_17819);
        int32_t zm_rhs_23541 = sdiv32(i64_res_23540, 2);
        int32_t r32_arg0_23542 = sub32(mouse_17807, zm_rhs_23541);
        float i32_res_23543 = sitofp_i32_f32(r32_arg0_23542);
        float zm_lhs_23544 = i32_res_23543 / xy_factor_23539;
        float zs_rhs_23545 = zzoom_factor_23536 * xy_factor_23539;
        float zm_rhs_23546 = i32_res_23543 / zs_rhs_23545;
        float xd_23547 = zm_lhs_23544 - zm_rhs_23546;
        int32_t i64_res_23548 = sext_i64_i32(height_17806);
        int32_t zm_rhs_23549 = sdiv32(i64_res_23548, 2);
        int32_t r32_arg0_23550 = sub32(mouse_17808, zm_rhs_23549);
        float i32_res_23551 = sitofp_i32_f32(r32_arg0_23550);
        float zm_lhs_23552 = i32_res_23551 / xy_factor_23539;
        float zm_rhs_23553 = i32_res_23551 / zs_rhs_23545;
        float yd_23554 = zm_lhs_23552 - zm_rhs_23553;
        float s_23556 = viewport_17816 + xd_23547;
        float s_23557 = viewport_17817 + yd_23554;
        int64_t precision_scale_23564 = shl64((int64_t) 1, max_res_23561);
        int64_t precision_23565 = mul64(min_res_23537, precision_scale_23564);
        float xy_factor_inv_23566 = 1.0F / i64_res_23538;
        float i64_res_23567 = sitofp_i64_f32(precision_23565);
        float zs_lhs_23568 = i64_res_23567 / i64_res_23538;
        float dup_arg0_23569 = zs_lhs_23568 / 2.0F;
        float zs_lhs_23570 = i64_res_23538 * s_23555;
        float i64_res_23571 = sitofp_i64_f32(precision_scale_23564);
        float zzoom_factor_23572 = zs_lhs_23570 / i64_res_23571;
        int64_t max_arg1_23573 = sub64(width_17819, height_17806);
        int64_t max_res_23574 = smax64((int64_t) 0, max_arg1_23573);
        float i64_res_23575 = sitofp_i64_f32(max_res_23574);
        float offset_23576 = i64_res_23575 / i64_res_23538;
        int64_t max_arg1_23577 = sub64(height_17806, width_17819);
        int64_t max_res_23578 = smax64((int64_t) 0, max_arg1_23577);
        float i64_res_23579 = sitofp_i64_f32(max_res_23578);
        float offset_23580 = i64_res_23579 / i64_res_23538;
        float zt_res_23581 = 0.5F * offset_23580;
        float zt_res_23582 = 0.5F * offset_23576;
        float zp_res_23583 = 0.5F + zt_res_23581;
        float zp_res_23584 = 0.5F + zt_res_23582;
        float zt_res_23585 = s_23555 * s_23556;
        float zt_res_23586 = s_23555 * s_23557;
        float zm_res_23587 = zp_res_23583 - zt_res_23585;
        float zm_res_23588 = zp_res_23584 - zt_res_23586;
        float zt_res_23589 = i64_res_23538 * zm_res_23587;
        float zt_res_23590 = i64_res_23538 * zm_res_23588;
        
        case_res_23520 = auto_zzoom_17801;
        case_res_23521 = dup_arg0_23569;
        case_res_23522 = dup_arg0_23569;
        case_res_23523 = zt_res_23589;
        case_res_23524 = zt_res_23590;
        case_res_23525 = precision_23565;
        case_res_23526 = xy_factor_inv_23566;
        case_res_23527 = zzoom_factor_23572;
        case_res_23528 = s_23556;
        case_res_23529 = s_23557;
        case_res_23530 = s_23555;
    }
    prim_out_26106 = auto_zzoom_17800;
    prim_out_26107 = case_res_23520;
    prim_out_26108 = base_17802;
    prim_out_26109 = base_17803;
    prim_out_26110 = base_17804;
    prim_out_26111 = base_17805;
    prim_out_26112 = height_17806;
    prim_out_26113 = mouse_17807;
    prim_out_26114 = mouse_17808;
    prim_out_26115 = case_res_23521;
    prim_out_26116 = case_res_23522;
    prim_out_26117 = case_res_23523;
    prim_out_26118 = case_res_23524;
    prim_out_26119 = case_res_23525;
    prim_out_26120 = case_res_23526;
    prim_out_26121 = case_res_23527;
    prim_out_26122 = case_res_23528;
    prim_out_26123 = case_res_23529;
    prim_out_26124 = case_res_23530;
    prim_out_26125 = width_17819;
    *out_prim_out_26648 = prim_out_26106;
    *out_prim_out_26649 = prim_out_26107;
    *out_prim_out_26650 = prim_out_26108;
    *out_prim_out_26651 = prim_out_26109;
    *out_prim_out_26652 = prim_out_26110;
    *out_prim_out_26653 = prim_out_26111;
    *out_prim_out_26654 = prim_out_26112;
    *out_prim_out_26655 = prim_out_26113;
    *out_prim_out_26656 = prim_out_26114;
    *out_prim_out_26657 = prim_out_26115;
    *out_prim_out_26658 = prim_out_26116;
    *out_prim_out_26659 = prim_out_26117;
    *out_prim_out_26660 = prim_out_26118;
    *out_prim_out_26661 = prim_out_26119;
    *out_prim_out_26662 = prim_out_26120;
    *out_prim_out_26663 = prim_out_26121;
    *out_prim_out_26664 = prim_out_26122;
    *out_prim_out_26665 = prim_out_26123;
    *out_prim_out_26666 = prim_out_26124;
    *out_prim_out_26667 = prim_out_26125;
    
  cleanup:
    { }
    return err;
}

int futhark_entry_grab_mouse(struct futhark_context *ctx, bool *out0)
{
    bool prim_out_26106 = 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    if (ret == 0) {
        ret = futrts_entry_grab_mouse(ctx, &prim_out_26106);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            *out0 = prim_out_26106;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_init(struct futhark_context *ctx, struct futhark_opaque_state **out0, const uint32_t in0, const int32_t in1, const int32_t in2)
{
    int32_t seed_16471 = 0;
    int32_t h_16472 = 0;
    int32_t w_16473 = 0;
    bool prim_out_26106 = 0;
    float prim_out_26107 = 0.0F;
    int8_t prim_out_26108 = (int8_t) 0;
    int64_t prim_out_26109 = (int64_t) 0;
    int64_t prim_out_26110 = (int64_t) 0;
    float prim_out_26111 = 0.0F;
    int64_t prim_out_26112 = (int64_t) 0;
    int32_t prim_out_26113 = 0;
    int32_t prim_out_26114 = 0;
    float prim_out_26115 = 0.0F;
    float prim_out_26116 = 0.0F;
    float prim_out_26117 = 0.0F;
    float prim_out_26118 = 0.0F;
    int64_t prim_out_26119 = (int64_t) 0;
    float prim_out_26120 = 0.0F;
    float prim_out_26121 = 0.0F;
    float prim_out_26122 = 0.0F;
    float prim_out_26123 = 0.0F;
    float prim_out_26124 = 0.0F;
    int64_t prim_out_26125 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    seed_16471 = in0;
    h_16472 = in1;
    w_16473 = in2;
    if (ret == 0) {
        ret = futrts_entry_init(ctx, &prim_out_26106, &prim_out_26107, &prim_out_26108, &prim_out_26109, &prim_out_26110, &prim_out_26111, &prim_out_26112, &prim_out_26113, &prim_out_26114, &prim_out_26115, &prim_out_26116, &prim_out_26117, &prim_out_26118, &prim_out_26119, &prim_out_26120, &prim_out_26121, &prim_out_26122, &prim_out_26123, &prim_out_26124, &prim_out_26125, seed_16471, h_16472, w_16473);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            assert((*out0 = (struct futhark_opaque_state *) malloc(sizeof(struct futhark_opaque_state))) != NULL);
            (*out0)->v0 = prim_out_26106;
            (*out0)->v1 = prim_out_26107;
            (*out0)->v2 = prim_out_26108;
            (*out0)->v3 = prim_out_26109;
            (*out0)->v4 = prim_out_26110;
            (*out0)->v5 = prim_out_26111;
            (*out0)->v6 = prim_out_26112;
            (*out0)->v7 = prim_out_26113;
            (*out0)->v8 = prim_out_26114;
            (*out0)->v9 = prim_out_26115;
            (*out0)->v10 = prim_out_26116;
            (*out0)->v11 = prim_out_26117;
            (*out0)->v12 = prim_out_26118;
            (*out0)->v13 = prim_out_26119;
            (*out0)->v14 = prim_out_26120;
            (*out0)->v15 = prim_out_26121;
            (*out0)->v16 = prim_out_26122;
            (*out0)->v17 = prim_out_26123;
            (*out0)->v18 = prim_out_26124;
            (*out0)->v19 = prim_out_26125;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_key(struct futhark_context *ctx, struct futhark_opaque_state **out0, const int32_t in0, const int32_t in1, const struct futhark_opaque_state *in2)
{
    int32_t e_17618 = 0;
    int32_t key_17619 = 0;
    bool auto_zzoom_17620 = 0;
    float auto_zzoom_17621 = 0.0F;
    int8_t base_17622 = (int8_t) 0;
    int64_t base_17623 = (int64_t) 0;
    int64_t base_17624 = (int64_t) 0;
    float base_17625 = 0.0F;
    int64_t height_17626 = (int64_t) 0;
    int32_t mouse_17627 = 0;
    int32_t mouse_17628 = 0;
    float screen_calculations_17629 = 0.0F;
    float screen_calculations_17630 = 0.0F;
    float screen_calculations_17631 = 0.0F;
    float screen_calculations_17632 = 0.0F;
    int64_t screen_calculations_17633 = (int64_t) 0;
    float screen_calculations_17634 = 0.0F;
    float screen_calculations_17635 = 0.0F;
    float viewport_17636 = 0.0F;
    float viewport_17637 = 0.0F;
    float viewport_17638 = 0.0F;
    int64_t width_17639 = (int64_t) 0;
    bool prim_out_26106 = 0;
    float prim_out_26107 = 0.0F;
    int8_t prim_out_26108 = (int8_t) 0;
    int64_t prim_out_26109 = (int64_t) 0;
    int64_t prim_out_26110 = (int64_t) 0;
    float prim_out_26111 = 0.0F;
    int64_t prim_out_26112 = (int64_t) 0;
    int32_t prim_out_26113 = 0;
    int32_t prim_out_26114 = 0;
    float prim_out_26115 = 0.0F;
    float prim_out_26116 = 0.0F;
    float prim_out_26117 = 0.0F;
    float prim_out_26118 = 0.0F;
    int64_t prim_out_26119 = (int64_t) 0;
    float prim_out_26120 = 0.0F;
    float prim_out_26121 = 0.0F;
    float prim_out_26122 = 0.0F;
    float prim_out_26123 = 0.0F;
    float prim_out_26124 = 0.0F;
    int64_t prim_out_26125 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    e_17618 = in0;
    key_17619 = in1;
    auto_zzoom_17620 = in2->v0;
    auto_zzoom_17621 = in2->v1;
    base_17622 = in2->v2;
    base_17623 = in2->v3;
    base_17624 = in2->v4;
    base_17625 = in2->v5;
    height_17626 = in2->v6;
    mouse_17627 = in2->v7;
    mouse_17628 = in2->v8;
    screen_calculations_17629 = in2->v9;
    screen_calculations_17630 = in2->v10;
    screen_calculations_17631 = in2->v11;
    screen_calculations_17632 = in2->v12;
    screen_calculations_17633 = in2->v13;
    screen_calculations_17634 = in2->v14;
    screen_calculations_17635 = in2->v15;
    viewport_17636 = in2->v16;
    viewport_17637 = in2->v17;
    viewport_17638 = in2->v18;
    width_17639 = in2->v19;
    if (ret == 0) {
        ret = futrts_entry_key(ctx, &prim_out_26106, &prim_out_26107, &prim_out_26108, &prim_out_26109, &prim_out_26110, &prim_out_26111, &prim_out_26112, &prim_out_26113, &prim_out_26114, &prim_out_26115, &prim_out_26116, &prim_out_26117, &prim_out_26118, &prim_out_26119, &prim_out_26120, &prim_out_26121, &prim_out_26122, &prim_out_26123, &prim_out_26124, &prim_out_26125, e_17618, key_17619, auto_zzoom_17620, auto_zzoom_17621, base_17622, base_17623, base_17624, base_17625, height_17626, mouse_17627, mouse_17628, screen_calculations_17629, screen_calculations_17630, screen_calculations_17631, screen_calculations_17632, screen_calculations_17633, screen_calculations_17634, screen_calculations_17635, viewport_17636, viewport_17637, viewport_17638, width_17639);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            assert((*out0 = (struct futhark_opaque_state *) malloc(sizeof(struct futhark_opaque_state))) != NULL);
            (*out0)->v0 = prim_out_26106;
            (*out0)->v1 = prim_out_26107;
            (*out0)->v2 = prim_out_26108;
            (*out0)->v3 = prim_out_26109;
            (*out0)->v4 = prim_out_26110;
            (*out0)->v5 = prim_out_26111;
            (*out0)->v6 = prim_out_26112;
            (*out0)->v7 = prim_out_26113;
            (*out0)->v8 = prim_out_26114;
            (*out0)->v9 = prim_out_26115;
            (*out0)->v10 = prim_out_26116;
            (*out0)->v11 = prim_out_26117;
            (*out0)->v12 = prim_out_26118;
            (*out0)->v13 = prim_out_26119;
            (*out0)->v14 = prim_out_26120;
            (*out0)->v15 = prim_out_26121;
            (*out0)->v16 = prim_out_26122;
            (*out0)->v17 = prim_out_26123;
            (*out0)->v18 = prim_out_26124;
            (*out0)->v19 = prim_out_26125;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_mouse(struct futhark_context *ctx, struct futhark_opaque_state **out0, const int32_t in0, const int32_t in1, const int32_t in2, const struct futhark_opaque_state *in3)
{
    int32_t buttons_17708 = 0;
    int32_t x_17709 = 0;
    int32_t y_17710 = 0;
    bool auto_zzoom_17711 = 0;
    float auto_zzoom_17712 = 0.0F;
    int8_t base_17713 = (int8_t) 0;
    int64_t base_17714 = (int64_t) 0;
    int64_t base_17715 = (int64_t) 0;
    float base_17716 = 0.0F;
    int64_t height_17717 = (int64_t) 0;
    int32_t mouse_17718 = 0;
    int32_t mouse_17719 = 0;
    float screen_calculations_17720 = 0.0F;
    float screen_calculations_17721 = 0.0F;
    float screen_calculations_17722 = 0.0F;
    float screen_calculations_17723 = 0.0F;
    int64_t screen_calculations_17724 = (int64_t) 0;
    float screen_calculations_17725 = 0.0F;
    float screen_calculations_17726 = 0.0F;
    float viewport_17727 = 0.0F;
    float viewport_17728 = 0.0F;
    float viewport_17729 = 0.0F;
    int64_t width_17730 = (int64_t) 0;
    bool prim_out_26106 = 0;
    float prim_out_26107 = 0.0F;
    int8_t prim_out_26108 = (int8_t) 0;
    int64_t prim_out_26109 = (int64_t) 0;
    int64_t prim_out_26110 = (int64_t) 0;
    float prim_out_26111 = 0.0F;
    int64_t prim_out_26112 = (int64_t) 0;
    int32_t prim_out_26113 = 0;
    int32_t prim_out_26114 = 0;
    float prim_out_26115 = 0.0F;
    float prim_out_26116 = 0.0F;
    float prim_out_26117 = 0.0F;
    float prim_out_26118 = 0.0F;
    int64_t prim_out_26119 = (int64_t) 0;
    float prim_out_26120 = 0.0F;
    float prim_out_26121 = 0.0F;
    float prim_out_26122 = 0.0F;
    float prim_out_26123 = 0.0F;
    float prim_out_26124 = 0.0F;
    int64_t prim_out_26125 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    buttons_17708 = in0;
    x_17709 = in1;
    y_17710 = in2;
    auto_zzoom_17711 = in3->v0;
    auto_zzoom_17712 = in3->v1;
    base_17713 = in3->v2;
    base_17714 = in3->v3;
    base_17715 = in3->v4;
    base_17716 = in3->v5;
    height_17717 = in3->v6;
    mouse_17718 = in3->v7;
    mouse_17719 = in3->v8;
    screen_calculations_17720 = in3->v9;
    screen_calculations_17721 = in3->v10;
    screen_calculations_17722 = in3->v11;
    screen_calculations_17723 = in3->v12;
    screen_calculations_17724 = in3->v13;
    screen_calculations_17725 = in3->v14;
    screen_calculations_17726 = in3->v15;
    viewport_17727 = in3->v16;
    viewport_17728 = in3->v17;
    viewport_17729 = in3->v18;
    width_17730 = in3->v19;
    if (ret == 0) {
        ret = futrts_entry_mouse(ctx, &prim_out_26106, &prim_out_26107, &prim_out_26108, &prim_out_26109, &prim_out_26110, &prim_out_26111, &prim_out_26112, &prim_out_26113, &prim_out_26114, &prim_out_26115, &prim_out_26116, &prim_out_26117, &prim_out_26118, &prim_out_26119, &prim_out_26120, &prim_out_26121, &prim_out_26122, &prim_out_26123, &prim_out_26124, &prim_out_26125, buttons_17708, x_17709, y_17710, auto_zzoom_17711, auto_zzoom_17712, base_17713, base_17714, base_17715, base_17716, height_17717, mouse_17718, mouse_17719, screen_calculations_17720, screen_calculations_17721, screen_calculations_17722, screen_calculations_17723, screen_calculations_17724, screen_calculations_17725, screen_calculations_17726, viewport_17727, viewport_17728, viewport_17729, width_17730);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            assert((*out0 = (struct futhark_opaque_state *) malloc(sizeof(struct futhark_opaque_state))) != NULL);
            (*out0)->v0 = prim_out_26106;
            (*out0)->v1 = prim_out_26107;
            (*out0)->v2 = prim_out_26108;
            (*out0)->v3 = prim_out_26109;
            (*out0)->v4 = prim_out_26110;
            (*out0)->v5 = prim_out_26111;
            (*out0)->v6 = prim_out_26112;
            (*out0)->v7 = prim_out_26113;
            (*out0)->v8 = prim_out_26114;
            (*out0)->v9 = prim_out_26115;
            (*out0)->v10 = prim_out_26116;
            (*out0)->v11 = prim_out_26117;
            (*out0)->v12 = prim_out_26118;
            (*out0)->v13 = prim_out_26119;
            (*out0)->v14 = prim_out_26120;
            (*out0)->v15 = prim_out_26121;
            (*out0)->v16 = prim_out_26122;
            (*out0)->v17 = prim_out_26123;
            (*out0)->v18 = prim_out_26124;
            (*out0)->v19 = prim_out_26125;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_render(struct futhark_context *ctx, struct futhark_u32_2d **out0, const struct futhark_opaque_state *in0)
{
    bool auto_zzoom_20348 = 0;
    float auto_zzoom_20349 = 0.0F;
    int8_t base_20350 = (int8_t) 0;
    int64_t base_20351 = (int64_t) 0;
    int64_t base_20352 = (int64_t) 0;
    float base_20353 = 0.0F;
    int64_t height_20354 = (int64_t) 0;
    int32_t mouse_20355 = 0;
    int32_t mouse_20356 = 0;
    float screen_calculations_20357 = 0.0F;
    float screen_calculations_20358 = 0.0F;
    float screen_calculations_20359 = 0.0F;
    float screen_calculations_20360 = 0.0F;
    int64_t screen_calculations_20361 = (int64_t) 0;
    float screen_calculations_20362 = 0.0F;
    float screen_calculations_20363 = 0.0F;
    float viewport_20364 = 0.0F;
    float viewport_20365 = 0.0F;
    float viewport_20366 = 0.0F;
    int64_t width_20367 = (int64_t) 0;
    int64_t prim_out_26107 = (int64_t) 0;
    int64_t prim_out_26108 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock_device mem_out_26106;
    
    mem_out_26106.references = NULL;
    auto_zzoom_20348 = in0->v0;
    auto_zzoom_20349 = in0->v1;
    base_20350 = in0->v2;
    base_20351 = in0->v3;
    base_20352 = in0->v4;
    base_20353 = in0->v5;
    height_20354 = in0->v6;
    mouse_20355 = in0->v7;
    mouse_20356 = in0->v8;
    screen_calculations_20357 = in0->v9;
    screen_calculations_20358 = in0->v10;
    screen_calculations_20359 = in0->v11;
    screen_calculations_20360 = in0->v12;
    screen_calculations_20361 = in0->v13;
    screen_calculations_20362 = in0->v14;
    screen_calculations_20363 = in0->v15;
    viewport_20364 = in0->v16;
    viewport_20365 = in0->v17;
    viewport_20366 = in0->v18;
    width_20367 = in0->v19;
    if (ret == 0) {
        ret = futrts_entry_render(ctx, &mem_out_26106, &prim_out_26107, &prim_out_26108, auto_zzoom_20348, auto_zzoom_20349, base_20350, base_20351, base_20352, base_20353, height_20354, mouse_20355, mouse_20356, screen_calculations_20357, screen_calculations_20358, screen_calculations_20359, screen_calculations_20360, screen_calculations_20361, screen_calculations_20362, screen_calculations_20363, viewport_20364, viewport_20365, viewport_20366, width_20367);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            assert((*out0 = (struct futhark_u32_2d *) malloc(sizeof(struct futhark_u32_2d))) != NULL);
            (*out0)->mem = mem_out_26106;
            (*out0)->shape[0] = prim_out_26107;
            (*out0)->shape[1] = prim_out_26108;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_resize(struct futhark_context *ctx, struct futhark_opaque_state **out0, const int32_t in0, const int32_t in1, const struct futhark_opaque_state *in2)
{
    int32_t h_16698 = 0;
    int32_t w_16699 = 0;
    bool auto_zzoom_16700 = 0;
    float auto_zzoom_16701 = 0.0F;
    int8_t base_16702 = (int8_t) 0;
    int64_t base_16703 = (int64_t) 0;
    int64_t base_16704 = (int64_t) 0;
    float base_16705 = 0.0F;
    int64_t height_16706 = (int64_t) 0;
    int32_t mouse_16707 = 0;
    int32_t mouse_16708 = 0;
    float screen_calculations_16709 = 0.0F;
    float screen_calculations_16710 = 0.0F;
    float screen_calculations_16711 = 0.0F;
    float screen_calculations_16712 = 0.0F;
    int64_t screen_calculations_16713 = (int64_t) 0;
    float screen_calculations_16714 = 0.0F;
    float screen_calculations_16715 = 0.0F;
    float viewport_16716 = 0.0F;
    float viewport_16717 = 0.0F;
    float viewport_16718 = 0.0F;
    int64_t width_16719 = (int64_t) 0;
    bool prim_out_26106 = 0;
    float prim_out_26107 = 0.0F;
    int8_t prim_out_26108 = (int8_t) 0;
    int64_t prim_out_26109 = (int64_t) 0;
    int64_t prim_out_26110 = (int64_t) 0;
    float prim_out_26111 = 0.0F;
    int64_t prim_out_26112 = (int64_t) 0;
    int32_t prim_out_26113 = 0;
    int32_t prim_out_26114 = 0;
    float prim_out_26115 = 0.0F;
    float prim_out_26116 = 0.0F;
    float prim_out_26117 = 0.0F;
    float prim_out_26118 = 0.0F;
    int64_t prim_out_26119 = (int64_t) 0;
    float prim_out_26120 = 0.0F;
    float prim_out_26121 = 0.0F;
    float prim_out_26122 = 0.0F;
    float prim_out_26123 = 0.0F;
    float prim_out_26124 = 0.0F;
    int64_t prim_out_26125 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    h_16698 = in0;
    w_16699 = in1;
    auto_zzoom_16700 = in2->v0;
    auto_zzoom_16701 = in2->v1;
    base_16702 = in2->v2;
    base_16703 = in2->v3;
    base_16704 = in2->v4;
    base_16705 = in2->v5;
    height_16706 = in2->v6;
    mouse_16707 = in2->v7;
    mouse_16708 = in2->v8;
    screen_calculations_16709 = in2->v9;
    screen_calculations_16710 = in2->v10;
    screen_calculations_16711 = in2->v11;
    screen_calculations_16712 = in2->v12;
    screen_calculations_16713 = in2->v13;
    screen_calculations_16714 = in2->v14;
    screen_calculations_16715 = in2->v15;
    viewport_16716 = in2->v16;
    viewport_16717 = in2->v17;
    viewport_16718 = in2->v18;
    width_16719 = in2->v19;
    if (ret == 0) {
        ret = futrts_entry_resizze(ctx, &prim_out_26106, &prim_out_26107, &prim_out_26108, &prim_out_26109, &prim_out_26110, &prim_out_26111, &prim_out_26112, &prim_out_26113, &prim_out_26114, &prim_out_26115, &prim_out_26116, &prim_out_26117, &prim_out_26118, &prim_out_26119, &prim_out_26120, &prim_out_26121, &prim_out_26122, &prim_out_26123, &prim_out_26124, &prim_out_26125, h_16698, w_16699, auto_zzoom_16700, auto_zzoom_16701, base_16702, base_16703, base_16704, base_16705, height_16706, mouse_16707, mouse_16708, screen_calculations_16709, screen_calculations_16710, screen_calculations_16711, screen_calculations_16712, screen_calculations_16713, screen_calculations_16714, screen_calculations_16715, viewport_16716, viewport_16717, viewport_16718, width_16719);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            assert((*out0 = (struct futhark_opaque_state *) malloc(sizeof(struct futhark_opaque_state))) != NULL);
            (*out0)->v0 = prim_out_26106;
            (*out0)->v1 = prim_out_26107;
            (*out0)->v2 = prim_out_26108;
            (*out0)->v3 = prim_out_26109;
            (*out0)->v4 = prim_out_26110;
            (*out0)->v5 = prim_out_26111;
            (*out0)->v6 = prim_out_26112;
            (*out0)->v7 = prim_out_26113;
            (*out0)->v8 = prim_out_26114;
            (*out0)->v9 = prim_out_26115;
            (*out0)->v10 = prim_out_26116;
            (*out0)->v11 = prim_out_26117;
            (*out0)->v12 = prim_out_26118;
            (*out0)->v13 = prim_out_26119;
            (*out0)->v14 = prim_out_26120;
            (*out0)->v15 = prim_out_26121;
            (*out0)->v16 = prim_out_26122;
            (*out0)->v17 = prim_out_26123;
            (*out0)->v18 = prim_out_26124;
            (*out0)->v19 = prim_out_26125;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_step(struct futhark_context *ctx, struct futhark_opaque_state **out0, const float in0, const struct futhark_opaque_state *in1)
{
    float td_17886 = 0.0F;
    bool auto_zzoom_17887 = 0;
    float auto_zzoom_17888 = 0.0F;
    int8_t base_17889 = (int8_t) 0;
    int64_t base_17890 = (int64_t) 0;
    int64_t base_17891 = (int64_t) 0;
    float base_17892 = 0.0F;
    int64_t height_17893 = (int64_t) 0;
    int32_t mouse_17894 = 0;
    int32_t mouse_17895 = 0;
    float screen_calculations_17896 = 0.0F;
    float screen_calculations_17897 = 0.0F;
    float screen_calculations_17898 = 0.0F;
    float screen_calculations_17899 = 0.0F;
    int64_t screen_calculations_17900 = (int64_t) 0;
    float screen_calculations_17901 = 0.0F;
    float screen_calculations_17902 = 0.0F;
    float viewport_17903 = 0.0F;
    float viewport_17904 = 0.0F;
    float viewport_17905 = 0.0F;
    int64_t width_17906 = (int64_t) 0;
    bool prim_out_26106 = 0;
    float prim_out_26107 = 0.0F;
    int8_t prim_out_26108 = (int8_t) 0;
    int64_t prim_out_26109 = (int64_t) 0;
    int64_t prim_out_26110 = (int64_t) 0;
    float prim_out_26111 = 0.0F;
    int64_t prim_out_26112 = (int64_t) 0;
    int32_t prim_out_26113 = 0;
    int32_t prim_out_26114 = 0;
    float prim_out_26115 = 0.0F;
    float prim_out_26116 = 0.0F;
    float prim_out_26117 = 0.0F;
    float prim_out_26118 = 0.0F;
    int64_t prim_out_26119 = (int64_t) 0;
    float prim_out_26120 = 0.0F;
    float prim_out_26121 = 0.0F;
    float prim_out_26122 = 0.0F;
    float prim_out_26123 = 0.0F;
    float prim_out_26124 = 0.0F;
    int64_t prim_out_26125 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    td_17886 = in0;
    auto_zzoom_17887 = in1->v0;
    auto_zzoom_17888 = in1->v1;
    base_17889 = in1->v2;
    base_17890 = in1->v3;
    base_17891 = in1->v4;
    base_17892 = in1->v5;
    height_17893 = in1->v6;
    mouse_17894 = in1->v7;
    mouse_17895 = in1->v8;
    screen_calculations_17896 = in1->v9;
    screen_calculations_17897 = in1->v10;
    screen_calculations_17898 = in1->v11;
    screen_calculations_17899 = in1->v12;
    screen_calculations_17900 = in1->v13;
    screen_calculations_17901 = in1->v14;
    screen_calculations_17902 = in1->v15;
    viewport_17903 = in1->v16;
    viewport_17904 = in1->v17;
    viewport_17905 = in1->v18;
    width_17906 = in1->v19;
    if (ret == 0) {
        ret = futrts_entry_step(ctx, &prim_out_26106, &prim_out_26107, &prim_out_26108, &prim_out_26109, &prim_out_26110, &prim_out_26111, &prim_out_26112, &prim_out_26113, &prim_out_26114, &prim_out_26115, &prim_out_26116, &prim_out_26117, &prim_out_26118, &prim_out_26119, &prim_out_26120, &prim_out_26121, &prim_out_26122, &prim_out_26123, &prim_out_26124, &prim_out_26125, td_17886, auto_zzoom_17887, auto_zzoom_17888, base_17889, base_17890, base_17891, base_17892, height_17893, mouse_17894, mouse_17895, screen_calculations_17896, screen_calculations_17897, screen_calculations_17898, screen_calculations_17899, screen_calculations_17900, screen_calculations_17901, screen_calculations_17902, viewport_17903, viewport_17904, viewport_17905, width_17906);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            assert((*out0 = (struct futhark_opaque_state *) malloc(sizeof(struct futhark_opaque_state))) != NULL);
            (*out0)->v0 = prim_out_26106;
            (*out0)->v1 = prim_out_26107;
            (*out0)->v2 = prim_out_26108;
            (*out0)->v3 = prim_out_26109;
            (*out0)->v4 = prim_out_26110;
            (*out0)->v5 = prim_out_26111;
            (*out0)->v6 = prim_out_26112;
            (*out0)->v7 = prim_out_26113;
            (*out0)->v8 = prim_out_26114;
            (*out0)->v9 = prim_out_26115;
            (*out0)->v10 = prim_out_26116;
            (*out0)->v11 = prim_out_26117;
            (*out0)->v12 = prim_out_26118;
            (*out0)->v13 = prim_out_26119;
            (*out0)->v14 = prim_out_26120;
            (*out0)->v15 = prim_out_26121;
            (*out0)->v16 = prim_out_26122;
            (*out0)->v17 = prim_out_26123;
            (*out0)->v18 = prim_out_26124;
            (*out0)->v19 = prim_out_26125;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_text_colour(struct futhark_context *ctx, uint32_t *out0, const struct futhark_opaque_state *in0)
{
    bool auto_zzoom_20413 = 0;
    float auto_zzoom_20414 = 0.0F;
    int8_t base_20415 = (int8_t) 0;
    int64_t base_20416 = (int64_t) 0;
    int64_t base_20417 = (int64_t) 0;
    float base_20418 = 0.0F;
    int64_t height_20419 = (int64_t) 0;
    int32_t mouse_20420 = 0;
    int32_t mouse_20421 = 0;
    float screen_calculations_20422 = 0.0F;
    float screen_calculations_20423 = 0.0F;
    float screen_calculations_20424 = 0.0F;
    float screen_calculations_20425 = 0.0F;
    int64_t screen_calculations_20426 = (int64_t) 0;
    float screen_calculations_20427 = 0.0F;
    float screen_calculations_20428 = 0.0F;
    float viewport_20429 = 0.0F;
    float viewport_20430 = 0.0F;
    float viewport_20431 = 0.0F;
    int64_t width_20432 = (int64_t) 0;
    int32_t prim_out_26106 = 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    auto_zzoom_20413 = in0->v0;
    auto_zzoom_20414 = in0->v1;
    base_20415 = in0->v2;
    base_20416 = in0->v3;
    base_20417 = in0->v4;
    base_20418 = in0->v5;
    height_20419 = in0->v6;
    mouse_20420 = in0->v7;
    mouse_20421 = in0->v8;
    screen_calculations_20422 = in0->v9;
    screen_calculations_20423 = in0->v10;
    screen_calculations_20424 = in0->v11;
    screen_calculations_20425 = in0->v12;
    screen_calculations_20426 = in0->v13;
    screen_calculations_20427 = in0->v14;
    screen_calculations_20428 = in0->v15;
    viewport_20429 = in0->v16;
    viewport_20430 = in0->v17;
    viewport_20431 = in0->v18;
    width_20432 = in0->v19;
    if (ret == 0) {
        ret = futrts_entry_text_colour(ctx, &prim_out_26106, auto_zzoom_20413, auto_zzoom_20414, base_20415, base_20416, base_20417, base_20418, height_20419, mouse_20420, mouse_20421, screen_calculations_20422, screen_calculations_20423, screen_calculations_20424, screen_calculations_20425, screen_calculations_20426, screen_calculations_20427, screen_calculations_20428, viewport_20429, viewport_20430, viewport_20431, width_20432);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            *out0 = prim_out_26106;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_text_content(struct futhark_context *ctx, int32_t *out0, int32_t *out1, float *out2, float *out3, float *out4, int32_t *out5, const float in0, const struct futhark_opaque_state *in1)
{
    float render_duration_20548 = 0.0F;
    bool auto_zzoom_20549 = 0;
    float auto_zzoom_20550 = 0.0F;
    int8_t base_20551 = (int8_t) 0;
    int64_t base_20552 = (int64_t) 0;
    int64_t base_20553 = (int64_t) 0;
    float base_20554 = 0.0F;
    int64_t height_20555 = (int64_t) 0;
    int32_t mouse_20556 = 0;
    int32_t mouse_20557 = 0;
    float screen_calculations_20558 = 0.0F;
    float screen_calculations_20559 = 0.0F;
    float screen_calculations_20560 = 0.0F;
    float screen_calculations_20561 = 0.0F;
    int64_t screen_calculations_20562 = (int64_t) 0;
    float screen_calculations_20563 = 0.0F;
    float screen_calculations_20564 = 0.0F;
    float viewport_20565 = 0.0F;
    float viewport_20566 = 0.0F;
    float viewport_20567 = 0.0F;
    int64_t width_20568 = (int64_t) 0;
    int32_t prim_out_26106 = 0;
    int32_t prim_out_26107 = 0;
    float prim_out_26108 = 0.0F;
    float prim_out_26109 = 0.0F;
    float prim_out_26110 = 0.0F;
    int32_t prim_out_26111 = 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    render_duration_20548 = in0;
    auto_zzoom_20549 = in1->v0;
    auto_zzoom_20550 = in1->v1;
    base_20551 = in1->v2;
    base_20552 = in1->v3;
    base_20553 = in1->v4;
    base_20554 = in1->v5;
    height_20555 = in1->v6;
    mouse_20556 = in1->v7;
    mouse_20557 = in1->v8;
    screen_calculations_20558 = in1->v9;
    screen_calculations_20559 = in1->v10;
    screen_calculations_20560 = in1->v11;
    screen_calculations_20561 = in1->v12;
    screen_calculations_20562 = in1->v13;
    screen_calculations_20563 = in1->v14;
    screen_calculations_20564 = in1->v15;
    viewport_20565 = in1->v16;
    viewport_20566 = in1->v17;
    viewport_20567 = in1->v18;
    width_20568 = in1->v19;
    if (ret == 0) {
        ret = futrts_entry_text_content(ctx, &prim_out_26106, &prim_out_26107, &prim_out_26108, &prim_out_26109, &prim_out_26110, &prim_out_26111, render_duration_20548, auto_zzoom_20549, auto_zzoom_20550, base_20551, base_20552, base_20553, base_20554, height_20555, mouse_20556, mouse_20557, screen_calculations_20558, screen_calculations_20559, screen_calculations_20560, screen_calculations_20561, screen_calculations_20562, screen_calculations_20563, screen_calculations_20564, viewport_20565, viewport_20566, viewport_20567, width_20568);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            *out0 = prim_out_26106;
            *out1 = prim_out_26107;
            *out2 = prim_out_26108;
            *out3 = prim_out_26109;
            *out4 = prim_out_26110;
            *out5 = prim_out_26111;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_text_format(struct futhark_context *ctx, struct futhark_u8_1d **out0)
{
    int64_t prim_out_26107 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock_device mem_out_26106;
    
    mem_out_26106.references = NULL;
    if (ret == 0) {
        ret = futrts_entry_text_format(ctx, &mem_out_26106, &prim_out_26107);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            assert((*out0 = (struct futhark_u8_1d *) malloc(sizeof(struct futhark_u8_1d))) != NULL);
            (*out0)->mem = mem_out_26106;
            (*out0)->shape[0] = prim_out_26107;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_wheel(struct futhark_context *ctx, struct futhark_opaque_state **out0, const int32_t in0, const int32_t in1, const struct futhark_opaque_state *in2)
{
    int32_t dx_17798 = 0;
    int32_t dy_17799 = 0;
    bool auto_zzoom_17800 = 0;
    float auto_zzoom_17801 = 0.0F;
    int8_t base_17802 = (int8_t) 0;
    int64_t base_17803 = (int64_t) 0;
    int64_t base_17804 = (int64_t) 0;
    float base_17805 = 0.0F;
    int64_t height_17806 = (int64_t) 0;
    int32_t mouse_17807 = 0;
    int32_t mouse_17808 = 0;
    float screen_calculations_17809 = 0.0F;
    float screen_calculations_17810 = 0.0F;
    float screen_calculations_17811 = 0.0F;
    float screen_calculations_17812 = 0.0F;
    int64_t screen_calculations_17813 = (int64_t) 0;
    float screen_calculations_17814 = 0.0F;
    float screen_calculations_17815 = 0.0F;
    float viewport_17816 = 0.0F;
    float viewport_17817 = 0.0F;
    float viewport_17818 = 0.0F;
    int64_t width_17819 = (int64_t) 0;
    bool prim_out_26106 = 0;
    float prim_out_26107 = 0.0F;
    int8_t prim_out_26108 = (int8_t) 0;
    int64_t prim_out_26109 = (int64_t) 0;
    int64_t prim_out_26110 = (int64_t) 0;
    float prim_out_26111 = 0.0F;
    int64_t prim_out_26112 = (int64_t) 0;
    int32_t prim_out_26113 = 0;
    int32_t prim_out_26114 = 0;
    float prim_out_26115 = 0.0F;
    float prim_out_26116 = 0.0F;
    float prim_out_26117 = 0.0F;
    float prim_out_26118 = 0.0F;
    int64_t prim_out_26119 = (int64_t) 0;
    float prim_out_26120 = 0.0F;
    float prim_out_26121 = 0.0F;
    float prim_out_26122 = 0.0F;
    float prim_out_26123 = 0.0F;
    float prim_out_26124 = 0.0F;
    int64_t prim_out_26125 = (int64_t) 0;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    dx_17798 = in0;
    dy_17799 = in1;
    auto_zzoom_17800 = in2->v0;
    auto_zzoom_17801 = in2->v1;
    base_17802 = in2->v2;
    base_17803 = in2->v3;
    base_17804 = in2->v4;
    base_17805 = in2->v5;
    height_17806 = in2->v6;
    mouse_17807 = in2->v7;
    mouse_17808 = in2->v8;
    screen_calculations_17809 = in2->v9;
    screen_calculations_17810 = in2->v10;
    screen_calculations_17811 = in2->v11;
    screen_calculations_17812 = in2->v12;
    screen_calculations_17813 = in2->v13;
    screen_calculations_17814 = in2->v14;
    screen_calculations_17815 = in2->v15;
    viewport_17816 = in2->v16;
    viewport_17817 = in2->v17;
    viewport_17818 = in2->v18;
    width_17819 = in2->v19;
    if (ret == 0) {
        ret = futrts_entry_wheel(ctx, &prim_out_26106, &prim_out_26107, &prim_out_26108, &prim_out_26109, &prim_out_26110, &prim_out_26111, &prim_out_26112, &prim_out_26113, &prim_out_26114, &prim_out_26115, &prim_out_26116, &prim_out_26117, &prim_out_26118, &prim_out_26119, &prim_out_26120, &prim_out_26121, &prim_out_26122, &prim_out_26123, &prim_out_26124, &prim_out_26125, dx_17798, dy_17799, auto_zzoom_17800, auto_zzoom_17801, base_17802, base_17803, base_17804, base_17805, height_17806, mouse_17807, mouse_17808, screen_calculations_17809, screen_calculations_17810, screen_calculations_17811, screen_calculations_17812, screen_calculations_17813, screen_calculations_17814, screen_calculations_17815, viewport_17816, viewport_17817, viewport_17818, width_17819);
        if (ret == 0) {
            struct memblock_device counters_mem_26260 = ctx->constants->counters_mem_26260;
            struct memblock_device mem_25847 = ctx->constants->mem_25847;
            
            assert((*out0 = (struct futhark_opaque_state *) malloc(sizeof(struct futhark_opaque_state))) != NULL);
            (*out0)->v0 = prim_out_26106;
            (*out0)->v1 = prim_out_26107;
            (*out0)->v2 = prim_out_26108;
            (*out0)->v3 = prim_out_26109;
            (*out0)->v4 = prim_out_26110;
            (*out0)->v5 = prim_out_26111;
            (*out0)->v6 = prim_out_26112;
            (*out0)->v7 = prim_out_26113;
            (*out0)->v8 = prim_out_26114;
            (*out0)->v9 = prim_out_26115;
            (*out0)->v10 = prim_out_26116;
            (*out0)->v11 = prim_out_26117;
            (*out0)->v12 = prim_out_26118;
            (*out0)->v13 = prim_out_26119;
            (*out0)->v14 = prim_out_26120;
            (*out0)->v15 = prim_out_26121;
            (*out0)->v16 = prim_out_26122;
            (*out0)->v17 = prim_out_26123;
            (*out0)->v18 = prim_out_26124;
            (*out0)->v19 = prim_out_26125;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
  
